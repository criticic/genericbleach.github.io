(window.webpackJsonp = window.webpackJsonp || []).push([
    ["chunk-4f2ac058"], {
        "09fa": function(t, e, n) {
            var r = n("4588"),
                i = n("9def");
            t.exports = function(t) {
                if (void 0 === t) return 0;
                var e = r(t),
                    n = i(e);
                if (e !== n) throw RangeError("Wrong length!");
                return n
            }
        },
        "0f88": function(t, e, n) {
            for (var r, i = n("7726"), o = n("32e9"), a = n("ca5a"), s = a("typed_array"), c = a("view"), u = !(!i.ArrayBuffer || !i.DataView), l = u, h = 0, p = "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(","); h < 9;)(r = i[p[h++]]) ? (o(r.prototype, s, !0), o(r.prototype, c, !0)) : l = !1;
            t.exports = {
                ABV: u,
                CONSTR: l,
                TYPED: s,
                VIEW: c
            }
        },
        "28a5": function(t, e, n) {
            "use strict";
            var r = n("aae3"),
                i = n("cb7c"),
                o = n("ebd6"),
                a = n("0390"),
                s = n("9def"),
                c = n("5f1b"),
                u = n("520a"),
                l = n("79e5"),
                h = Math.min,
                p = [].push,
                d = "split",
                f = "length",
                m = "lastIndex",
                v = 4294967295,
                g = !l(function() {
                    RegExp(v, "y")
                });
            n("214f")("split", 2, function(t, e, n, l) {
                var y;
                return y = "c" == "abbc" [d](/(b)*/)[1] || 4 != "test" [d](/(?:)/, -1)[f] || 2 != "ab" [d](/(?:ab)*/)[f] || 4 != "." [d](/(.?)(.?)/)[f] || "." [d](/()()/)[f] > 1 || "" [d](/.?/)[f] ? function(t, e) {
                    var i = String(this);
                    if (void 0 === t && 0 === e) return [];
                    if (!r(t)) return n.call(i, t, e);
                    for (var o, a, s, c = [], l = (t.ignoreCase ? "i" : "") + (t.multiline ? "m" : "") + (t.unicode ? "u" : "") + (t.sticky ? "y" : ""), h = 0, d = void 0 === e ? v : e >>> 0, g = new RegExp(t.source, l + "g");
                        (o = u.call(g, i)) && !((a = g[m]) > h && (c.push(i.slice(h, o.index)), o[f] > 1 && o.index < i[f] && p.apply(c, o.slice(1)), s = o[0][f], h = a, c[f] >= d));) g[m] === o.index && g[m]++;
                    return h === i[f] ? !s && g.test("") || c.push("") : c.push(i.slice(h)), c[f] > d ? c.slice(0, d) : c
                } : "0" [d](void 0, 0)[f] ? function(t, e) {
                    return void 0 === t && 0 === e ? [] : n.call(this, t, e)
                } : n, [function(n, r) {
                    var i = t(this),
                        o = null == n ? void 0 : n[e];
                    return void 0 !== o ? o.call(n, i, r) : y.call(String(i), n, r)
                }, function(t, e) {
                    var r = l(y, t, this, e, y !== n);
                    if (r.done) return r.value;
                    var u = i(t),
                        p = String(this),
                        d = o(u, RegExp),
                        f = u.unicode,
                        m = (u.ignoreCase ? "i" : "") + (u.multiline ? "m" : "") + (u.unicode ? "u" : "") + (g ? "y" : "g"),
                        x = new d(g ? u : "^(?:" + u.source + ")", m),
                        b = void 0 === e ? v : e >>> 0;
                    if (0 === b) return [];
                    if (0 === p.length) return null === c(x, p) ? [p] : [];
                    for (var w = 0, _ = 0, M = []; _ < p.length;) {
                        x.lastIndex = g ? _ : 0;
                        var E, S = c(x, g ? p : p.slice(_));
                        if (null === S || (E = h(s(x.lastIndex + (g ? 0 : _)), p.length)) === w) _ = a(p, _, f);
                        else {
                            if (M.push(p.slice(w, _)), M.length === b) return M;
                            for (var T = 1; T <= S.length - 1; T++)
                                if (M.push(S[T]), M.length === b) return M;
                            _ = w = E
                        }
                    }
                    return M.push(p.slice(w)), M
                }]
            })
        },
        "34ef": function(t, e, n) {
            n("ec30")("Uint8", 1, function(t) {
                return function(e, n, r) {
                    return t(this, e, n, r)
                }
            })
        },
        "36bd": function(t, e, n) {
            "use strict";
            var r = n("4bf8"),
                i = n("77f1"),
                o = n("9def");
            t.exports = function(t) {
                for (var e = r(this), n = o(e.length), a = arguments.length, s = i(a > 1 ? arguments[1] : void 0, n), c = a > 2 ? arguments[2] : void 0, u = void 0 === c ? n : i(c, n); u > s;) e[s++] = t;
                return e
            }
        },
        "3b2b": function(t, e, n) {
            var r = n("7726"),
                i = n("5dbc"),
                o = n("86cc").f,
                a = n("9093").f,
                s = n("aae3"),
                c = n("0bfb"),
                u = r.RegExp,
                l = u,
                h = u.prototype,
                p = /a/g,
                d = /a/g,
                f = new u(p) !== p;
            if (n("9e1e") && (!f || n("79e5")(function() {
                    return d[n("2b4c")("match")] = !1, u(p) != p || u(d) == d || "/a/i" != u(p, "i")
                }))) {
                u = function(t, e) {
                    var n = this instanceof u,
                        r = s(t),
                        o = void 0 === e;
                    return !n && r && t.constructor === u && o ? t : i(f ? new l(r && !o ? t.source : t, e) : l((r = t instanceof u) ? t.source : t, r && o ? c.call(t) : e), n ? this : h, u)
                };
                for (var m = function(t) {
                        t in u || o(u, t, {
                            configurable: !0,
                            get: function() {
                                return l[t]
                            },
                            set: function(e) {
                                l[t] = e
                            }
                        })
                    }, v = a(l), g = 0; v.length > g;) m(v[g++]);
                h.constructor = u, u.prototype = h, n("2aba")(r, "RegExp", u)
            }
            n("7a56")("RegExp")
        },
        4026: function(t, e, n) {
            "use strict";
            n("456d"), n("c5f6");
            var r = n("7618");
            n("ac6a"), n("7f7f"), n("d225"), n("b0b4"), n("8615"), n("28a5");
            n("4328");

            function i(t) {
                var e = "#";
                for (var n in t)
                    if ("object" !== Object(r.a)(t[n])) e += "".concat(n, "=").concat(t[n], "&");
                    else {
                        var i = Object.values(t[n]);
                        e += "".concat(n, "=").concat(i, "&")
                    }
                history.replaceState(null, null, document.location.pathname + e)
            }! function(t, e) {
                var n, r, i = !1
            }(i, 100);
            var o = function(t) {
                window.location.reload()
            };
            window.addEventListener("hashchange", function(t) {
                o(t)
            }), n("abc8"), n("fa81")
        },
        4127: function(t, e, n) {
            "use strict";
            var r = n("d233"),
                i = n("b313"),
                o = {
                    brackets: function(t) {
                        return t + "[]"
                    },
                    indices: function(t, e) {
                        return t + "[" + e + "]"
                    },
                    repeat: function(t) {
                        return t
                    }
                },
                a = Date.prototype.toISOString,
                s = {
                    delimiter: "&",
                    encode: !0,
                    encoder: r.encode,
                    encodeValuesOnly: !1,
                    serializeDate: function(t) {
                        return a.call(t)
                    },
                    skipNulls: !1,
                    strictNullHandling: !1
                },
                c = function t(e, n, i, o, a, c, u, l, h, p, d, f) {
                    var m = e;
                    if ("function" == typeof u) m = u(n, m);
                    else if (m instanceof Date) m = p(m);
                    else if (null === m) {
                        if (o) return c && !f ? c(n, s.encoder) : n;
                        m = ""
                    }
                    if ("string" == typeof m || "number" == typeof m || "boolean" == typeof m || r.isBuffer(m)) return c ? [d(f ? n : c(n, s.encoder)) + "=" + d(c(m, s.encoder))] : [d(n) + "=" + d(String(m))];
                    var v, g = [];
                    if (void 0 === m) return g;
                    if (Array.isArray(u)) v = u;
                    else {
                        var y = Object.keys(m);
                        v = l ? y.sort(l) : y
                    }
                    for (var x = 0; x < v.length; ++x) {
                        var b = v[x];
                        a && null === m[b] || (g = Array.isArray(m) ? g.concat(t(m[b], i(n, b), i, o, a, c, u, l, h, p, d, f)) : g.concat(t(m[b], n + (h ? "." + b : "[" + b + "]"), i, o, a, c, u, l, h, p, d, f)))
                    }
                    return g
                };
            t.exports = function(t, e) {
                var n = t,
                    a = e ? r.assign({}, e) : {};
                if (null !== a.encoder && void 0 !== a.encoder && "function" != typeof a.encoder) throw new TypeError("Encoder has to be a function.");
                var u = void 0 === a.delimiter ? s.delimiter : a.delimiter,
                    l = "boolean" == typeof a.strictNullHandling ? a.strictNullHandling : s.strictNullHandling,
                    h = "boolean" == typeof a.skipNulls ? a.skipNulls : s.skipNulls,
                    p = "boolean" == typeof a.encode ? a.encode : s.encode,
                    d = "function" == typeof a.encoder ? a.encoder : s.encoder,
                    f = "function" == typeof a.sort ? a.sort : null,
                    m = void 0 !== a.allowDots && a.allowDots,
                    v = "function" == typeof a.serializeDate ? a.serializeDate : s.serializeDate,
                    g = "boolean" == typeof a.encodeValuesOnly ? a.encodeValuesOnly : s.encodeValuesOnly;
                if (void 0 === a.format) a.format = i.default;
                else if (!Object.prototype.hasOwnProperty.call(i.formatters, a.format)) throw new TypeError("Unknown format option provided.");
                var y, x, b = i.formatters[a.format];
                "function" == typeof a.filter ? n = (x = a.filter)("", n) : Array.isArray(a.filter) && (y = x = a.filter);
                var w, _ = [];
                if ("object" != typeof n || null === n) return "";
                w = a.arrayFormat in o ? a.arrayFormat : "indices" in a ? a.indices ? "indices" : "repeat" : "indices";
                var M = o[w];
                y || (y = Object.keys(n)), f && y.sort(f);
                for (var E = 0; E < y.length; ++E) {
                    var S = y[E];
                    h && null === n[S] || (_ = _.concat(c(n[S], S, M, l, h, p ? d : null, x, f, m, v, b, g)))
                }
                var T = _.join(u),
                    A = !0 === a.addQueryPrefix ? "?" : "";
                return T.length > 0 ? A + T : ""
            }
        },
        4328: function(t, e, n) {
            "use strict";
            var r = n("4127"),
                i = n("9e6a"),
                o = n("b313");
            t.exports = {
                formats: o,
                parse: i,
                stringify: r
            }
        },
        "438c": function(t, e, n) {
            "use strict";
            n.d(e, "a", function() {
                return r
            });
            var r = function(t) {
                return t <= 0 ? 0 : t >= 1 ? 1 : t * t * t * (t * (6 * t - 15) + 10)
            }
        },
        "504c": function(t, e, n) {
            var r = n("9e1e"),
                i = n("0d58"),
                o = n("6821"),
                a = n("52a7").f;
            t.exports = function(t) {
                return function(e) {
                    for (var n, s = o(e), c = i(s), u = c.length, l = 0, h = []; u > l;) n = c[l++], r && !a.call(s, n) || h.push(t ? [n, s[n]] : s[n]);
                    return h
                }
            }
        },
        "5a89": function(t, e, n) {
            "use strict";

            function r() {}
            n.r(e), n.d(e, "ACESFilmicToneMapping", function() {
                return ct
            }), n.d(e, "AddEquation", function() {
                return R
            }), n.d(e, "AddOperation", function() {
                return nt
            }), n.d(e, "AdditiveBlending", function() {
                return T
            }), n.d(e, "AlphaFormat", function() {
                return Nt
            }), n.d(e, "AlwaysDepth", function() {
                return X
            }), n.d(e, "AmbientLight", function() {
                return qs
            }), n.d(e, "AmbientLightProbe", function() {
                return vc
            }), n.d(e, "AnimationClip", function() {
                return es
            }), n.d(e, "AnimationLoader", function() {
                return cs
            }), n.d(e, "AnimationMixer", function() {
                return Pc
            }), n.d(e, "AnimationObjectGroup", function() {
                return Cc
            }), n.d(e, "AnimationUtils", function() {
                return Ua
            }), n.d(e, "ArcCurve", function() {
                return vs
            }), n.d(e, "ArrayCamera", function() {
                return ji
            }), n.d(e, "ArrowHelper", function() {
                return iu
            }), n.d(e, "Audio", function() {
                return bc
            }), n.d(e, "AudioAnalyser", function() {
                return _c
            }), n.d(e, "AudioContext", function() {
                return hc
            }), n.d(e, "AudioListener", function() {
                return xc
            }), n.d(e, "AudioLoader", function() {
                return pc
            }), n.d(e, "AxesHelper", function() {
                return ou
            }), n.d(e, "AxisHelper", function() {
                return Pu
            }), n.d(e, "BackSide", function() {
                return g
            }), n.d(e, "BasicDepthPacking", function() {
                return Fe
            }), n.d(e, "BasicShadowMap", function() {
                return d
            }), n.d(e, "BinaryTextureLoader", function() {
                return Fu
            }), n.d(e, "Bone", function() {
                return ao
            }), n.d(e, "BooleanKeyframeTrack", function() {
                return Ya
            }), n.d(e, "BoundingBoxHelper", function() {
                return Ou
            }), n.d(e, "Box2", function() {
                return zc
            }), n.d(e, "Box3", function() {
                return rn
            }), n.d(e, "Box3Helper", function() {
                return nu
            }), n.d(e, "BoxBufferGeometry", function() {
                return Dn
            }), n.d(e, "BoxGeometry", function() {
                return Bn
            }), n.d(e, "BoxHelper", function() {
                return eu
            }), n.d(e, "BufferAttribute", function() {
                return gn
            }), n.d(e, "BufferGeometry", function() {
                return Rn
            }), n.d(e, "BufferGeometryLoader", function() {
                return Ks
            }), n.d(e, "ByteType", function() {
                return At
            }), n.d(e, "Cache", function() {
                return rs
            }), n.d(e, "Camera", function() {
                return Un
            }), n.d(e, "CameraHelper", function() {
                return tu
            }), n.d(e, "CanvasRenderer", function() {
                return Nu
            }), n.d(e, "CanvasTexture", function() {
                return vo
            }), n.d(e, "CatmullRomCurve3", function() {
                return _s
            }), n.d(e, "CineonToneMapping", function() {
                return st
            }), n.d(e, "CircleBufferGeometry", function() {
                return Ca
            }), n.d(e, "CircleGeometry", function() {
                return La
            }), n.d(e, "ClampToEdgeWrapping", function() {
                return yt
            }), n.d(e, "Clock", function() {
                return yc
            }), n.d(e, "ClosedSplineCurve3", function() {
                return Lu
            }), n.d(e, "Color", function() {
                return un
            }), n.d(e, "ColorKeyframeTrack", function() {
                return Ja
            }), n.d(e, "CompressedTexture", function() {
                return mo
            }), n.d(e, "CompressedTextureLoader", function() {
                return us
            }), n.d(e, "ConeBufferGeometry", function() {
                return Aa
            }), n.d(e, "ConeGeometry", function() {
                return Ta
            }), n.d(e, "CubeCamera", function() {
                return qn
            }), n.d(e, "CubeGeometry", function() {
                return Bn
            }), n.d(e, "CubeReflectionMapping", function() {
                return lt
            }), n.d(e, "CubeRefractionMapping", function() {
                return ht
            }), n.d(e, "CubeTexture", function() {
                return mr
            }), n.d(e, "CubeTextureLoader", function() {
                return ps
            }), n.d(e, "CubeUVReflectionMapping", function() {
                return mt
            }), n.d(e, "CubeUVRefractionMapping", function() {
                return vt
            }), n.d(e, "CubicBezierCurve", function() {
                return Ts
            }), n.d(e, "CubicBezierCurve3", function() {
                return As
            }), n.d(e, "CubicInterpolant", function() {
                return Va
            }), n.d(e, "CullFaceBack", function() {
                return c
            }), n.d(e, "CullFaceFront", function() {
                return u
            }), n.d(e, "CullFaceFrontBack", function() {
                return l
            }), n.d(e, "CullFaceNone", function() {
                return s
            }), n.d(e, "Curve", function() {
                return fs
            }), n.d(e, "CurvePath", function() {
                return Bs
            }), n.d(e, "CustomBlending", function() {
                return C
            }), n.d(e, "CylinderBufferGeometry", function() {
                return Sa
            }), n.d(e, "CylinderGeometry", function() {
                return Ea
            }), n.d(e, "Cylindrical", function() {
                return Nc
            }), n.d(e, "DataTexture", function() {
                return Yn
            }), n.d(e, "DataTexture2DArray", function() {
                return vr
            }), n.d(e, "DataTexture3D", function() {
                return gr
            }), n.d(e, "DataTextureLoader", function() {
                return ls
            }), n.d(e, "DefaultLoadingManager", function() {
                return os
            }), n.d(e, "DepthFormat", function() {
                return Vt
            }), n.d(e, "DepthStencilFormat", function() {
                return Wt
            }), n.d(e, "DepthTexture", function() {
                return go
            }), n.d(e, "DirectionalLight", function() {
                return Ws
            }), n.d(e, "DirectionalLightHelper", function() {
                return $c
            }), n.d(e, "DirectionalLightShadow", function() {
                return Vs
            }), n.d(e, "DiscreteInterpolant", function() {
                return qa
            }), n.d(e, "DodecahedronBufferGeometry", function() {
                return Ro
            }), n.d(e, "DodecahedronGeometry", function() {
                return Co
            }), n.d(e, "DoubleSide", function() {
                return y
            }), n.d(e, "DstAlphaFactor", function() {
                return H
            }), n.d(e, "DstColorFactor", function() {
                return j
            }), n.d(e, "DynamicBufferAttribute", function() {
                return yu
            }), n.d(e, "EdgesGeometry", function() {
                return Ma
            }), n.d(e, "EdgesHelper", function() {
                return Iu
            }), n.d(e, "EllipseCurve", function() {
                return ms
            }), n.d(e, "EqualDepth", function() {
                return Z
            }), n.d(e, "EquirectangularReflectionMapping", function() {
                return pt
            }), n.d(e, "EquirectangularRefractionMapping", function() {
                return dt
            }), n.d(e, "Euler", function() {
                return Ke
            }), n.d(e, "EventDispatcher", function() {
                return r
            }), n.d(e, "ExtrudeBufferGeometry", function() {
                return ua
            }), n.d(e, "ExtrudeGeometry", function() {
                return ca
            }), n.d(e, "Face3", function() {
                return dn
            }), n.d(e, "Face4", function() {
                return au
            }), n.d(e, "FaceColors", function() {
                return _
            }), n.d(e, "FaceNormalsHelper", function() {
                return Kc
            }), n.d(e, "FileLoader", function() {
                return ss
            }), n.d(e, "FlatShading", function() {
                return x
            }), n.d(e, "Float32Attribute", function() {
                return Tu
            }), n.d(e, "Float32BufferAttribute", function() {
                return Sn
            }), n.d(e, "Float64Attribute", function() {
                return Au
            }), n.d(e, "Float64BufferAttribute", function() {
                return Tn
            }), n.d(e, "FloatType", function() {
                return Ot
            }), n.d(e, "Fog", function() {
                return Ki
            }), n.d(e, "FogExp2", function() {
                return Qi
            }), n.d(e, "Font", function() {
                return sc
            }), n.d(e, "FontLoader", function() {
                return uc
            }), n.d(e, "FrontFaceDirectionCCW", function() {
                return p
            }), n.d(e, "FrontFaceDirectionCW", function() {
                return h
            }), n.d(e, "FrontSide", function() {
                return v
            }), n.d(e, "Frustum", function() {
                return Zn
            }), n.d(e, "GammaEncoding", function() {
                return Re
            }), n.d(e, "Geometry", function() {
                return In
            }), n.d(e, "GeometryUtils", function() {
                return ku
            }), n.d(e, "GreaterDepth", function() {
                return K
            }), n.d(e, "GreaterEqualDepth", function() {
                return Q
            }), n.d(e, "GridHelper", function() {
                return Jc
            }), n.d(e, "Group", function() {
                return Ui
            }), n.d(e, "HalfFloatType", function() {
                return It
            }), n.d(e, "HemisphereLight", function() {
                return Ns
            }), n.d(e, "HemisphereLightHelper", function() {
                return Xc
            }), n.d(e, "HemisphereLightProbe", function() {
                return mc
            }), n.d(e, "IcosahedronBufferGeometry", function() {
                return Lo
            }), n.d(e, "IcosahedronGeometry", function() {
                return Ao
            }), n.d(e, "ImageBitmapLoader", function() {
                return oc
            }), n.d(e, "ImageLoader", function() {
                return hs
            }), n.d(e, "ImageUtils", function() {
                return We
            }), n.d(e, "ImmediateRenderObject", function() {
                return Hc
            }), n.d(e, "InstancedBufferAttribute", function() {
                return Qs
            }), n.d(e, "InstancedBufferGeometry", function() {
                return Zs
            }), n.d(e, "InstancedInterleavedBuffer", function() {
                return Ic
            }), n.d(e, "Int16Attribute", function() {
                return _u
            }), n.d(e, "Int16BufferAttribute", function() {
                return wn
            }), n.d(e, "Int32Attribute", function() {
                return Eu
            }), n.d(e, "Int32BufferAttribute", function() {
                return Mn
            }), n.d(e, "Int8Attribute", function() {
                return xu
            }), n.d(e, "Int8BufferAttribute", function() {
                return yn
            }), n.d(e, "IntType", function() {
                return Rt
            }), n.d(e, "InterleavedBuffer", function() {
                return $i
            }), n.d(e, "InterleavedBufferAttribute", function() {
                return to
            }), n.d(e, "Interpolant", function() {
                return ja
            }), n.d(e, "InterpolateDiscrete", function() {
                return xe
            }), n.d(e, "InterpolateLinear", function() {
                return be
            }), n.d(e, "InterpolateSmooth", function() {
                return we
            }), n.d(e, "JSONLoader", function() {
                return zu
            }), n.d(e, "KeyframeTrack", function() {
                return Xa
            }), n.d(e, "LOD", function() {
                return ro
            }), n.d(e, "LatheBufferGeometry", function() {
                return xa
            }), n.d(e, "LatheGeometry", function() {
                return ya
            }), n.d(e, "Layers", function() {
                return $e
            }), n.d(e, "LensFlare", function() {
                return Hu
            }), n.d(e, "LessDepth", function() {
                return Y
            }), n.d(e, "LessEqualDepth", function() {
                return J
            }), n.d(e, "Light", function() {
                return ks
            }), n.d(e, "LightProbe", function() {
                return fc
            }), n.d(e, "LightProbeHelper", function() {
                return Yc
            }), n.d(e, "LightShadow", function() {
                return zs
            }), n.d(e, "Line", function() {
                return co
            }), n.d(e, "Line3", function() {
                return Gc
            }), n.d(e, "LineBasicMaterial", function() {
                return so
            }), n.d(e, "LineCurve", function() {
                return Ls
            }), n.d(e, "LineCurve3", function() {
                return Cs
            }), n.d(e, "LineDashedMaterial", function() {
                return Ga
            }), n.d(e, "LineLoop", function() {
                return lo
            }), n.d(e, "LinePieces", function() {
                return cu
            }), n.d(e, "LineSegments", function() {
                return uo
            }), n.d(e, "LineStrip", function() {
                return su
            }), n.d(e, "LinearEncoding", function() {
                return Le
            }), n.d(e, "LinearFilter", function() {
                return Mt
            }), n.d(e, "LinearInterpolant", function() {
                return Wa
            }), n.d(e, "LinearMipMapLinearFilter", function() {
                return St
            }), n.d(e, "LinearMipMapNearestFilter", function() {
                return Et
            }), n.d(e, "LinearToneMapping", function() {
                return it
            }), n.d(e, "Loader", function() {
                return lc
            }), n.d(e, "LoaderUtils", function() {
                return Js
            }), n.d(e, "LoadingManager", function() {
                return is
            }), n.d(e, "LogLuvEncoding", function() {
                return Oe
            }), n.d(e, "LoopOnce", function() {
                return ve
            }), n.d(e, "LoopPingPong", function() {
                return ye
            }), n.d(e, "LoopRepeat", function() {
                return ge
            }), n.d(e, "LuminanceAlphaFormat", function() {
                return Ut
            }), n.d(e, "LuminanceFormat", function() {
                return Ht
            }), n.d(e, "MOUSE", function() {
                return a
            }), n.d(e, "Material", function() {
                return mn
            }), n.d(e, "MaterialLoader", function() {
                return Ys
            }), n.d(e, "Math", function() {
                return Ge
            }), n.d(e, "Matrix3", function() {
                return Ve
            }), n.d(e, "Matrix4", function() {
                return Qe
            }), n.d(e, "MaxEquation", function() {
                return B
            }), n.d(e, "Mesh", function() {
                return Pn
            }), n.d(e, "MeshBasicMaterial", function() {
                return vn
            }), n.d(e, "MeshDepthMaterial", function() {
                return Fi
            }), n.d(e, "MeshDistanceMaterial", function() {
                return ki
            }), n.d(e, "MeshFaceMaterial", function() {
                return uu
            }), n.d(e, "MeshLambertMaterial", function() {
                return Na
            }), n.d(e, "MeshMatcapMaterial", function() {
                return za
            }), n.d(e, "MeshNormalMaterial", function() {
                return ka
            }), n.d(e, "MeshPhongMaterial", function() {
                return Da
            }), n.d(e, "MeshPhysicalMaterial", function() {
                return Ba
            }), n.d(e, "MeshStandardMaterial", function() {
                return Ia
            }), n.d(e, "MeshToonMaterial", function() {
                return Fa
            }), n.d(e, "MinEquation", function() {
                return I
            }), n.d(e, "MirroredRepeatWrapping", function() {
                return xt
            }), n.d(e, "MixOperation", function() {
                return et
            }), n.d(e, "MultiMaterial", function() {
                return lu
            }), n.d(e, "MultiplyBlending", function() {
                return L
            }), n.d(e, "MultiplyOperation", function() {
                return tt
            }), n.d(e, "NearestFilter", function() {
                return bt
            }), n.d(e, "NearestMipMapLinearFilter", function() {
                return _t
            }), n.d(e, "NearestMipMapNearestFilter", function() {
                return wt
            }), n.d(e, "NeverDepth", function() {
                return q
            }), n.d(e, "NoBlending", function() {
                return E
            }), n.d(e, "NoColors", function() {
                return w
            }), n.d(e, "NoToneMapping", function() {
                return rt
            }), n.d(e, "NormalBlending", function() {
                return S
            }), n.d(e, "NotEqualDepth", function() {
                return $
            }), n.d(e, "NumberKeyframeTrack", function() {
                return Za
            }), n.d(e, "Object3D", function() {
                return en
            }), n.d(e, "ObjectLoader", function() {
                return tc
            }), n.d(e, "ObjectSpaceNormalMap", function() {
                return ze
            }), n.d(e, "OctahedronBufferGeometry", function() {
                return To
            }), n.d(e, "OctahedronGeometry", function() {
                return So
            }), n.d(e, "OneFactor", function() {
                return F
            }), n.d(e, "OneMinusDstAlphaFactor", function() {
                return U
            }), n.d(e, "OneMinusDstColorFactor", function() {
                return V
            }), n.d(e, "OneMinusSrcAlphaFactor", function() {
                return G
            }), n.d(e, "OneMinusSrcColorFactor", function() {
                return N
            }), n.d(e, "OrthographicCamera", function() {
                return js
            }), n.d(e, "PCFShadowMap", function() {
                return f
            }), n.d(e, "PCFSoftShadowMap", function() {
                return m
            }), n.d(e, "ParametricBufferGeometry", function() {
                return bo
            }), n.d(e, "ParametricGeometry", function() {
                return xo
            }), n.d(e, "Particle", function() {
                return pu
            }), n.d(e, "ParticleBasicMaterial", function() {
                return mu
            }), n.d(e, "ParticleSystem", function() {
                return du
            }), n.d(e, "ParticleSystemMaterial", function() {
                return vu
            }), n.d(e, "Path", function() {
                return Ds
            }), n.d(e, "PerspectiveCamera", function() {
                return jn
            }), n.d(e, "Plane", function() {
                return Jn
            }), n.d(e, "PlaneBufferGeometry", function() {
                return rr
            }), n.d(e, "PlaneGeometry", function() {
                return nr
            }), n.d(e, "PlaneHelper", function() {
                return ru
            }), n.d(e, "PointCloud", function() {
                return hu
            }), n.d(e, "PointCloudMaterial", function() {
                return fu
            }), n.d(e, "PointLight", function() {
                return Us
            }), n.d(e, "PointLightHelper", function() {
                return Wc
            }), n.d(e, "Points", function() {
                return po
            }), n.d(e, "PointsMaterial", function() {
                return ho
            }), n.d(e, "PolarGridHelper", function() {
                return Zc
            }), n.d(e, "PolyhedronBufferGeometry", function() {
                return _o
            }), n.d(e, "PolyhedronGeometry", function() {
                return wo
            }), n.d(e, "PositionalAudio", function() {
                return wc
            }), n.d(e, "PositionalAudioHelper", function() {
                return Qc
            }), n.d(e, "PropertyBinding", function() {
                return Lc
            }), n.d(e, "PropertyMixer", function() {
                return Mc
            }), n.d(e, "QuadraticBezierCurve", function() {
                return Rs
            }), n.d(e, "QuadraticBezierCurve3", function() {
                return Ps
            }), n.d(e, "Quaternion", function() {
                return Ue
            }), n.d(e, "QuaternionKeyframeTrack", function() {
                return Ka
            }), n.d(e, "QuaternionLinearInterpolant", function() {
                return Qa
            }), n.d(e, "REVISION", function() {
                return o
            }), n.d(e, "RGBADepthPacking", function() {
                return ke
            }), n.d(e, "RGBAFormat", function() {
                return Gt
            }), n.d(e, "RGBA_ASTC_10x10_Format", function() {
                return de
            }), n.d(e, "RGBA_ASTC_10x5_Format", function() {
                return le
            }), n.d(e, "RGBA_ASTC_10x6_Format", function() {
                return he
            }), n.d(e, "RGBA_ASTC_10x8_Format", function() {
                return pe
            }), n.d(e, "RGBA_ASTC_12x10_Format", function() {
                return fe
            }), n.d(e, "RGBA_ASTC_12x12_Format", function() {
                return me
            }), n.d(e, "RGBA_ASTC_4x4_Format", function() {
                return ne
            }), n.d(e, "RGBA_ASTC_5x4_Format", function() {
                return re
            }), n.d(e, "RGBA_ASTC_5x5_Format", function() {
                return ie
            }), n.d(e, "RGBA_ASTC_6x5_Format", function() {
                return oe
            }), n.d(e, "RGBA_ASTC_6x6_Format", function() {
                return ae
            }), n.d(e, "RGBA_ASTC_8x5_Format", function() {
                return se
            }), n.d(e, "RGBA_ASTC_8x6_Format", function() {
                return ce
            }), n.d(e, "RGBA_ASTC_8x8_Format", function() {
                return ue
            }), n.d(e, "RGBA_PVRTC_2BPPV1_Format", function() {
                return te
            }), n.d(e, "RGBA_PVRTC_4BPPV1_Format", function() {
                return $t
            }), n.d(e, "RGBA_S3TC_DXT1_Format", function() {
                return Yt
            }), n.d(e, "RGBA_S3TC_DXT3_Format", function() {
                return Jt
            }), n.d(e, "RGBA_S3TC_DXT5_Format", function() {
                return Zt
            }), n.d(e, "RGBDEncoding", function() {
                return De
            }), n.d(e, "RGBEEncoding", function() {
                return Pe
            }), n.d(e, "RGBEFormat", function() {
                return jt
            }), n.d(e, "RGBFormat", function() {
                return zt
            }), n.d(e, "RGBM16Encoding", function() {
                return Be
            }), n.d(e, "RGBM7Encoding", function() {
                return Ie
            }), n.d(e, "RGB_ETC1_Format", function() {
                return ee
            }), n.d(e, "RGB_PVRTC_2BPPV1_Format", function() {
                return Kt
            }), n.d(e, "RGB_PVRTC_4BPPV1_Format", function() {
                return Qt
            }), n.d(e, "RGB_S3TC_DXT1_Format", function() {
                return Xt
            }), n.d(e, "RawShaderMaterial", function() {
                return Oa
            }), n.d(e, "Ray", function() {
                return an
            }), n.d(e, "Raycaster", function() {
                return Bc
            }), n.d(e, "RectAreaLight", function() {
                return Xs
            }), n.d(e, "RectAreaLightHelper", function() {
                return qc
            }), n.d(e, "RedFormat", function() {
                return qt
            }), n.d(e, "ReinhardToneMapping", function() {
                return ot
            }), n.d(e, "RepeatWrapping", function() {
                return gt
            }), n.d(e, "ReverseSubtractEquation", function() {
                return O
            }), n.d(e, "RingBufferGeometry", function() {
                return ga
            }), n.d(e, "RingGeometry", function() {
                return va
            }), n.d(e, "Scene", function() {
                return nn
            }), n.d(e, "SceneUtils", function() {
                return Gu
            }), n.d(e, "ShaderChunk", function() {
                return Qn
            }), n.d(e, "ShaderLib", function() {
                return $n
            }), n.d(e, "ShaderMaterial", function() {
                return Hn
            }), n.d(e, "ShadowMaterial", function() {
                return Pa
            }), n.d(e, "Shape", function() {
                return Fs
            }), n.d(e, "ShapeBufferGeometry", function() {
                return wa
            }), n.d(e, "ShapeGeometry", function() {
                return ba
            }), n.d(e, "ShapePath", function() {
                return ac
            }), n.d(e, "ShapeUtils", function() {
                return oa
            }), n.d(e, "ShortType", function() {
                return Lt
            }), n.d(e, "Skeleton", function() {
                return oo
            }), n.d(e, "SkeletonHelper", function() {
                return Vc
            }), n.d(e, "SkinnedMesh", function() {
                return io
            }), n.d(e, "SmoothShading", function() {
                return b
            }), n.d(e, "Sphere", function() {
                return on
            }), n.d(e, "SphereBufferGeometry", function() {
                return ma
            }), n.d(e, "SphereGeometry", function() {
                return fa
            }), n.d(e, "Spherical", function() {
                return kc
            }), n.d(e, "SphericalHarmonics3", function() {
                return dc
            }), n.d(e, "SphericalReflectionMapping", function() {
                return ft
            }), n.d(e, "Spline", function() {
                return Ru
            }), n.d(e, "SplineCurve", function() {
                return Os
            }), n.d(e, "SplineCurve3", function() {
                return Cu
            }), n.d(e, "SpotLight", function() {
                return Hs
            }), n.d(e, "SpotLightHelper", function() {
                return jc
            }), n.d(e, "SpotLightShadow", function() {
                return Gs
            }), n.d(e, "Sprite", function() {
                return no
            }), n.d(e, "SpriteMaterial", function() {
                return eo
            }), n.d(e, "SrcAlphaFactor", function() {
                return z
            }), n.d(e, "SrcAlphaSaturateFactor", function() {
                return W
            }), n.d(e, "SrcColorFactor", function() {
                return k
            }), n.d(e, "StereoCamera", function() {
                return gc
            }), n.d(e, "StringKeyframeTrack", function() {
                return $a
            }), n.d(e, "SubtractEquation", function() {
                return P
            }), n.d(e, "SubtractiveBlending", function() {
                return A
            }), n.d(e, "TangentSpaceNormalMap", function() {
                return Ne
            }), n.d(e, "TetrahedronBufferGeometry", function() {
                return Eo
            }), n.d(e, "TetrahedronGeometry", function() {
                return Mo
            }), n.d(e, "TextBufferGeometry", function() {
                return da
            }), n.d(e, "TextGeometry", function() {
                return pa
            }), n.d(e, "Texture", function() {
                return Xe
            }), n.d(e, "TextureLoader", function() {
                return ds
            }), n.d(e, "TorusBufferGeometry", function() {
                return Fo
            }), n.d(e, "TorusGeometry", function() {
                return Do
            }), n.d(e, "TorusKnotBufferGeometry", function() {
                return Bo
            }), n.d(e, "TorusKnotGeometry", function() {
                return Io
            }), n.d(e, "Triangle", function() {
                return sn
            }), n.d(e, "TriangleFanDrawMode", function() {
                return Ae
            }), n.d(e, "TriangleStripDrawMode", function() {
                return Te
            }), n.d(e, "TrianglesDrawMode", function() {
                return Se
            }), n.d(e, "TubeBufferGeometry", function() {
                return Oo
            }), n.d(e, "TubeGeometry", function() {
                return Po
            }), n.d(e, "UVMapping", function() {
                return ut
            }), n.d(e, "Uint16Attribute", function() {
                return Mu
            }), n.d(e, "Uint16BufferAttribute", function() {
                return _n
            }), n.d(e, "Uint32Attribute", function() {
                return Su
            }), n.d(e, "Uint32BufferAttribute", function() {
                return En
            }), n.d(e, "Uint8Attribute", function() {
                return bu
            }), n.d(e, "Uint8BufferAttribute", function() {
                return xn
            }), n.d(e, "Uint8ClampedAttribute", function() {
                return wu
            }), n.d(e, "Uint8ClampedBufferAttribute", function() {
                return bn
            }), n.d(e, "Uncharted2ToneMapping", function() {
                return at
            }), n.d(e, "Uniform", function() {
                return Oc
            }), n.d(e, "UniformsLib", function() {
                return Kn
            }), n.d(e, "UniformsUtils", function() {
                return Nn
            }), n.d(e, "UnsignedByteType", function() {
                return Tt
            }), n.d(e, "UnsignedInt248Type", function() {
                return kt
            }), n.d(e, "UnsignedIntType", function() {
                return Pt
            }), n.d(e, "UnsignedShort4444Type", function() {
                return Bt
            }), n.d(e, "UnsignedShort5551Type", function() {
                return Dt
            }), n.d(e, "UnsignedShort565Type", function() {
                return Ft
            }), n.d(e, "UnsignedShortType", function() {
                return Ct
            }), n.d(e, "Vector2", function() {
                return He
            }), n.d(e, "Vector3", function() {
                return je
            }), n.d(e, "Vector4", function() {
                return Ye
            }), n.d(e, "VectorKeyframeTrack", function() {
                return ts
            }), n.d(e, "Vertex", function() {
                return gu
            }), n.d(e, "VertexColors", function() {
                return M
            }), n.d(e, "VertexNormalsHelper", function() {
                return Uc
            }), n.d(e, "VideoTexture", function() {
                return fo
            }), n.d(e, "WebGLMultisampleRenderTarget", function() {
                return Ze
            }), n.d(e, "WebGLRenderTarget", function() {
                return Je
            }), n.d(e, "WebGLRenderTargetCube", function() {
                return Xn
            }), n.d(e, "WebGLRenderer", function() {
                return Zi
            }), n.d(e, "WebGLUtils", function() {
                return Hi
            }), n.d(e, "WireframeGeometry", function() {
                return yo
            }), n.d(e, "WireframeHelper", function() {
                return Bu
            }), n.d(e, "WrapAroundEnding", function() {
                return Ee
            }), n.d(e, "XHRLoader", function() {
                return Du
            }), n.d(e, "ZeroCurvatureEnding", function() {
                return _e
            }), n.d(e, "ZeroFactor", function() {
                return D
            }), n.d(e, "ZeroSlopeEnding", function() {
                return Me
            }), n.d(e, "sRGBEncoding", function() {
                return Ce
            }), void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function(t) {
                return "number" == typeof t && isFinite(t) && Math.floor(t) === t
            }), void 0 === Math.sign && (Math.sign = function(t) {
                return t < 0 ? -1 : t > 0 ? 1 : +t
            }), "name" in Function.prototype == !1 && Object.defineProperty(Function.prototype, "name", {
                get: function() {
                    return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
                }
            }), void 0 === Object.assign && (Object.assign = function(t) {
                if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                for (var e = Object(t), n = 1; n < arguments.length; n++) {
                    var r = arguments[n];
                    if (null != r)
                        for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
                }
                return e
            }), Object.assign(r.prototype, {
                addEventListener: function(t, e) {
                    void 0 === this._listeners && (this._listeners = {});
                    var n = this._listeners;
                    void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
                },
                hasEventListener: function(t, e) {
                    if (void 0 === this._listeners) return !1;
                    var n = this._listeners;
                    return void 0 !== n[t] && -1 !== n[t].indexOf(e)
                },
                removeEventListener: function(t, e) {
                    if (void 0 !== this._listeners) {
                        var n = this._listeners[t];
                        if (void 0 !== n) {
                            var r = n.indexOf(e); - 1 !== r && n.splice(r, 1)
                        }
                    }
                },
                dispatchEvent: function(t) {
                    if (void 0 !== this._listeners) {
                        var e = this._listeners[t.type];
                        if (void 0 !== e) {
                            t.target = this;
                            for (var n = e.slice(0), r = 0, i = n.length; r < i; r++) n[r].call(this, t)
                        }
                    }
                }
            });
            var i, o = "106",
                a = {
                    LEFT: 0,
                    MIDDLE: 1,
                    RIGHT: 2
                },
                s = 0,
                c = 1,
                u = 2,
                l = 3,
                h = 0,
                p = 1,
                d = 0,
                f = 1,
                m = 2,
                v = 0,
                g = 1,
                y = 2,
                x = 1,
                b = 2,
                w = 0,
                _ = 1,
                M = 2,
                E = 0,
                S = 1,
                T = 2,
                A = 3,
                L = 4,
                C = 5,
                R = 100,
                P = 101,
                O = 102,
                I = 103,
                B = 104,
                D = 200,
                F = 201,
                k = 202,
                N = 203,
                z = 204,
                G = 205,
                H = 206,
                U = 207,
                j = 208,
                V = 209,
                W = 210,
                q = 0,
                X = 1,
                Y = 2,
                J = 3,
                Z = 4,
                Q = 5,
                K = 6,
                $ = 7,
                tt = 0,
                et = 1,
                nt = 2,
                rt = 0,
                it = 1,
                ot = 2,
                at = 3,
                st = 4,
                ct = 5,
                ut = 300,
                lt = 301,
                ht = 302,
                pt = 303,
                dt = 304,
                ft = 305,
                mt = 306,
                vt = 307,
                gt = 1e3,
                yt = 1001,
                xt = 1002,
                bt = 1003,
                wt = 1004,
                _t = 1005,
                Mt = 1006,
                Et = 1007,
                St = 1008,
                Tt = 1009,
                At = 1010,
                Lt = 1011,
                Ct = 1012,
                Rt = 1013,
                Pt = 1014,
                Ot = 1015,
                It = 1016,
                Bt = 1017,
                Dt = 1018,
                Ft = 1019,
                kt = 1020,
                Nt = 1021,
                zt = 1022,
                Gt = 1023,
                Ht = 1024,
                Ut = 1025,
                jt = Gt,
                Vt = 1026,
                Wt = 1027,
                qt = 1028,
                Xt = 33776,
                Yt = 33777,
                Jt = 33778,
                Zt = 33779,
                Qt = 35840,
                Kt = 35841,
                $t = 35842,
                te = 35843,
                ee = 36196,
                ne = 37808,
                re = 37809,
                ie = 37810,
                oe = 37811,
                ae = 37812,
                se = 37813,
                ce = 37814,
                ue = 37815,
                le = 37816,
                he = 37817,
                pe = 37818,
                de = 37819,
                fe = 37820,
                me = 37821,
                ve = 2200,
                ge = 2201,
                ye = 2202,
                xe = 2300,
                be = 2301,
                we = 2302,
                _e = 2400,
                Me = 2401,
                Ee = 2402,
                Se = 0,
                Te = 1,
                Ae = 2,
                Le = 3e3,
                Ce = 3001,
                Re = 3007,
                Pe = 3002,
                Oe = 3003,
                Ie = 3004,
                Be = 3005,
                De = 3006,
                Fe = 3200,
                ke = 3201,
                Ne = 0,
                ze = 1,
                Ge = {
                    DEG2RAD: Math.PI / 180,
                    RAD2DEG: 180 / Math.PI,
                    generateUUID: function() {
                        for (var t = [], e = 0; e < 256; e++) t[e] = (e < 16 ? "0" : "") + e.toString(16);
                        return function() {
                            var e = 4294967295 * Math.random() | 0,
                                n = 4294967295 * Math.random() | 0,
                                r = 4294967295 * Math.random() | 0,
                                i = 4294967295 * Math.random() | 0;
                            return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & n] + t[n >> 8 & 255] + "-" + t[n >> 16 & 15 | 64] + t[n >> 24 & 255] + "-" + t[63 & r | 128] + t[r >> 8 & 255] + "-" + t[r >> 16 & 255] + t[r >> 24 & 255] + t[255 & i] + t[i >> 8 & 255] + t[i >> 16 & 255] + t[i >> 24 & 255]).toUpperCase()
                        }
                    }(),
                    clamp: function(t, e, n) {
                        return Math.max(e, Math.min(n, t))
                    },
                    euclideanModulo: function(t, e) {
                        return (t % e + e) % e
                    },
                    mapLinear: function(t, e, n, r, i) {
                        return r + (t - e) * (i - r) / (n - e)
                    },
                    lerp: function(t, e, n) {
                        return (1 - n) * t + n * e
                    },
                    smoothstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, n) {
                        return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
                    },
                    randInt: function(t, e) {
                        return t + Math.floor(Math.random() * (e - t + 1))
                    },
                    randFloat: function(t, e) {
                        return t + Math.random() * (e - t)
                    },
                    randFloatSpread: function(t) {
                        return t * (.5 - Math.random())
                    },
                    degToRad: function(t) {
                        return t * Ge.DEG2RAD
                    },
                    radToDeg: function(t) {
                        return t * Ge.RAD2DEG
                    },
                    isPowerOfTwo: function(t) {
                        return 0 == (t & t - 1) && 0 !== t
                    },
                    ceilPowerOfTwo: function(t) {
                        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
                    },
                    floorPowerOfTwo: function(t) {
                        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
                    }
                };

            function He(t, e) {
                this.x = t || 0, this.y = e || 0
            }

            function Ue(t, e, n, r) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._w = void 0 !== r ? r : 1
            }

            function je(t, e, n) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0
            }

            function Ve() {
                this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
            }
            Object.defineProperties(He.prototype, {
                width: {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                },
                height: {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }
            }), Object.assign(He.prototype, {
                isVector2: !0,
                set: function(t, e) {
                    return this.x = t, this.y = e, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this
                },
                multiply: function(t) {
                    return this.x *= t.x, this.y *= t.y, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        r = t.elements;
                    return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
                },
                clampScalar: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
                },
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y
                },
                cross: function(t) {
                    return this.x * t.y - this.y * t.x
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                angle: function() {
                    var t = Math.atan2(this.y, this.x);
                    return t < 0 && (t += 2 * Math.PI), t
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y;
                    return e * e + n * n
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
                },
                rotateAround: function(t, e) {
                    var n = Math.cos(e),
                        r = Math.sin(e),
                        i = this.x - t.x,
                        o = this.y - t.y;
                    return this.x = i * n - o * r + t.x, this.y = i * r + o * n + t.y, this
                }
            }), Object.assign(Ue, {
                slerp: function(t, e, n, r) {
                    return n.copy(t).slerp(e, r)
                },
                slerpFlat: function(t, e, n, r, i, o, a) {
                    var s = n[r + 0],
                        c = n[r + 1],
                        u = n[r + 2],
                        l = n[r + 3],
                        h = i[o + 0],
                        p = i[o + 1],
                        d = i[o + 2],
                        f = i[o + 3];
                    if (l !== f || s !== h || c !== p || u !== d) {
                        var m = 1 - a,
                            v = s * h + c * p + u * d + l * f,
                            g = v >= 0 ? 1 : -1,
                            y = 1 - v * v;
                        if (y > Number.EPSILON) {
                            var x = Math.sqrt(y),
                                b = Math.atan2(x, v * g);
                            m = Math.sin(m * b) / x, a = Math.sin(a * b) / x
                        }
                        var w = a * g;
                        if (s = s * m + h * w, c = c * m + p * w, u = u * m + d * w, l = l * m + f * w, m === 1 - a) {
                            var _ = 1 / Math.sqrt(s * s + c * c + u * u + l * l);
                            s *= _, c *= _, u *= _, l *= _
                        }
                    }
                    t[e] = s, t[e + 1] = c, t[e + 2] = u, t[e + 3] = l
                }
            }), Object.defineProperties(Ue.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this._onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this._onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this._onChangeCallback()
                    }
                },
                w: {
                    get: function() {
                        return this._w
                    },
                    set: function(t) {
                        this._w = t, this._onChangeCallback()
                    }
                }
            }), Object.assign(Ue.prototype, {
                isQuaternion: !0,
                set: function(t, e, n, r) {
                    return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._w)
                },
                copy: function(t) {
                    return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
                },
                setFromEuler: function(t, e) {
                    if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
                    var n = t._x,
                        r = t._y,
                        i = t._z,
                        o = t.order,
                        a = Math.cos,
                        s = Math.sin,
                        c = a(n / 2),
                        u = a(r / 2),
                        l = a(i / 2),
                        h = s(n / 2),
                        p = s(r / 2),
                        d = s(i / 2);
                    return "XYZ" === o ? (this._x = h * u * l + c * p * d, this._y = c * p * l - h * u * d, this._z = c * u * d + h * p * l, this._w = c * u * l - h * p * d) : "YXZ" === o ? (this._x = h * u * l + c * p * d, this._y = c * p * l - h * u * d, this._z = c * u * d - h * p * l, this._w = c * u * l + h * p * d) : "ZXY" === o ? (this._x = h * u * l - c * p * d, this._y = c * p * l + h * u * d, this._z = c * u * d + h * p * l, this._w = c * u * l - h * p * d) : "ZYX" === o ? (this._x = h * u * l - c * p * d, this._y = c * p * l + h * u * d, this._z = c * u * d - h * p * l, this._w = c * u * l + h * p * d) : "YZX" === o ? (this._x = h * u * l + c * p * d, this._y = c * p * l + h * u * d, this._z = c * u * d - h * p * l, this._w = c * u * l - h * p * d) : "XZY" === o && (this._x = h * u * l - c * p * d, this._y = c * p * l - h * u * d, this._z = c * u * d + h * p * l, this._w = c * u * l + h * p * d), !1 !== e && this._onChangeCallback(), this
                },
                setFromAxisAngle: function(t, e) {
                    var n = e / 2,
                        r = Math.sin(n);
                    return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this
                },
                setFromRotationMatrix: function(t) {
                    var e, n = t.elements,
                        r = n[0],
                        i = n[4],
                        o = n[8],
                        a = n[1],
                        s = n[5],
                        c = n[9],
                        u = n[2],
                        l = n[6],
                        h = n[10],
                        p = r + s + h;
                    return p > 0 ? (e = .5 / Math.sqrt(p + 1), this._w = .25 / e, this._x = (l - c) * e, this._y = (o - u) * e, this._z = (a - i) * e) : r > s && r > h ? (e = 2 * Math.sqrt(1 + r - s - h), this._w = (l - c) / e, this._x = .25 * e, this._y = (i + a) / e, this._z = (o + u) / e) : s > h ? (e = 2 * Math.sqrt(1 + s - r - h), this._w = (o - u) / e, this._x = (i + a) / e, this._y = .25 * e, this._z = (c + l) / e) : (e = 2 * Math.sqrt(1 + h - r - s), this._w = (a - i) / e, this._x = (o + u) / e, this._y = (c + l) / e, this._z = .25 * e), this._onChangeCallback(), this
                },
                setFromUnitVectors: function(t, e) {
                    var n = t.dot(e) + 1;
                    return n < 1e-6 ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
                },
                angleTo: function(t) {
                    return 2 * Math.acos(Math.abs(Ge.clamp(this.dot(t), -1, 1)))
                },
                rotateTowards: function(t, e) {
                    var n = this.angleTo(t);
                    if (0 === n) return this;
                    var r = Math.min(1, e / n);
                    return this.slerp(t, r), this
                },
                inverse: function() {
                    return this.conjugate()
                },
                conjugate: function() {
                    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
                },
                dot: function(t) {
                    return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
                },
                lengthSq: function() {
                    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
                },
                length: function() {
                    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
                },
                normalize: function() {
                    var t = this.length();
                    return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyQuaternions(t, this)
                },
                multiplyQuaternions: function(t, e) {
                    var n = t._x,
                        r = t._y,
                        i = t._z,
                        o = t._w,
                        a = e._x,
                        s = e._y,
                        c = e._z,
                        u = e._w;
                    return this._x = n * u + o * a + r * c - i * s, this._y = r * u + o * s + i * a - n * c, this._z = i * u + o * c + n * s - r * a, this._w = o * u - n * a - r * s - i * c, this._onChangeCallback(), this
                },
                slerp: function(t, e) {
                    if (0 === e) return this;
                    if (1 === e) return this.copy(t);
                    var n = this._x,
                        r = this._y,
                        i = this._z,
                        o = this._w,
                        a = o * t._w + n * t._x + r * t._y + i * t._z;
                    if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = i, this;
                    var s = 1 - a * a;
                    if (s <= Number.EPSILON) {
                        var c = 1 - e;
                        return this._w = c * o + e * this._w, this._x = c * n + e * this._x, this._y = c * r + e * this._y, this._z = c * i + e * this._z, this.normalize(), this._onChangeCallback(), this
                    }
                    var u = Math.sqrt(s),
                        l = Math.atan2(u, a),
                        h = Math.sin((1 - e) * l) / u,
                        p = Math.sin(e * l) / u;
                    return this._w = o * h + this._w * p, this._x = n * h + this._x * p, this._y = r * h + this._y * p, this._z = i * h + this._z * p, this._onChangeCallback(), this
                },
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
                },
                _onChange: function(t) {
                    return this._onChangeCallback = t, this
                },
                _onChangeCallback: function() {}
            }), Object.assign(je.prototype, {
                isVector3: !0,
                set: function(t, e, n) {
                    return this.x = t, this.y = e, this.z = n, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
                },
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this
                },
                multiplyVectors: function(t, e) {
                    return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
                },
                applyEuler: function() {
                    var t = new Ue;
                    return function(e) {
                        return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
                    }
                }(),
                applyAxisAngle: function() {
                    var t = new Ue;
                    return function(e, n) {
                        return this.applyQuaternion(t.setFromAxisAngle(e, n))
                    }
                }(),
                applyMatrix3: function(t) {
                    var e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.elements;
                    return this.x = i[0] * e + i[3] * n + i[6] * r, this.y = i[1] * e + i[4] * n + i[7] * r, this.z = i[2] * e + i[5] * n + i[8] * r, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.elements,
                        o = 1 / (i[3] * e + i[7] * n + i[11] * r + i[15]);
                    return this.x = (i[0] * e + i[4] * n + i[8] * r + i[12]) * o, this.y = (i[1] * e + i[5] * n + i[9] * r + i[13]) * o, this.z = (i[2] * e + i[6] * n + i[10] * r + i[14]) * o, this
                },
                applyQuaternion: function(t) {
                    var e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.x,
                        o = t.y,
                        a = t.z,
                        s = t.w,
                        c = s * e + o * r - a * n,
                        u = s * n + a * e - i * r,
                        l = s * r + i * n - o * e,
                        h = -i * e - o * n - a * r;
                    return this.x = c * s + h * -i + u * -a - l * -o, this.y = u * s + h * -o + l * -i - c * -a, this.z = l * s + h * -a + c * -o - u * -i, this
                },
                project: function(t) {
                    return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
                },
                unproject: function(t) {
                    return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
                },
                transformDirection: function(t) {
                    var e = this.x,
                        n = this.y,
                        r = this.z,
                        i = t.elements;
                    return this.x = i[0] * e + i[4] * n + i[8] * r, this.y = i[1] * e + i[5] * n + i[9] * r, this.z = i[2] * e + i[6] * n + i[10] * r, this.normalize()
                },
                divide: function(t) {
                    return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
                },
                clampScalar: function(t, e) {
                    return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
                },
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                cross: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
                },
                crossVectors: function(t, e) {
                    var n = t.x,
                        r = t.y,
                        i = t.z,
                        o = e.x,
                        a = e.y,
                        s = e.z;
                    return this.x = r * s - i * a, this.y = i * o - n * s, this.z = n * a - r * o, this
                },
                projectOnVector: function(t) {
                    var e = t.dot(this) / t.lengthSq();
                    return this.copy(t).multiplyScalar(e)
                },
                projectOnPlane: function() {
                    var t = new je;
                    return function(e) {
                        return t.copy(this).projectOnVector(e), this.sub(t)
                    }
                }(),
                reflect: function() {
                    var t = new je;
                    return function(e) {
                        return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
                    }
                }(),
                angleTo: function(t) {
                    var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
                    return Math.acos(Ge.clamp(e, -1, 1))
                },
                distanceTo: function(t) {
                    return Math.sqrt(this.distanceToSquared(t))
                },
                distanceToSquared: function(t) {
                    var e = this.x - t.x,
                        n = this.y - t.y,
                        r = this.z - t.z;
                    return e * e + n * n + r * r
                },
                manhattanDistanceTo: function(t) {
                    return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
                },
                setFromSpherical: function(t) {
                    return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
                },
                setFromSphericalCoords: function(t, e, n) {
                    var r = Math.sin(e) * t;
                    return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
                },
                setFromCylindrical: function(t) {
                    return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
                },
                setFromCylindricalCoords: function(t, e, n) {
                    return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
                },
                setFromMatrixPosition: function(t) {
                    var e = t.elements;
                    return this.x = e[12], this.y = e[13], this.z = e[14], this
                },
                setFromMatrixScale: function(t) {
                    var e = this.setFromMatrixColumn(t, 0).length(),
                        n = this.setFromMatrixColumn(t, 1).length(),
                        r = this.setFromMatrixColumn(t, 2).length();
                    return this.x = e, this.y = n, this.z = r, this
                },
                setFromMatrixColumn: function(t, e) {
                    return this.fromArray(t.elements, 4 * e)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
                }
            }), Object.assign(Ve.prototype, {
                isMatrix3: !0,
                set: function(t, e, n, r, i, o, a, s, c) {
                    var u = this.elements;
                    return u[0] = t, u[1] = r, u[2] = a, u[3] = e, u[4] = i, u[5] = s, u[6] = n, u[7] = o, u[8] = c, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new this.constructor).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
                },
                setFromMatrix4: function(t) {
                    var e = t.elements;
                    return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
                },
                applyToBufferAttribute: function() {
                    var t = new je;
                    return function(e) {
                        for (var n = 0, r = e.count; n < r; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix3(this), e.setXYZ(n, t.x, t.y, t.z);
                        return e
                    }
                }(),
                multiply: function(t) {
                    return this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        r = e.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[3],
                        s = n[6],
                        c = n[1],
                        u = n[4],
                        l = n[7],
                        h = n[2],
                        p = n[5],
                        d = n[8],
                        f = r[0],
                        m = r[3],
                        v = r[6],
                        g = r[1],
                        y = r[4],
                        x = r[7],
                        b = r[2],
                        w = r[5],
                        _ = r[8];
                    return i[0] = o * f + a * g + s * b, i[3] = o * m + a * y + s * w, i[6] = o * v + a * x + s * _, i[1] = c * f + u * g + l * b, i[4] = c * m + u * y + l * w, i[7] = c * v + u * x + l * _, i[2] = h * f + p * g + d * b, i[5] = h * m + p * y + d * w, i[8] = h * v + p * x + d * _, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
                },
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[1],
                        r = t[2],
                        i = t[3],
                        o = t[4],
                        a = t[5],
                        s = t[6],
                        c = t[7],
                        u = t[8];
                    return e * o * u - e * a * c - n * i * u + n * a * s + r * i * c - r * o * s
                },
                getInverse: function(t, e) {
                    t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
                    var n = t.elements,
                        r = this.elements,
                        i = n[0],
                        o = n[1],
                        a = n[2],
                        s = n[3],
                        c = n[4],
                        u = n[5],
                        l = n[6],
                        h = n[7],
                        p = n[8],
                        d = p * c - u * h,
                        f = u * l - p * s,
                        m = h * s - c * l,
                        v = i * d + o * f + a * m;
                    if (0 === v) {
                        var g = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(g);
                        return console.warn(g), this.identity()
                    }
                    var y = 1 / v;
                    return r[0] = d * y, r[1] = (a * h - p * o) * y, r[2] = (u * o - a * c) * y, r[3] = f * y, r[4] = (p * i - a * l) * y, r[5] = (a * s - u * i) * y, r[6] = m * y, r[7] = (o * l - h * i) * y, r[8] = (c * i - o * s) * y, this
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
                },
                getNormalMatrix: function(t) {
                    return this.setFromMatrix4(t).getInverse(this).transpose()
                },
                transposeIntoArray: function(t) {
                    var e = this.elements;
                    return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
                },
                setUvTransform: function(t, e, n, r, i, o, a) {
                    var s = Math.cos(i),
                        c = Math.sin(i);
                    this.set(n * s, n * c, -n * (s * o + c * a) + o + t, -r * c, r * s, -r * (-c * o + s * a) + a + e, 0, 0, 1)
                },
                scale: function(t, e) {
                    var n = this.elements;
                    return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
                },
                rotate: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t),
                        r = this.elements,
                        i = r[0],
                        o = r[3],
                        a = r[6],
                        s = r[1],
                        c = r[4],
                        u = r[7];
                    return r[0] = e * i + n * s, r[3] = e * o + n * c, r[6] = e * a + n * u, r[1] = -n * i + e * s, r[4] = -n * o + e * c, r[7] = -n * a + e * u, this
                },
                translate: function(t, e) {
                    var n = this.elements;
                    return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, r = 0; r < 9; r++)
                        if (e[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 9; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
                }
            });
            var We = {
                    getDataURL: function(t) {
                        var e;
                        if ("undefined" == typeof HTMLCanvasElement) return t.src;
                        if (t instanceof HTMLCanvasElement) e = t;
                        else {
                            void 0 === i && (i = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), i.width = t.width, i.height = t.height;
                            var n = i.getContext("2d");
                            t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = i
                        }
                        return e.width > 2048 || e.height > 2048 ? e.toDataURL("image/jpeg", .6) : e.toDataURL("image/png")
                    }
                },
                qe = 0;

            function Xe(t, e, n, r, i, o, a, s, c, u) {
                Object.defineProperty(this, "id", {
                    value: qe++
                }), this.uuid = Ge.generateUUID(), this.name = "", this.image = void 0 !== t ? t : Xe.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : Xe.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : yt, this.wrapT = void 0 !== r ? r : yt, this.magFilter = void 0 !== i ? i : Mt, this.minFilter = void 0 !== o ? o : St, this.anisotropy = void 0 !== c ? c : 1, this.format = void 0 !== a ? a : Gt, this.type = void 0 !== s ? s : Tt, this.offset = new He(0, 0), this.repeat = new He(1, 1), this.center = new He(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ve, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== u ? u : Le, this.version = 0, this.onUpdate = null
            }

            function Ye(t, e, n, r) {
                this.x = t || 0, this.y = e || 0, this.z = n || 0, this.w = void 0 !== r ? r : 1
            }

            function Je(t, e, n) {
                this.width = t, this.height = e, this.scissor = new Ye(0, 0, t, e), this.scissorTest = !1, this.viewport = new Ye(0, 0, t, e), n = n || {}, this.texture = new Xe(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.image = {}, this.texture.image.width = t, this.texture.image.height = e, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : Mt, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 === n.stencilBuffer || n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
            }

            function Ze(t, e, n) {
                Je.call(this, t, e, n), this.samples = 4
            }

            function Qe() {
                this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
            }

            function Ke(t, e, n, r) {
                this._x = t || 0, this._y = e || 0, this._z = n || 0, this._order = r || Ke.DefaultOrder
            }

            function $e() {
                this.mask = 1
            }
            Xe.DEFAULT_IMAGE = void 0, Xe.DEFAULT_MAPPING = ut, Xe.prototype = Object.assign(Object.create(r.prototype), {
                constructor: Xe,
                isTexture: !0,
                updateMatrix: function() {
                    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Texture",
                            generator: "Texture.toJSON"
                        },
                        uuid: this.uuid,
                        name: this.name,
                        mapping: this.mapping,
                        repeat: [this.repeat.x, this.repeat.y],
                        offset: [this.offset.x, this.offset.y],
                        center: [this.center.x, this.center.y],
                        rotation: this.rotation,
                        wrap: [this.wrapS, this.wrapT],
                        format: this.format,
                        type: this.type,
                        encoding: this.encoding,
                        minFilter: this.minFilter,
                        magFilter: this.magFilter,
                        anisotropy: this.anisotropy,
                        flipY: this.flipY,
                        premultiplyAlpha: this.premultiplyAlpha,
                        unpackAlignment: this.unpackAlignment
                    };
                    if (void 0 !== this.image) {
                        var r = this.image;
                        if (void 0 === r.uuid && (r.uuid = Ge.generateUUID()), !e && void 0 === t.images[r.uuid]) {
                            var i;
                            if (Array.isArray(r)) {
                                i = [];
                                for (var o = 0, a = r.length; o < a; o++) i.push(We.getDataURL(r[o]))
                            } else i = We.getDataURL(r);
                            t.images[r.uuid] = {
                                uuid: r.uuid,
                                url: i
                            }
                        }
                        n.image = r.uuid
                    }
                    return e || (t.textures[this.uuid] = n), n
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                },
                transformUv: function(t) {
                    if (this.mapping !== ut) return t;
                    if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
                        case gt:
                            t.x = t.x - Math.floor(t.x);
                            break;
                        case yt:
                            t.x = t.x < 0 ? 0 : 1;
                            break;
                        case xt:
                            1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
                    }
                    if (t.y < 0 || t.y > 1) switch (this.wrapT) {
                        case gt:
                            t.y = t.y - Math.floor(t.y);
                            break;
                        case yt:
                            t.y = t.y < 0 ? 0 : 1;
                            break;
                        case xt:
                            1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
                    }
                    return this.flipY && (t.y = 1 - t.y), t
                }
            }), Object.defineProperty(Xe.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.defineProperties(Ye.prototype, {
                width: {
                    get: function() {
                        return this.z
                    },
                    set: function(t) {
                        this.z = t
                    }
                },
                height: {
                    get: function() {
                        return this.w
                    },
                    set: function(t) {
                        this.w = t
                    }
                }
            }), Object.assign(Ye.prototype, {
                isVector4: !0,
                set: function(t, e, n, r) {
                    return this.x = t, this.y = e, this.z = n, this.w = r, this
                },
                setScalar: function(t) {
                    return this.x = t, this.y = t, this.z = t, this.w = t, this
                },
                setX: function(t) {
                    return this.x = t, this
                },
                setY: function(t) {
                    return this.y = t, this
                },
                setZ: function(t) {
                    return this.z = t, this
                },
                setW: function(t) {
                    return this.w = t, this
                },
                setComponent: function(t, e) {
                    switch (t) {
                        case 0:
                            this.x = e;
                            break;
                        case 1:
                            this.y = e;
                            break;
                        case 2:
                            this.z = e;
                            break;
                        case 3:
                            this.w = e;
                            break;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                    return this
                },
                getComponent: function(t) {
                    switch (t) {
                        case 0:
                            return this.x;
                        case 1:
                            return this.y;
                        case 2:
                            return this.z;
                        case 3:
                            return this.w;
                        default:
                            throw new Error("index is out of range: " + t)
                    }
                },
                clone: function() {
                    return new this.constructor(this.x, this.y, this.z, this.w)
                },
                copy: function(t) {
                    return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
                },
                add: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
                },
                addScalar: function(t) {
                    return this.x += t, this.y += t, this.z += t, this.w += t, this
                },
                addVectors: function(t, e) {
                    return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
                },
                addScaledVector: function(t, e) {
                    return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
                },
                sub: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
                },
                subScalar: function(t) {
                    return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
                },
                subVectors: function(t, e) {
                    return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
                },
                multiplyScalar: function(t) {
                    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
                },
                applyMatrix4: function(t) {
                    var e = this.x,
                        n = this.y,
                        r = this.z,
                        i = this.w,
                        o = t.elements;
                    return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * i, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * i, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * i, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * i, this
                },
                divideScalar: function(t) {
                    return this.multiplyScalar(1 / t)
                },
                setAxisAngleFromQuaternion: function(t) {
                    this.w = 2 * Math.acos(t.w);
                    var e = Math.sqrt(1 - t.w * t.w);
                    return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
                },
                setAxisAngleFromRotationMatrix: function(t) {
                    var e, n, r, i, o = .01,
                        a = t.elements,
                        s = a[0],
                        c = a[4],
                        u = a[8],
                        l = a[1],
                        h = a[5],
                        p = a[9],
                        d = a[2],
                        f = a[6],
                        m = a[10];
                    if (Math.abs(c - l) < o && Math.abs(u - d) < o && Math.abs(p - f) < o) {
                        if (Math.abs(c + l) < .1 && Math.abs(u + d) < .1 && Math.abs(p + f) < .1 && Math.abs(s + h + m - 3) < .1) return this.set(1, 0, 0, 0), this;
                        e = Math.PI;
                        var v = (s + 1) / 2,
                            g = (h + 1) / 2,
                            y = (m + 1) / 2,
                            x = (c + l) / 4,
                            b = (u + d) / 4,
                            w = (p + f) / 4;
                        return v > g && v > y ? v < o ? (n = 0, r = .707106781, i = .707106781) : (r = x / (n = Math.sqrt(v)), i = b / n) : g > y ? g < o ? (n = .707106781, r = 0, i = .707106781) : (n = x / (r = Math.sqrt(g)), i = w / r) : y < o ? (n = .707106781, r = .707106781, i = 0) : (n = b / (i = Math.sqrt(y)), r = w / i), this.set(n, r, i, e), this
                    }
                    var _ = Math.sqrt((f - p) * (f - p) + (u - d) * (u - d) + (l - c) * (l - c));
                    return Math.abs(_) < .001 && (_ = 1), this.x = (f - p) / _, this.y = (u - d) / _, this.z = (l - c) / _, this.w = Math.acos((s + h + m - 1) / 2), this
                },
                min: function(t) {
                    return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
                },
                max: function(t) {
                    return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
                },
                clamp: function(t, e) {
                    return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
                },
                clampScalar: function() {
                    var t, e;
                    return function(n, r) {
                        return void 0 === t && (t = new Ye, e = new Ye), t.set(n, n, n, n), e.set(r, r, r, r), this.clamp(t, e)
                    }
                }(),
                clampLength: function(t, e) {
                    var n = this.length();
                    return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
                },
                floor: function() {
                    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
                },
                ceil: function() {
                    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
                },
                round: function() {
                    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
                },
                roundToZero: function() {
                    return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
                },
                negate: function() {
                    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
                },
                dot: function(t) {
                    return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
                },
                lengthSq: function() {
                    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
                },
                length: function() {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
                },
                manhattanLength: function() {
                    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
                },
                normalize: function() {
                    return this.divideScalar(this.length() || 1)
                },
                setLength: function(t) {
                    return this.normalize().multiplyScalar(t)
                },
                lerp: function(t, e) {
                    return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
                },
                lerpVectors: function(t, e, n) {
                    return this.subVectors(e, t).multiplyScalar(n).add(t)
                },
                equals: function(t) {
                    return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
                },
                fromBufferAttribute: function(t, e, n) {
                    return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
                }
            }), Je.prototype = Object.assign(Object.create(r.prototype), {
                constructor: Je,
                isWebGLRenderTarget: !0,
                setSize: function(t, e) {
                    this.width === t && this.height === e || (this.width = t, this.height = e, this.texture.image.width = t, this.texture.image.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Ze.prototype = Object.assign(Object.create(Je.prototype), {
                constructor: Ze,
                isWebGLMultisampleRenderTarget: !0,
                copy: function(t) {
                    return Je.prototype.copy.call(this, t), this.samples = t.samples, this
                }
            }), Object.assign(Qe.prototype, {
                isMatrix4: !0,
                set: function(t, e, n, r, i, o, a, s, c, u, l, h, p, d, f, m) {
                    var v = this.elements;
                    return v[0] = t, v[4] = e, v[8] = n, v[12] = r, v[1] = i, v[5] = o, v[9] = a, v[13] = s, v[2] = c, v[6] = u, v[10] = l, v[14] = h, v[3] = p, v[7] = d, v[11] = f, v[15] = m, this
                },
                identity: function() {
                    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                clone: function() {
                    return (new Qe).fromArray(this.elements)
                },
                copy: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
                },
                copyPosition: function(t) {
                    var e = this.elements,
                        n = t.elements;
                    return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
                },
                extractBasis: function(t, e, n) {
                    return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
                },
                makeBasis: function(t, e, n) {
                    return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
                },
                extractRotation: function() {
                    var t = new je;
                    return function(e) {
                        var n = this.elements,
                            r = e.elements,
                            i = 1 / t.setFromMatrixColumn(e, 0).length(),
                            o = 1 / t.setFromMatrixColumn(e, 1).length(),
                            a = 1 / t.setFromMatrixColumn(e, 2).length();
                        return n[0] = r[0] * i, n[1] = r[1] * i, n[2] = r[2] * i, n[3] = 0, n[4] = r[4] * o, n[5] = r[5] * o, n[6] = r[6] * o, n[7] = 0, n[8] = r[8] * a, n[9] = r[9] * a, n[10] = r[10] * a, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this
                    }
                }(),
                makeRotationFromEuler: function(t) {
                    t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
                    var e = this.elements,
                        n = t.x,
                        r = t.y,
                        i = t.z,
                        o = Math.cos(n),
                        a = Math.sin(n),
                        s = Math.cos(r),
                        c = Math.sin(r),
                        u = Math.cos(i),
                        l = Math.sin(i);
                    if ("XYZ" === t.order) {
                        var h = o * u,
                            p = o * l,
                            d = a * u,
                            f = a * l;
                        e[0] = s * u, e[4] = -s * l, e[8] = c, e[1] = p + d * c, e[5] = h - f * c, e[9] = -a * s, e[2] = f - h * c, e[6] = d + p * c, e[10] = o * s
                    } else if ("YXZ" === t.order) {
                        var m = s * u,
                            v = s * l,
                            g = c * u,
                            y = c * l;
                        e[0] = m + y * a, e[4] = g * a - v, e[8] = o * c, e[1] = o * l, e[5] = o * u, e[9] = -a, e[2] = v * a - g, e[6] = y + m * a, e[10] = o * s
                    } else if ("ZXY" === t.order) m = s * u, v = s * l, g = c * u, y = c * l, e[0] = m - y * a, e[4] = -o * l, e[8] = g + v * a, e[1] = v + g * a, e[5] = o * u, e[9] = y - m * a, e[2] = -o * c, e[6] = a, e[10] = o * s;
                    else if ("ZYX" === t.order) h = o * u, p = o * l, d = a * u, f = a * l, e[0] = s * u, e[4] = d * c - p, e[8] = h * c + f, e[1] = s * l, e[5] = f * c + h, e[9] = p * c - d, e[2] = -c, e[6] = a * s, e[10] = o * s;
                    else if ("YZX" === t.order) {
                        var x = o * s,
                            b = o * c,
                            w = a * s,
                            _ = a * c;
                        e[0] = s * u, e[4] = _ - x * l, e[8] = w * l + b, e[1] = l, e[5] = o * u, e[9] = -a * u, e[2] = -c * u, e[6] = b * l + w, e[10] = x - _ * l
                    } else "XZY" === t.order && (x = o * s, b = o * c, w = a * s, _ = a * c, e[0] = s * u, e[4] = -l, e[8] = c * u, e[1] = x * l + _, e[5] = o * u, e[9] = b * l - w, e[2] = w * l - b, e[6] = a * u, e[10] = _ * l + x);
                    return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
                },
                makeRotationFromQuaternion: function() {
                    var t = new je(0, 0, 0),
                        e = new je(1, 1, 1);
                    return function(n) {
                        return this.compose(t, n, e)
                    }
                }(),
                lookAt: function() {
                    var t = new je,
                        e = new je,
                        n = new je;
                    return function(r, i, o) {
                        var a = this.elements;
                        return n.subVectors(r, i), 0 === n.lengthSq() && (n.z = 1), n.normalize(), t.crossVectors(o, n), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? n.x += 1e-4 : n.z += 1e-4, n.normalize(), t.crossVectors(o, n)), t.normalize(), e.crossVectors(n, t), a[0] = t.x, a[4] = e.x, a[8] = n.x, a[1] = t.y, a[5] = e.y, a[9] = n.y, a[2] = t.z, a[6] = e.z, a[10] = n.z, this
                    }
                }(),
                multiply: function(t, e) {
                    return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
                },
                premultiply: function(t) {
                    return this.multiplyMatrices(t, this)
                },
                multiplyMatrices: function(t, e) {
                    var n = t.elements,
                        r = e.elements,
                        i = this.elements,
                        o = n[0],
                        a = n[4],
                        s = n[8],
                        c = n[12],
                        u = n[1],
                        l = n[5],
                        h = n[9],
                        p = n[13],
                        d = n[2],
                        f = n[6],
                        m = n[10],
                        v = n[14],
                        g = n[3],
                        y = n[7],
                        x = n[11],
                        b = n[15],
                        w = r[0],
                        _ = r[4],
                        M = r[8],
                        E = r[12],
                        S = r[1],
                        T = r[5],
                        A = r[9],
                        L = r[13],
                        C = r[2],
                        R = r[6],
                        P = r[10],
                        O = r[14],
                        I = r[3],
                        B = r[7],
                        D = r[11],
                        F = r[15];
                    return i[0] = o * w + a * S + s * C + c * I, i[4] = o * _ + a * T + s * R + c * B, i[8] = o * M + a * A + s * P + c * D, i[12] = o * E + a * L + s * O + c * F, i[1] = u * w + l * S + h * C + p * I, i[5] = u * _ + l * T + h * R + p * B, i[9] = u * M + l * A + h * P + p * D, i[13] = u * E + l * L + h * O + p * F, i[2] = d * w + f * S + m * C + v * I, i[6] = d * _ + f * T + m * R + v * B, i[10] = d * M + f * A + m * P + v * D, i[14] = d * E + f * L + m * O + v * F, i[3] = g * w + y * S + x * C + b * I, i[7] = g * _ + y * T + x * R + b * B, i[11] = g * M + y * A + x * P + b * D, i[15] = g * E + y * L + x * O + b * F, this
                },
                multiplyScalar: function(t) {
                    var e = this.elements;
                    return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
                },
                applyToBufferAttribute: function() {
                    var t = new je;
                    return function(e) {
                        for (var n = 0, r = e.count; n < r; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.applyMatrix4(this), e.setXYZ(n, t.x, t.y, t.z);
                        return e
                    }
                }(),
                determinant: function() {
                    var t = this.elements,
                        e = t[0],
                        n = t[4],
                        r = t[8],
                        i = t[12],
                        o = t[1],
                        a = t[5],
                        s = t[9],
                        c = t[13],
                        u = t[2],
                        l = t[6],
                        h = t[10],
                        p = t[14];
                    return t[3] * (+i * s * l - r * c * l - i * a * h + n * c * h + r * a * p - n * s * p) + t[7] * (+e * s * p - e * c * h + i * o * h - r * o * p + r * c * u - i * s * u) + t[11] * (+e * c * l - e * a * p - i * o * l + n * o * p + i * a * u - n * c * u) + t[15] * (-r * a * u - e * s * l + e * a * h + r * o * l - n * o * h + n * s * u)
                },
                transpose: function() {
                    var t, e = this.elements;
                    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
                },
                setPosition: function(t, e, n) {
                    var r = this.elements;
                    return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
                },
                getInverse: function(t, e) {
                    var n = this.elements,
                        r = t.elements,
                        i = r[0],
                        o = r[1],
                        a = r[2],
                        s = r[3],
                        c = r[4],
                        u = r[5],
                        l = r[6],
                        h = r[7],
                        p = r[8],
                        d = r[9],
                        f = r[10],
                        m = r[11],
                        v = r[12],
                        g = r[13],
                        y = r[14],
                        x = r[15],
                        b = d * y * h - g * f * h + g * l * m - u * y * m - d * l * x + u * f * x,
                        w = v * f * h - p * y * h - v * l * m + c * y * m + p * l * x - c * f * x,
                        _ = p * g * h - v * d * h + v * u * m - c * g * m - p * u * x + c * d * x,
                        M = v * d * l - p * g * l - v * u * f + c * g * f + p * u * y - c * d * y,
                        E = i * b + o * w + a * _ + s * M;
                    if (0 === E) {
                        var S = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
                        if (!0 === e) throw new Error(S);
                        return console.warn(S), this.identity()
                    }
                    var T = 1 / E;
                    return n[0] = b * T, n[1] = (g * f * s - d * y * s - g * a * m + o * y * m + d * a * x - o * f * x) * T, n[2] = (u * y * s - g * l * s + g * a * h - o * y * h - u * a * x + o * l * x) * T, n[3] = (d * l * s - u * f * s - d * a * h + o * f * h + u * a * m - o * l * m) * T, n[4] = w * T, n[5] = (p * y * s - v * f * s + v * a * m - i * y * m - p * a * x + i * f * x) * T, n[6] = (v * l * s - c * y * s - v * a * h + i * y * h + c * a * x - i * l * x) * T, n[7] = (c * f * s - p * l * s + p * a * h - i * f * h - c * a * m + i * l * m) * T, n[8] = _ * T, n[9] = (v * d * s - p * g * s - v * o * m + i * g * m + p * o * x - i * d * x) * T, n[10] = (c * g * s - v * u * s + v * o * h - i * g * h - c * o * x + i * u * x) * T, n[11] = (p * u * s - c * d * s - p * o * h + i * d * h + c * o * m - i * u * m) * T, n[12] = M * T, n[13] = (p * g * a - v * d * a + v * o * f - i * g * f - p * o * y + i * d * y) * T, n[14] = (v * u * a - c * g * a - v * o * l + i * g * l + c * o * y - i * u * y) * T, n[15] = (c * d * a - p * u * a + p * o * l - i * d * l - c * o * f + i * u * f) * T, this
                },
                scale: function(t) {
                    var e = this.elements,
                        n = t.x,
                        r = t.y,
                        i = t.z;
                    return e[0] *= n, e[4] *= r, e[8] *= i, e[1] *= n, e[5] *= r, e[9] *= i, e[2] *= n, e[6] *= r, e[10] *= i, e[3] *= n, e[7] *= r, e[11] *= i, this
                },
                getMaxScaleOnAxis: function() {
                    var t = this.elements,
                        e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
                        n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
                        r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
                    return Math.sqrt(Math.max(e, n, r))
                },
                makeTranslation: function(t, e, n) {
                    return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
                },
                makeRotationX: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this
                },
                makeRotationY: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this
                },
                makeRotationZ: function(t) {
                    var e = Math.cos(t),
                        n = Math.sin(t);
                    return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
                },
                makeRotationAxis: function(t, e) {
                    var n = Math.cos(e),
                        r = Math.sin(e),
                        i = 1 - n,
                        o = t.x,
                        a = t.y,
                        s = t.z,
                        c = i * o,
                        u = i * a;
                    return this.set(c * o + n, c * a - r * s, c * s + r * a, 0, c * a + r * s, u * a + n, u * s - r * o, 0, c * s - r * a, u * s + r * o, i * s * s + n, 0, 0, 0, 0, 1), this
                },
                makeScale: function(t, e, n) {
                    return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
                },
                makeShear: function(t, e, n) {
                    return this.set(1, e, n, 0, t, 1, n, 0, t, e, 1, 0, 0, 0, 0, 1), this
                },
                compose: function(t, e, n) {
                    var r = this.elements,
                        i = e._x,
                        o = e._y,
                        a = e._z,
                        s = e._w,
                        c = i + i,
                        u = o + o,
                        l = a + a,
                        h = i * c,
                        p = i * u,
                        d = i * l,
                        f = o * u,
                        m = o * l,
                        v = a * l,
                        g = s * c,
                        y = s * u,
                        x = s * l,
                        b = n.x,
                        w = n.y,
                        _ = n.z;
                    return r[0] = (1 - (f + v)) * b, r[1] = (p + x) * b, r[2] = (d - y) * b, r[3] = 0, r[4] = (p - x) * w, r[5] = (1 - (h + v)) * w, r[6] = (m + g) * w, r[7] = 0, r[8] = (d + y) * _, r[9] = (m - g) * _, r[10] = (1 - (h + f)) * _, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
                },
                decompose: function() {
                    var t = new je,
                        e = new Qe;
                    return function(n, r, i) {
                        var o = this.elements,
                            a = t.set(o[0], o[1], o[2]).length(),
                            s = t.set(o[4], o[5], o[6]).length(),
                            c = t.set(o[8], o[9], o[10]).length();
                        this.determinant() < 0 && (a = -a), n.x = o[12], n.y = o[13], n.z = o[14], e.copy(this);
                        var u = 1 / a,
                            l = 1 / s,
                            h = 1 / c;
                        return e.elements[0] *= u, e.elements[1] *= u, e.elements[2] *= u, e.elements[4] *= l, e.elements[5] *= l, e.elements[6] *= l, e.elements[8] *= h, e.elements[9] *= h, e.elements[10] *= h, r.setFromRotationMatrix(e), i.x = a, i.y = s, i.z = c, this
                    }
                }(),
                makePerspective: function(t, e, n, r, i, o) {
                    void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
                    var a = this.elements,
                        s = 2 * i / (e - t),
                        c = 2 * i / (n - r),
                        u = (e + t) / (e - t),
                        l = (n + r) / (n - r),
                        h = -(o + i) / (o - i),
                        p = -2 * o * i / (o - i);
                    return a[0] = s, a[4] = 0, a[8] = u, a[12] = 0, a[1] = 0, a[5] = c, a[9] = l, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = h, a[14] = p, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this
                },
                makeOrthographic: function(t, e, n, r, i, o) {
                    var a = this.elements,
                        s = 1 / (e - t),
                        c = 1 / (n - r),
                        u = 1 / (o - i),
                        l = (e + t) * s,
                        h = (n + r) * c,
                        p = (o + i) * u;
                    return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -l, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -h, a[2] = 0, a[6] = 0, a[10] = -2 * u, a[14] = -p, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this
                },
                equals: function(t) {
                    for (var e = this.elements, n = t.elements, r = 0; r < 16; r++)
                        if (e[r] !== n[r]) return !1;
                    return !0
                },
                fromArray: function(t, e) {
                    void 0 === e && (e = 0);
                    for (var n = 0; n < 16; n++) this.elements[n] = t[n + e];
                    return this
                },
                toArray: function(t, e) {
                    void 0 === t && (t = []), void 0 === e && (e = 0);
                    var n = this.elements;
                    return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
                }
            }), Ke.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"], Ke.DefaultOrder = "XYZ", Object.defineProperties(Ke.prototype, {
                x: {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = t, this._onChangeCallback()
                    }
                },
                y: {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = t, this._onChangeCallback()
                    }
                },
                z: {
                    get: function() {
                        return this._z
                    },
                    set: function(t) {
                        this._z = t, this._onChangeCallback()
                    }
                },
                order: {
                    get: function() {
                        return this._order
                    },
                    set: function(t) {
                        this._order = t, this._onChangeCallback()
                    }
                }
            }), Object.assign(Ke.prototype, {
                isEuler: !0,
                set: function(t, e, n, r) {
                    return this._x = t, this._y = e, this._z = n, this._order = r || this._order, this._onChangeCallback(), this
                },
                clone: function() {
                    return new this.constructor(this._x, this._y, this._z, this._order)
                },
                copy: function(t) {
                    return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
                },
                setFromRotationMatrix: function(t, e, n) {
                    var r = Ge.clamp,
                        i = t.elements,
                        o = i[0],
                        a = i[4],
                        s = i[8],
                        c = i[1],
                        u = i[5],
                        l = i[9],
                        h = i[2],
                        p = i[6],
                        d = i[10];
                    return "XYZ" === (e = e || this._order) ? (this._y = Math.asin(r(s, -1, 1)), Math.abs(s) < .99999 ? (this._x = Math.atan2(-l, d), this._z = Math.atan2(-a, o)) : (this._x = Math.atan2(p, u), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-r(l, -1, 1)), Math.abs(l) < .99999 ? (this._y = Math.atan2(s, d), this._z = Math.atan2(c, u)) : (this._y = Math.atan2(-h, o), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(r(p, -1, 1)), Math.abs(p) < .99999 ? (this._y = Math.atan2(-h, d), this._z = Math.atan2(-a, u)) : (this._y = 0, this._z = Math.atan2(c, o))) : "ZYX" === e ? (this._y = Math.asin(-r(h, -1, 1)), Math.abs(h) < .99999 ? (this._x = Math.atan2(p, d), this._z = Math.atan2(c, o)) : (this._x = 0, this._z = Math.atan2(-a, u))) : "YZX" === e ? (this._z = Math.asin(r(c, -1, 1)), Math.abs(c) < .99999 ? (this._x = Math.atan2(-l, u), this._y = Math.atan2(-h, o)) : (this._x = 0, this._y = Math.atan2(s, d))) : "XZY" === e ? (this._z = Math.asin(-r(a, -1, 1)), Math.abs(a) < .99999 ? (this._x = Math.atan2(p, u), this._y = Math.atan2(s, o)) : (this._x = Math.atan2(-l, d), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== n && this._onChangeCallback(), this
                },
                setFromQuaternion: function() {
                    var t = new Qe;
                    return function(e, n, r) {
                        return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, n, r)
                    }
                }(),
                setFromVector3: function(t, e) {
                    return this.set(t.x, t.y, t.z, e || this._order)
                },
                reorder: function() {
                    var t = new Ue;
                    return function(e) {
                        return t.setFromEuler(this), this.setFromQuaternion(t, e)
                    }
                }(),
                equals: function(t) {
                    return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
                },
                fromArray: function(t) {
                    return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
                },
                toVector3: function(t) {
                    return t ? t.set(this._x, this._y, this._z) : new je(this._x, this._y, this._z)
                },
                _onChange: function(t) {
                    return this._onChangeCallback = t, this
                },
                _onChangeCallback: function() {}
            }), Object.assign($e.prototype, {
                set: function(t) {
                    this.mask = 1 << t | 0
                },
                enable: function(t) {
                    this.mask |= 1 << t | 0
                },
                toggle: function(t) {
                    this.mask ^= 1 << t | 0
                },
                disable: function(t) {
                    this.mask &= ~(1 << t | 0)
                },
                test: function(t) {
                    return 0 != (this.mask & t.mask)
                }
            });
            var tn = 0;

            function en() {
                Object.defineProperty(this, "id", {
                    value: tn++
                }), this.uuid = Ge.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = en.DefaultUp.clone();
                var t = new je,
                    e = new Ke,
                    n = new Ue,
                    r = new je(1, 1, 1);
                e._onChange(function() {
                    n.setFromEuler(e, !1)
                }), n._onChange(function() {
                    e.setFromQuaternion(n, void 0, !1)
                }), Object.defineProperties(this, {
                    position: {
                        configurable: !0,
                        enumerable: !0,
                        value: t
                    },
                    rotation: {
                        configurable: !0,
                        enumerable: !0,
                        value: e
                    },
                    quaternion: {
                        configurable: !0,
                        enumerable: !0,
                        value: n
                    },
                    scale: {
                        configurable: !0,
                        enumerable: !0,
                        value: r
                    },
                    modelViewMatrix: {
                        value: new Qe
                    },
                    normalMatrix: {
                        value: new Ve
                    }
                }), this.matrix = new Qe, this.matrixWorld = new Qe, this.matrixAutoUpdate = en.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new $e, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
            }

            function nn() {
                en.call(this), this.type = "Scene", this.background = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function rn(t, e) {
                this.min = void 0 !== t ? t : new je(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new je(-1 / 0, -1 / 0, -1 / 0)
            }

            function on(t, e) {
                this.center = void 0 !== t ? t : new je, this.radius = void 0 !== e ? e : 0
            }

            function an(t, e) {
                this.origin = void 0 !== t ? t : new je, this.direction = void 0 !== e ? e : new je
            }

            function sn(t, e, n) {
                this.a = void 0 !== t ? t : new je, this.b = void 0 !== e ? e : new je, this.c = void 0 !== n ? n : new je
            }
            en.DefaultUp = new je(0, 1, 0), en.DefaultMatrixAutoUpdate = !0, en.prototype = Object.assign(Object.create(r.prototype), {
                constructor: en,
                isObject3D: !0,
                onBeforeRender: function() {},
                onAfterRender: function() {},
                applyMatrix: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
                },
                applyQuaternion: function(t) {
                    return this.quaternion.premultiply(t), this
                },
                setRotationFromAxisAngle: function(t, e) {
                    this.quaternion.setFromAxisAngle(t, e)
                },
                setRotationFromEuler: function(t) {
                    this.quaternion.setFromEuler(t, !0)
                },
                setRotationFromMatrix: function(t) {
                    this.quaternion.setFromRotationMatrix(t)
                },
                setRotationFromQuaternion: function(t) {
                    this.quaternion.copy(t)
                },
                rotateOnAxis: function() {
                    var t = new Ue;
                    return function(e, n) {
                        return t.setFromAxisAngle(e, n), this.quaternion.multiply(t), this
                    }
                }(),
                rotateOnWorldAxis: function() {
                    var t = new Ue;
                    return function(e, n) {
                        return t.setFromAxisAngle(e, n), this.quaternion.premultiply(t), this
                    }
                }(),
                rotateX: function() {
                    var t = new je(1, 0, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateY: function() {
                    var t = new je(0, 1, 0);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                rotateZ: function() {
                    var t = new je(0, 0, 1);
                    return function(e) {
                        return this.rotateOnAxis(t, e)
                    }
                }(),
                translateOnAxis: function() {
                    var t = new je;
                    return function(e, n) {
                        return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(n)), this
                    }
                }(),
                translateX: function() {
                    var t = new je(1, 0, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateY: function() {
                    var t = new je(0, 1, 0);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                translateZ: function() {
                    var t = new je(0, 0, 1);
                    return function(e) {
                        return this.translateOnAxis(t, e)
                    }
                }(),
                localToWorld: function(t) {
                    return t.applyMatrix4(this.matrixWorld)
                },
                worldToLocal: function() {
                    var t = new Qe;
                    return function(e) {
                        return e.applyMatrix4(t.getInverse(this.matrixWorld))
                    }
                }(),
                lookAt: function() {
                    var t = new Ue,
                        e = new Qe,
                        n = new je,
                        r = new je;
                    return function(i, o, a) {
                        i.isVector3 ? n.copy(i) : n.set(i, o, a);
                        var s = this.parent;
                        this.updateWorldMatrix(!0, !1), r.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? e.lookAt(r, n, this.up) : e.lookAt(n, r, this.up), this.quaternion.setFromRotationMatrix(e), s && (e.extractRotation(s.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
                    }
                }(),
                add: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                        return this
                    }
                    return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent({
                        type: "added"
                    })) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
                },
                remove: function(t) {
                    if (arguments.length > 1) {
                        for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                        return this
                    }
                    var n = this.children.indexOf(t);
                    return -1 !== n && (t.parent = null, this.children.splice(n, 1), t.dispatchEvent({
                        type: "removed"
                    })), this
                },
                attach: function() {
                    var t = new Qe;
                    return function(e) {
                        return this.updateWorldMatrix(!0, !1), t.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), t.multiply(e.parent.matrixWorld)), e.applyMatrix(t), e.updateWorldMatrix(!1, !1), this.add(e), this
                    }
                }(),
                getObjectById: function(t) {
                    return this.getObjectByProperty("id", t)
                },
                getObjectByName: function(t) {
                    return this.getObjectByProperty("name", t)
                },
                getObjectByProperty: function(t, e) {
                    if (this[t] === e) return this;
                    for (var n = 0, r = this.children.length; n < r; n++) {
                        var i = this.children[n].getObjectByProperty(t, e);
                        if (void 0 !== i) return i
                    }
                },
                getWorldPosition: function(t) {
                    return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new je), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
                },
                getWorldQuaternion: function() {
                    var t = new je,
                        e = new je;
                    return function(n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), n = new Ue), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, n, e), n
                    }
                }(),
                getWorldScale: function() {
                    var t = new je,
                        e = new Ue;
                    return function(n) {
                        return void 0 === n && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), n = new je), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, n), n
                    }
                }(),
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new je), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(e[8], e[9], e[10]).normalize()
                },
                raycast: function() {},
                traverse: function(t) {
                    t(this);
                    for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverse(t)
                },
                traverseVisible: function(t) {
                    if (!1 !== this.visible) {
                        t(this);
                        for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].traverseVisible(t)
                    }
                },
                traverseAncestors: function(t) {
                    var e = this.parent;
                    null !== e && (t(e), e.traverseAncestors(t))
                },
                updateMatrix: function() {
                    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
                },
                updateMatrixWorld: function(t) {
                    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
                    for (var e = this.children, n = 0, r = e.length; n < r; n++) e[n].updateMatrixWorld(t)
                },
                updateWorldMatrix: function(t, e) {
                    var n = this.parent;
                    if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e)
                        for (var r = this.children, i = 0, o = r.length; i < o; i++) r[i].updateWorldMatrix(!1, !0)
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t,
                        n = {};
                    e && (t = {
                        geometries: {},
                        materials: {},
                        textures: {},
                        images: {},
                        shapes: {}
                    }, n.metadata = {
                        version: 4.5,
                        type: "Object",
                        generator: "Object3D.toJSON"
                    });
                    var r = {};

                    function i(e, n) {
                        return void 0 === e[n.uuid] && (e[n.uuid] = n.toJSON(t)), n.uuid
                    }
                    if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), !0 === this.castShadow && (r.castShadow = !0), !0 === this.receiveShadow && (r.receiveShadow = !0), !1 === this.visible && (r.visible = !1), !1 === this.frustumCulled && (r.frustumCulled = !1), 0 !== this.renderOrder && (r.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (r.matrixAutoUpdate = !1), this.isMesh && this.drawMode !== Se && (r.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                        r.geometry = i(t.geometries, this.geometry);
                        var o = this.geometry.parameters;
                        if (void 0 !== o && void 0 !== o.shapes) {
                            var a = o.shapes;
                            if (Array.isArray(a))
                                for (var s = 0, c = a.length; s < c; s++) {
                                    var u = a[s];
                                    i(t.shapes, u)
                                } else i(t.shapes, a)
                        }
                    }
                    if (void 0 !== this.material)
                        if (Array.isArray(this.material)) {
                            var l = [];
                            for (s = 0, c = this.material.length; s < c; s++) l.push(i(t.materials, this.material[s]));
                            r.material = l
                        } else r.material = i(t.materials, this.material);
                    if (this.children.length > 0)
                        for (r.children = [], s = 0; s < this.children.length; s++) r.children.push(this.children[s].toJSON(t).object);
                    if (e) {
                        var h = m(t.geometries),
                            p = m(t.materials),
                            d = m(t.textures),
                            f = m(t.images);
                        a = m(t.shapes), h.length > 0 && (n.geometries = h), p.length > 0 && (n.materials = p), d.length > 0 && (n.textures = d), f.length > 0 && (n.images = f), a.length > 0 && (n.shapes = a)
                    }
                    return n.object = r, n;

                    function m(t) {
                        var e = [];
                        for (var n in t) {
                            var r = t[n];
                            delete r.metadata, e.push(r)
                        }
                        return e
                    }
                },
                clone: function(t) {
                    return (new this.constructor).copy(this, t)
                },
                copy: function(t, e) {
                    if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e)
                        for (var n = 0; n < t.children.length; n++) {
                            var r = t.children[n];
                            this.add(r.clone())
                        }
                    return this
                }
            }), nn.prototype = Object.assign(Object.create(en.prototype), {
                constructor: nn,
                isScene: !0,
                copy: function(t, e) {
                    return en.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
                },
                toJSON: function(t) {
                    var e = en.prototype.toJSON.call(this, t);
                    return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Object.assign(rn.prototype, {
                isBox3: !0,
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromArray: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) {
                        var u = t[s],
                            l = t[s + 1],
                            h = t[s + 2];
                        u < e && (e = u), l < n && (n = l), h < r && (r = h), u > i && (i = u), l > o && (o = l), h > a && (a = h)
                    }
                    return this.min.set(e, n, r), this.max.set(i, o, a), this
                },
                setFromBufferAttribute: function(t) {
                    for (var e = 1 / 0, n = 1 / 0, r = 1 / 0, i = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) {
                        var u = t.getX(s),
                            l = t.getY(s),
                            h = t.getZ(s);
                        u < e && (e = u), l < n && (n = l), h < r && (r = h), u > i && (i = u), l > o && (o = l), h > a && (a = h)
                    }
                    return this.min.set(e, n, r), this.max.set(i, o, a), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new je;
                    return function(e, n) {
                        var r = t.copy(n).multiplyScalar(.5);
                        return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                    }
                }(),
                setFromObject: function(t) {
                    return this.makeEmpty(), this.expandByObject(t)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new je), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                expandByObject: function() {
                    var t, e, n, r = new je;

                    function i(i) {
                        var o = i.geometry;
                        if (void 0 !== o)
                            if (o.isGeometry) {
                                var a = o.vertices;
                                for (e = 0, n = a.length; e < n; e++) r.copy(a[e]), r.applyMatrix4(i.matrixWorld), t.expandByPoint(r)
                            } else if (o.isBufferGeometry) {
                            var s = o.attributes.position;
                            if (void 0 !== s)
                                for (e = 0, n = s.count; e < n; e++) r.fromBufferAttribute(s, e).applyMatrix4(i.matrixWorld), t.expandByPoint(r)
                        }
                    }
                    return function(e) {
                        return t = this, e.updateMatrixWorld(!0), e.traverse(i), this
                    }
                }(),
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new je), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
                },
                intersectsSphere: function() {
                    var t = new je;
                    return function(e) {
                        return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
                    }
                }(),
                intersectsPlane: function(t) {
                    var e, n;
                    return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
                },
                intersectsTriangle: function() {
                    var t = new je,
                        e = new je,
                        n = new je,
                        r = new je,
                        i = new je,
                        o = new je,
                        a = new je,
                        s = new je,
                        c = new je,
                        u = new je;

                    function l(r) {
                        var i, o;
                        for (i = 0, o = r.length - 3; i <= o; i += 3) {
                            a.fromArray(r, i);
                            var s = c.x * Math.abs(a.x) + c.y * Math.abs(a.y) + c.z * Math.abs(a.z),
                                u = t.dot(a),
                                l = e.dot(a),
                                h = n.dot(a);
                            if (Math.max(-Math.max(u, l, h), Math.min(u, l, h)) > s) return !1
                        }
                        return !0
                    }
                    return function(a) {
                        if (this.isEmpty()) return !1;
                        this.getCenter(s), c.subVectors(this.max, s), t.subVectors(a.a, s), e.subVectors(a.b, s), n.subVectors(a.c, s), r.subVectors(e, t), i.subVectors(n, e), o.subVectors(t, n);
                        var h = [0, -r.z, r.y, 0, -i.z, i.y, 0, -o.z, o.y, r.z, 0, -r.x, i.z, 0, -i.x, o.z, 0, -o.x, -r.y, r.x, 0, -i.y, i.x, 0, -o.y, o.x, 0];
                        return !!l(h) && (!!l(h = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(r, i), l(h = [u.x, u.y, u.z])))
                    }
                }(),
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new je), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new je;
                    return function(e) {
                        return t.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                }(),
                getBoundingSphere: function() {
                    var t = new je;
                    return function(e) {
                        return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                applyMatrix4: function() {
                    var t = [new je, new je, new je, new je, new je, new je, new je, new je];
                    return function(e) {
                        return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
                    }
                }(),
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(on.prototype, {
                set: function(t, e) {
                    return this.center.copy(t), this.radius = e, this
                },
                setFromPoints: function() {
                    var t = new rn;
                    return function(e, n) {
                        var r = this.center;
                        void 0 !== n ? r.copy(n) : t.setFromPoints(e).getCenter(r);
                        for (var i = 0, o = 0, a = e.length; o < a; o++) i = Math.max(i, r.distanceToSquared(e[o]));
                        return this.radius = Math.sqrt(i), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.center.copy(t.center), this.radius = t.radius, this
                },
                empty: function() {
                    return this.radius <= 0
                },
                containsPoint: function(t) {
                    return t.distanceToSquared(this.center) <= this.radius * this.radius
                },
                distanceToPoint: function(t) {
                    return t.distanceTo(this.center) - this.radius
                },
                intersectsSphere: function(t) {
                    var e = this.radius + t.radius;
                    return t.center.distanceToSquared(this.center) <= e * e
                },
                intersectsBox: function(t) {
                    return t.intersectsSphere(this)
                },
                intersectsPlane: function(t) {
                    return Math.abs(t.distanceToPoint(this.center)) <= this.radius
                },
                clampPoint: function(t, e) {
                    var n = this.center.distanceToSquared(t);
                    return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new je), e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
                },
                getBoundingBox: function(t) {
                    return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new rn), t.set(this.center, this.center), t.expandByScalar(this.radius), t
                },
                applyMatrix4: function(t) {
                    return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
                },
                translate: function(t) {
                    return this.center.add(t), this
                },
                equals: function(t) {
                    return t.center.equals(this.center) && t.radius === this.radius
                }
            }), Object.assign(an.prototype, {
                set: function(t, e) {
                    return this.origin.copy(t), this.direction.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.origin.copy(t.origin), this.direction.copy(t.direction), this
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new je), e.copy(this.direction).multiplyScalar(t).add(this.origin)
                },
                lookAt: function(t) {
                    return this.direction.copy(t).sub(this.origin).normalize(), this
                },
                recast: function() {
                    var t = new je;
                    return function(e) {
                        return this.origin.copy(this.at(e, t)), this
                    }
                }(),
                closestPointToPoint: function(t, e) {
                    void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new je), e.subVectors(t, this.origin);
                    var n = e.dot(this.direction);
                    return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
                },
                distanceToPoint: function(t) {
                    return Math.sqrt(this.distanceSqToPoint(t))
                },
                distanceSqToPoint: function() {
                    var t = new je;
                    return function(e) {
                        var n = t.subVectors(e, this.origin).dot(this.direction);
                        return n < 0 ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(n).add(this.origin), t.distanceToSquared(e))
                    }
                }(),
                distanceSqToSegment: function() {
                    var t = new je,
                        e = new je,
                        n = new je;
                    return function(r, i, o, a) {
                        t.copy(r).add(i).multiplyScalar(.5), e.copy(i).sub(r).normalize(), n.copy(this.origin).sub(t);
                        var s, c, u, l, h = .5 * r.distanceTo(i),
                            p = -this.direction.dot(e),
                            d = n.dot(this.direction),
                            f = -n.dot(e),
                            m = n.lengthSq(),
                            v = Math.abs(1 - p * p);
                        if (v > 0)
                            if (c = p * d - f, l = h * v, (s = p * f - d) >= 0)
                                if (c >= -l)
                                    if (c <= l) {
                                        var g = 1 / v;
                                        u = (s *= g) * (s + p * (c *= g) + 2 * d) + c * (p * s + c + 2 * f) + m
                                    } else c = h, u = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                        else c = -h, u = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                        else c <= -l ? u = -(s = Math.max(0, -(-p * h + d))) * s + (c = s > 0 ? -h : Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m : c <= l ? (s = 0, u = (c = Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m) : u = -(s = Math.max(0, -(p * h + d))) * s + (c = s > 0 ? h : Math.min(Math.max(-h, -f), h)) * (c + 2 * f) + m;
                        else c = p > 0 ? -h : h, u = -(s = Math.max(0, -(p * c + d))) * s + c * (c + 2 * f) + m;
                        return o && o.copy(this.direction).multiplyScalar(s).add(this.origin), a && a.copy(e).multiplyScalar(c).add(t), u
                    }
                }(),
                intersectSphere: function() {
                    var t = new je;
                    return function(e, n) {
                        t.subVectors(e.center, this.origin);
                        var r = t.dot(this.direction),
                            i = t.dot(t) - r * r,
                            o = e.radius * e.radius;
                        if (i > o) return null;
                        var a = Math.sqrt(o - i),
                            s = r - a,
                            c = r + a;
                        return s < 0 && c < 0 ? null : s < 0 ? this.at(c, n) : this.at(s, n)
                    }
                }(),
                intersectsSphere: function(t) {
                    return this.distanceSqToPoint(t.center) <= t.radius * t.radius
                },
                distanceToPlane: function(t) {
                    var e = t.normal.dot(this.direction);
                    if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
                    var n = -(this.origin.dot(t.normal) + t.constant) / e;
                    return n >= 0 ? n : null
                },
                intersectPlane: function(t, e) {
                    var n = this.distanceToPlane(t);
                    return null === n ? null : this.at(n, e)
                },
                intersectsPlane: function(t) {
                    var e = t.distanceToPoint(this.origin);
                    return 0 === e || t.normal.dot(this.direction) * e < 0
                },
                intersectBox: function(t, e) {
                    var n, r, i, o, a, s, c = 1 / this.direction.x,
                        u = 1 / this.direction.y,
                        l = 1 / this.direction.z,
                        h = this.origin;
                    return c >= 0 ? (n = (t.min.x - h.x) * c, r = (t.max.x - h.x) * c) : (n = (t.max.x - h.x) * c, r = (t.min.x - h.x) * c), u >= 0 ? (i = (t.min.y - h.y) * u, o = (t.max.y - h.y) * u) : (i = (t.max.y - h.y) * u, o = (t.min.y - h.y) * u), n > o || i > r ? null : ((i > n || n != n) && (n = i), (o < r || r != r) && (r = o), l >= 0 ? (a = (t.min.z - h.z) * l, s = (t.max.z - h.z) * l) : (a = (t.max.z - h.z) * l, s = (t.min.z - h.z) * l), n > s || a > r ? null : ((a > n || n != n) && (n = a), (s < r || r != r) && (r = s), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
                },
                intersectsBox: function() {
                    var t = new je;
                    return function(e) {
                        return null !== this.intersectBox(e, t)
                    }
                }(),
                intersectTriangle: function() {
                    var t = new je,
                        e = new je,
                        n = new je,
                        r = new je;
                    return function(i, o, a, s, c) {
                        e.subVectors(o, i), n.subVectors(a, i), r.crossVectors(e, n);
                        var u, l = this.direction.dot(r);
                        if (l > 0) {
                            if (s) return null;
                            u = 1
                        } else {
                            if (!(l < 0)) return null;
                            u = -1, l = -l
                        }
                        t.subVectors(this.origin, i);
                        var h = u * this.direction.dot(n.crossVectors(t, n));
                        if (h < 0) return null;
                        var p = u * this.direction.dot(e.cross(t));
                        if (p < 0) return null;
                        if (h + p > l) return null;
                        var d = -u * t.dot(r);
                        return d < 0 ? null : this.at(d / l, c)
                    }
                }(),
                applyMatrix4: function(t) {
                    return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
                },
                equals: function(t) {
                    return t.origin.equals(this.origin) && t.direction.equals(this.direction)
                }
            }), Object.assign(sn, {
                getNormal: function() {
                    var t = new je;
                    return function(e, n, r, i) {
                        void 0 === i && (console.warn("THREE.Triangle: .getNormal() target is now required"), i = new je), i.subVectors(r, n), t.subVectors(e, n), i.cross(t);
                        var o = i.lengthSq();
                        return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0)
                    }
                }(),
                getBarycoord: function() {
                    var t = new je,
                        e = new je,
                        n = new je;
                    return function(r, i, o, a, s) {
                        t.subVectors(a, i), e.subVectors(o, i), n.subVectors(r, i);
                        var c = t.dot(t),
                            u = t.dot(e),
                            l = t.dot(n),
                            h = e.dot(e),
                            p = e.dot(n),
                            d = c * h - u * u;
                        if (void 0 === s && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), s = new je), 0 === d) return s.set(-2, -1, -1);
                        var f = 1 / d,
                            m = (h * l - u * p) * f,
                            v = (c * p - u * l) * f;
                        return s.set(1 - m - v, v, m)
                    }
                }(),
                containsPoint: function() {
                    var t = new je;
                    return function(e, n, r, i) {
                        return sn.getBarycoord(e, n, r, i, t), t.x >= 0 && t.y >= 0 && t.x + t.y <= 1
                    }
                }(),
                getUV: function() {
                    var t = new je;
                    return function(e, n, r, i, o, a, s, c) {
                        return this.getBarycoord(e, n, r, i, t), c.set(0, 0), c.addScaledVector(o, t.x), c.addScaledVector(a, t.y), c.addScaledVector(s, t.z), c
                    }
                }(),
                isFrontFacing: function() {
                    var t = new je,
                        e = new je;
                    return function(n, r, i, o) {
                        return t.subVectors(i, r), e.subVectors(n, r), t.cross(e).dot(o) < 0
                    }
                }()
            }), Object.assign(sn.prototype, {
                set: function(t, e, n) {
                    return this.a.copy(t), this.b.copy(e), this.c.copy(n), this
                },
                setFromPointsAndIndices: function(t, e, n, r) {
                    return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
                },
                getArea: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
                    }
                }(),
                getMidpoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new je), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
                },
                getNormal: function(t) {
                    return sn.getNormal(this.a, this.b, this.c, t)
                },
                getPlane: function(t) {
                    return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new je), t.setFromCoplanarPoints(this.a, this.b, this.c)
                },
                getBarycoord: function(t, e) {
                    return sn.getBarycoord(t, this.a, this.b, this.c, e)
                },
                getUV: function(t, e, n, r, i) {
                    return sn.getUV(t, this.a, this.b, this.c, e, n, r, i)
                },
                containsPoint: function(t) {
                    return sn.containsPoint(t, this.a, this.b, this.c)
                },
                isFrontFacing: function(t) {
                    return sn.isFrontFacing(this.a, this.b, this.c, t)
                },
                intersectsBox: function(t) {
                    return t.intersectsTriangle(this)
                },
                closestPointToPoint: function() {
                    var t = new je,
                        e = new je,
                        n = new je,
                        r = new je,
                        i = new je,
                        o = new je;
                    return function(a, s) {
                        void 0 === s && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), s = new je);
                        var c, u, l = this.a,
                            h = this.b,
                            p = this.c;
                        t.subVectors(h, l), e.subVectors(p, l), r.subVectors(a, l);
                        var d = t.dot(r),
                            f = e.dot(r);
                        if (d <= 0 && f <= 0) return s.copy(l);
                        i.subVectors(a, h);
                        var m = t.dot(i),
                            v = e.dot(i);
                        if (m >= 0 && v <= m) return s.copy(h);
                        var g = d * v - m * f;
                        if (g <= 0 && d >= 0 && m <= 0) return c = d / (d - m), s.copy(l).addScaledVector(t, c);
                        o.subVectors(a, p);
                        var y = t.dot(o),
                            x = e.dot(o);
                        if (x >= 0 && y <= x) return s.copy(p);
                        var b = y * f - d * x;
                        if (b <= 0 && f >= 0 && x <= 0) return u = f / (f - x), s.copy(l).addScaledVector(e, u);
                        var w = m * x - y * v;
                        if (w <= 0 && v - m >= 0 && y - x >= 0) return n.subVectors(p, h), u = (v - m) / (v - m + (y - x)), s.copy(h).addScaledVector(n, u);
                        var _ = 1 / (w + b + g);
                        return c = b * _, u = g * _, s.copy(l).addScaledVector(t, c).addScaledVector(e, u)
                    }
                }(),
                equals: function(t) {
                    return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
                }
            });
            var cn = {
                aliceblue: 15792383,
                antiquewhite: 16444375,
                aqua: 65535,
                aquamarine: 8388564,
                azure: 15794175,
                beige: 16119260,
                bisque: 16770244,
                black: 0,
                blanchedalmond: 16772045,
                blue: 255,
                blueviolet: 9055202,
                brown: 10824234,
                burlywood: 14596231,
                cadetblue: 6266528,
                chartreuse: 8388352,
                chocolate: 13789470,
                coral: 16744272,
                cornflowerblue: 6591981,
                cornsilk: 16775388,
                crimson: 14423100,
                cyan: 65535,
                darkblue: 139,
                darkcyan: 35723,
                darkgoldenrod: 12092939,
                darkgray: 11119017,
                darkgreen: 25600,
                darkgrey: 11119017,
                darkkhaki: 12433259,
                darkmagenta: 9109643,
                darkolivegreen: 5597999,
                darkorange: 16747520,
                darkorchid: 10040012,
                darkred: 9109504,
                darksalmon: 15308410,
                darkseagreen: 9419919,
                darkslateblue: 4734347,
                darkslategray: 3100495,
                darkslategrey: 3100495,
                darkturquoise: 52945,
                darkviolet: 9699539,
                deeppink: 16716947,
                deepskyblue: 49151,
                dimgray: 6908265,
                dimgrey: 6908265,
                dodgerblue: 2003199,
                firebrick: 11674146,
                floralwhite: 16775920,
                forestgreen: 2263842,
                fuchsia: 16711935,
                gainsboro: 14474460,
                ghostwhite: 16316671,
                gold: 16766720,
                goldenrod: 14329120,
                gray: 8421504,
                green: 32768,
                greenyellow: 11403055,
                grey: 8421504,
                honeydew: 15794160,
                hotpink: 16738740,
                indianred: 13458524,
                indigo: 4915330,
                ivory: 16777200,
                khaki: 15787660,
                lavender: 15132410,
                lavenderblush: 16773365,
                lawngreen: 8190976,
                lemonchiffon: 16775885,
                lightblue: 11393254,
                lightcoral: 15761536,
                lightcyan: 14745599,
                lightgoldenrodyellow: 16448210,
                lightgray: 13882323,
                lightgreen: 9498256,
                lightgrey: 13882323,
                lightpink: 16758465,
                lightsalmon: 16752762,
                lightseagreen: 2142890,
                lightskyblue: 8900346,
                lightslategray: 7833753,
                lightslategrey: 7833753,
                lightsteelblue: 11584734,
                lightyellow: 16777184,
                lime: 65280,
                limegreen: 3329330,
                linen: 16445670,
                magenta: 16711935,
                maroon: 8388608,
                mediumaquamarine: 6737322,
                mediumblue: 205,
                mediumorchid: 12211667,
                mediumpurple: 9662683,
                mediumseagreen: 3978097,
                mediumslateblue: 8087790,
                mediumspringgreen: 64154,
                mediumturquoise: 4772300,
                mediumvioletred: 13047173,
                midnightblue: 1644912,
                mintcream: 16121850,
                mistyrose: 16770273,
                moccasin: 16770229,
                navajowhite: 16768685,
                navy: 128,
                oldlace: 16643558,
                olive: 8421376,
                olivedrab: 7048739,
                orange: 16753920,
                orangered: 16729344,
                orchid: 14315734,
                palegoldenrod: 15657130,
                palegreen: 10025880,
                paleturquoise: 11529966,
                palevioletred: 14381203,
                papayawhip: 16773077,
                peachpuff: 16767673,
                peru: 13468991,
                pink: 16761035,
                plum: 14524637,
                powderblue: 11591910,
                purple: 8388736,
                rebeccapurple: 6697881,
                red: 16711680,
                rosybrown: 12357519,
                royalblue: 4286945,
                saddlebrown: 9127187,
                salmon: 16416882,
                sandybrown: 16032864,
                seagreen: 3050327,
                seashell: 16774638,
                sienna: 10506797,
                silver: 12632256,
                skyblue: 8900331,
                slateblue: 6970061,
                slategray: 7372944,
                slategrey: 7372944,
                snow: 16775930,
                springgreen: 65407,
                steelblue: 4620980,
                tan: 13808780,
                teal: 32896,
                thistle: 14204888,
                tomato: 16737095,
                turquoise: 4251856,
                violet: 15631086,
                wheat: 16113331,
                white: 16777215,
                whitesmoke: 16119285,
                yellow: 16776960,
                yellowgreen: 10145074
            };

            function un(t, e, n) {
                return void 0 === e && void 0 === n ? this.set(t) : this.setRGB(t, e, n)
            }

            function ln(t, e, n) {
                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - n) : t
            }

            function hn(t) {
                return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            function pn(t) {
                return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }

            function dn(t, e, n, r, i, o) {
                this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new je, this.vertexNormals = Array.isArray(r) ? r : [], this.color = i && i.isColor ? i : new un, this.vertexColors = Array.isArray(i) ? i : [], this.materialIndex = void 0 !== o ? o : 0
            }
            Object.assign(un.prototype, {
                isColor: !0,
                r: 1,
                g: 1,
                b: 1,
                set: function(t) {
                    return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
                },
                setScalar: function(t) {
                    return this.r = t, this.g = t, this.b = t, this
                },
                setHex: function(t) {
                    return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
                },
                setRGB: function(t, e, n) {
                    return this.r = t, this.g = e, this.b = n, this
                },
                setHSL: function(t, e, n) {
                    if (t = Ge.euclideanModulo(t, 1), e = Ge.clamp(e, 0, 1), n = Ge.clamp(n, 0, 1), 0 === e) this.r = this.g = this.b = n;
                    else {
                        var r = n <= .5 ? n * (1 + e) : n + e - n * e,
                            i = 2 * n - r;
                        this.r = ln(i, r, t + 1 / 3), this.g = ln(i, r, t), this.b = ln(i, r, t - 1 / 3)
                    }
                    return this
                },
                setStyle: function(t) {
                    function e(e) {
                        void 0 !== e && parseFloat(e) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
                    }
                    var n;
                    if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                        var r, i = n[1],
                            o = n[2];
                        switch (i) {
                            case "rgb":
                            case "rgba":
                                if (r = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(r[1], 10)) / 255, this.g = Math.min(255, parseInt(r[2], 10)) / 255, this.b = Math.min(255, parseInt(r[3], 10)) / 255, e(r[5]), this;
                                if (r = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(r[1], 10)) / 100, this.g = Math.min(100, parseInt(r[2], 10)) / 100, this.b = Math.min(100, parseInt(r[3], 10)) / 100, e(r[5]), this;
                                break;
                            case "hsl":
                            case "hsla":
                                if (r = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(o)) {
                                    var a = parseFloat(r[1]) / 360,
                                        s = parseInt(r[2], 10) / 100,
                                        c = parseInt(r[3], 10) / 100;
                                    return e(r[5]), this.setHSL(a, s, c)
                                }
                        }
                    } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(t)) {
                        var u = n[1],
                            l = u.length;
                        if (3 === l) return this.r = parseInt(u.charAt(0) + u.charAt(0), 16) / 255, this.g = parseInt(u.charAt(1) + u.charAt(1), 16) / 255, this.b = parseInt(u.charAt(2) + u.charAt(2), 16) / 255, this;
                        if (6 === l) return this.r = parseInt(u.charAt(0) + u.charAt(1), 16) / 255, this.g = parseInt(u.charAt(2) + u.charAt(3), 16) / 255, this.b = parseInt(u.charAt(4) + u.charAt(5), 16) / 255, this
                    }
                    return t && t.length > 0 && (void 0 !== (u = cn[t]) ? this.setHex(u) : console.warn("THREE.Color: Unknown color " + t)), this
                },
                clone: function() {
                    return new this.constructor(this.r, this.g, this.b)
                },
                copy: function(t) {
                    return this.r = t.r, this.g = t.g, this.b = t.b, this
                },
                copyGammaToLinear: function(t, e) {
                    return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
                },
                copyLinearToGamma: function(t, e) {
                    void 0 === e && (e = 2);
                    var n = e > 0 ? 1 / e : 1;
                    return this.r = Math.pow(t.r, n), this.g = Math.pow(t.g, n), this.b = Math.pow(t.b, n), this
                },
                convertGammaToLinear: function(t) {
                    return this.copyGammaToLinear(this, t), this
                },
                convertLinearToGamma: function(t) {
                    return this.copyLinearToGamma(this, t), this
                },
                copySRGBToLinear: function(t) {
                    return this.r = hn(t.r), this.g = hn(t.g), this.b = hn(t.b), this
                },
                copyLinearToSRGB: function(t) {
                    return this.r = pn(t.r), this.g = pn(t.g), this.b = pn(t.b), this
                },
                convertSRGBToLinear: function() {
                    return this.copySRGBToLinear(this), this
                },
                convertLinearToSRGB: function() {
                    return this.copyLinearToSRGB(this), this
                },
                getHex: function() {
                    return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
                },
                getHexString: function() {
                    return ("000000" + this.getHex().toString(16)).slice(-6)
                },
                getHSL: function(t) {
                    void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {
                        h: 0,
                        s: 0,
                        l: 0
                    });
                    var e, n, r = this.r,
                        i = this.g,
                        o = this.b,
                        a = Math.max(r, i, o),
                        s = Math.min(r, i, o),
                        c = (s + a) / 2;
                    if (s === a) e = 0, n = 0;
                    else {
                        var u = a - s;
                        switch (n = c <= .5 ? u / (a + s) : u / (2 - a - s), a) {
                            case r:
                                e = (i - o) / u + (i < o ? 6 : 0);
                                break;
                            case i:
                                e = (o - r) / u + 2;
                                break;
                            case o:
                                e = (r - i) / u + 4
                        }
                        e /= 6
                    }
                    return t.h = e, t.s = n, t.l = c, t
                },
                getStyle: function() {
                    return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
                },
                offsetHSL: function() {
                    var t = {};
                    return function(e, n, r) {
                        return this.getHSL(t), t.h += e, t.s += n, t.l += r, this.setHSL(t.h, t.s, t.l), this
                    }
                }(),
                add: function(t) {
                    return this.r += t.r, this.g += t.g, this.b += t.b, this
                },
                addColors: function(t, e) {
                    return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
                },
                addScalar: function(t) {
                    return this.r += t, this.g += t, this.b += t, this
                },
                sub: function(t) {
                    return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
                },
                multiply: function(t) {
                    return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
                },
                multiplyScalar: function(t) {
                    return this.r *= t, this.g *= t, this.b *= t, this
                },
                lerp: function(t, e) {
                    return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
                },
                lerpHSL: function() {
                    var t = {
                            h: 0,
                            s: 0,
                            l: 0
                        },
                        e = {
                            h: 0,
                            s: 0,
                            l: 0
                        };
                    return function(n, r) {
                        this.getHSL(t), n.getHSL(e);
                        var i = Ge.lerp(t.h, e.h, r),
                            o = Ge.lerp(t.s, e.s, r),
                            a = Ge.lerp(t.l, e.l, r);
                        return this.setHSL(i, o, a), this
                    }
                }(),
                equals: function(t) {
                    return t.r === this.r && t.g === this.g && t.b === this.b
                },
                fromArray: function(t, e) {
                    return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
                },
                toArray: function(t, e) {
                    return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
                },
                toJSON: function() {
                    return this.getHex()
                }
            }), Object.assign(dn.prototype, {
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
                    for (var e = 0, n = t.vertexNormals.length; e < n; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
                    for (e = 0, n = t.vertexColors.length; e < n; e++) this.vertexColors[e] = t.vertexColors[e].clone();
                    return this
                }
            });
            var fn = 0;

            function mn() {
                Object.defineProperty(this, "id", {
                    value: fn++
                }), this.uuid = Ge.generateUUID(), this.name = "", this.type = "Material", this.fog = !0, this.lights = !0, this.blending = S, this.side = v, this.flatShading = !1, this.vertexTangents = !1, this.vertexColors = w, this.opacity = 1, this.transparent = !1, this.blendSrc = z, this.blendDst = G, this.blendEquation = R, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = J, this.depthTest = !0, this.depthWrite = !0, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
            }

            function vn(t) {
                mn.call(this), this.type = "MeshBasicMaterial", this.color = new un(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function gn(t, e, n) {
                if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function yn(t, e, n) {
                gn.call(this, new Int8Array(t), e, n)
            }

            function xn(t, e, n) {
                gn.call(this, new Uint8Array(t), e, n)
            }

            function bn(t, e, n) {
                gn.call(this, new Uint8ClampedArray(t), e, n)
            }

            function wn(t, e, n) {
                gn.call(this, new Int16Array(t), e, n)
            }

            function _n(t, e, n) {
                gn.call(this, new Uint16Array(t), e, n)
            }

            function Mn(t, e, n) {
                gn.call(this, new Int32Array(t), e, n)
            }

            function En(t, e, n) {
                gn.call(this, new Uint32Array(t), e, n)
            }

            function Sn(t, e, n) {
                gn.call(this, new Float32Array(t), e, n)
            }

            function Tn(t, e, n) {
                gn.call(this, new Float64Array(t), e, n)
            }

            function An() {
                this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Ln(t) {
                if (0 === t.length) return -1 / 0;
                for (var e = t[0], n = 1, r = t.length; n < r; ++n) t[n] > e && (e = t[n]);
                return e
            }
            mn.prototype = Object.assign(Object.create(r.prototype), {
                constructor: mn,
                isMaterial: !0,
                onBeforeCompile: function() {},
                setValues: function(t) {
                    if (void 0 !== t)
                        for (var e in t) {
                            var n = t[e];
                            if (void 0 !== n)
                                if ("shading" !== e) {
                                    var r = this[e];
                                    void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
                                } else console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = n === x;
                            else console.warn("THREE.Material: '" + e + "' parameter is undefined.")
                        }
                },
                toJSON: function(t) {
                    var e = void 0 === t || "string" == typeof t;
                    e && (t = {
                        textures: {},
                        images: {}
                    });
                    var n = {
                        metadata: {
                            version: 4.5,
                            type: "Material",
                            generator: "Material.toJSON"
                        }
                    };

                    function r(t) {
                        var e = [];
                        for (var n in t) {
                            var r = t[n];
                            delete r.metadata, e.push(r)
                        }
                        return e
                    }
                    if (n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, n.refractionRatio = this.refractionRatio, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== S && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), this.side !== v && (n.side = this.side), this.vertexColors !== w && (n.vertexColors = this.vertexColors), this.opacity < 1 && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, this.rotation && 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.morphNormals && (n.morphNormals = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), e) {
                        var i = r(t.textures),
                            o = r(t.images);
                        i.length > 0 && (n.textures = i), o.length > 0 && (n.images = o)
                    }
                    return n
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
                    var e = t.clippingPlanes,
                        n = null;
                    if (null !== e) {
                        var r = e.length;
                        n = new Array(r);
                        for (var i = 0; i !== r; ++i) n[i] = e[i].clone()
                    }
                    return this.clippingPlanes = n, this.shadowSide = t.shadowSide, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), vn.prototype = Object.create(mn.prototype), vn.prototype.constructor = vn, vn.prototype.isMeshBasicMaterial = !0, vn.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
            }, Object.defineProperty(gn.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign(gn.prototype, {
                isBufferAttribute: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.itemSize, n *= e.itemSize;
                    for (var r = 0, i = this.itemSize; r < i; r++) this.array[t + r] = e.array[n + r];
                    return this
                },
                copyArray: function(t) {
                    return this.array.set(t), this
                },
                copyColorsArray: function(t) {
                    for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                        var o = t[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), o = new un), e[n++] = o.r, e[n++] = o.g, e[n++] = o.b
                    }
                    return this
                },
                copyVector2sArray: function(t) {
                    for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                        var o = t[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new He), e[n++] = o.x, e[n++] = o.y
                    }
                    return this
                },
                copyVector3sArray: function(t) {
                    for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                        var o = t[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), o = new je), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z
                    }
                    return this
                },
                copyVector4sArray: function(t) {
                    for (var e = this.array, n = 0, r = 0, i = t.length; r < i; r++) {
                        var o = t[r];
                        void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), o = new Ye), e[n++] = o.x, e[n++] = o.y, e[n++] = o.z, e[n++] = o.w
                    }
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                getX: function(t) {
                    return this.array[t * this.itemSize]
                },
                setX: function(t, e) {
                    return this.array[t * this.itemSize] = e, this
                },
                getY: function(t) {
                    return this.array[t * this.itemSize + 1]
                },
                setY: function(t, e) {
                    return this.array[t * this.itemSize + 1] = e, this
                },
                getZ: function(t) {
                    return this.array[t * this.itemSize + 2]
                },
                setZ: function(t, e) {
                    return this.array[t * this.itemSize + 2] = e, this
                },
                getW: function(t) {
                    return this.array[t * this.itemSize + 3]
                },
                setW: function(t, e) {
                    return this.array[t * this.itemSize + 3] = e, this
                },
                setXY: function(t, e, n) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, r) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
                },
                setXYZW: function(t, e, n, r, i) {
                    return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = i, this
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                },
                clone: function() {
                    return new this.constructor(this.array, this.itemSize).copy(this)
                },
                toJSON: function() {
                    return {
                        itemSize: this.itemSize,
                        type: this.array.constructor.name,
                        array: Array.prototype.slice.call(this.array),
                        normalized: this.normalized
                    }
                }
            }), yn.prototype = Object.create(gn.prototype), yn.prototype.constructor = yn, xn.prototype = Object.create(gn.prototype), xn.prototype.constructor = xn, bn.prototype = Object.create(gn.prototype), bn.prototype.constructor = bn, wn.prototype = Object.create(gn.prototype), wn.prototype.constructor = wn, _n.prototype = Object.create(gn.prototype), _n.prototype.constructor = _n, Mn.prototype = Object.create(gn.prototype), Mn.prototype.constructor = Mn, En.prototype = Object.create(gn.prototype), En.prototype.constructor = En, Sn.prototype = Object.create(gn.prototype), Sn.prototype.constructor = Sn, Tn.prototype = Object.create(gn.prototype), Tn.prototype.constructor = Tn, Object.assign(An.prototype, {
                computeGroups: function(t) {
                    for (var e, n = [], r = void 0, i = t.faces, o = 0; o < i.length; o++) {
                        var a = i[o];
                        a.materialIndex !== r && (r = a.materialIndex, void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), e = {
                            start: 3 * o,
                            materialIndex: r
                        })
                    }
                    void 0 !== e && (e.count = 3 * o - e.start, n.push(e)), this.groups = n
                },
                fromGeometry: function(t) {
                    var e, n = t.faces,
                        r = t.vertices,
                        i = t.faceVertexUvs,
                        o = i[0] && i[0].length > 0,
                        a = i[1] && i[1].length > 0,
                        s = t.morphTargets,
                        c = s.length;
                    if (c > 0) {
                        e = [];
                        for (var u = 0; u < c; u++) e[u] = {
                            name: s[u].name,
                            data: []
                        };
                        this.morphTargets.position = e
                    }
                    var l, h = t.morphNormals,
                        p = h.length;
                    if (p > 0) {
                        for (l = [], u = 0; u < p; u++) l[u] = {
                            name: h[u].name,
                            data: []
                        };
                        this.morphTargets.normal = l
                    }
                    var d = t.skinIndices,
                        f = t.skinWeights,
                        m = d.length === r.length,
                        v = f.length === r.length;
                    for (r.length > 0 && 0 === n.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), u = 0; u < n.length; u++) {
                        var g = n[u];
                        this.vertices.push(r[g.a], r[g.b], r[g.c]);
                        var y = g.vertexNormals;
                        if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
                        else {
                            var x = g.normal;
                            this.normals.push(x, x, x)
                        }
                        var b = g.vertexColors;
                        if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
                        else {
                            var w = g.color;
                            this.colors.push(w, w, w)
                        }
                        if (!0 === o) {
                            var _ = i[0][u];
                            void 0 !== _ ? this.uvs.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", u), this.uvs.push(new He, new He, new He))
                        }!0 === a && (void 0 !== (_ = i[1][u]) ? this.uvs2.push(_[0], _[1], _[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", u), this.uvs2.push(new He, new He, new He)));
                        for (var M = 0; M < c; M++) {
                            var E = s[M].vertices;
                            e[M].data.push(E[g.a], E[g.b], E[g.c])
                        }
                        for (M = 0; M < p; M++) {
                            var S = h[M].vertexNormals[u];
                            l[M].data.push(S.a, S.b, S.c)
                        }
                        m && this.skinIndices.push(d[g.a], d[g.b], d[g.c]), v && this.skinWeights.push(f[g.a], f[g.b], f[g.c])
                    }
                    return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                }
            });
            var Cn = 1;

            function Rn() {
                Object.defineProperty(this, "id", {
                    value: Cn += 2
                }), this.uuid = Ge.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
                    start: 0,
                    count: 1 / 0
                }, this.userData = {}
            }

            function Pn(t, e) {
                en.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new Rn, this.material = void 0 !== e ? e : new vn({
                    color: 16777215 * Math.random()
                }), this.drawMode = Se, this.updateMorphTargets()
            }
            Rn.prototype = Object.assign(Object.create(r.prototype), {
                constructor: Rn,
                isBufferGeometry: !0,
                getIndex: function() {
                    return this.index
                },
                setIndex: function(t) {
                    Array.isArray(t) ? this.index = new(Ln(t) > 65535 ? En : _n)(t, 1) : this.index = t
                },
                addAttribute: function(t, e) {
                    return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new gn(arguments[1], arguments[2])))
                },
                getAttribute: function(t) {
                    return this.attributes[t]
                },
                removeAttribute: function(t) {
                    return delete this.attributes[t], this
                },
                addGroup: function(t, e, n) {
                    this.groups.push({
                        start: t,
                        count: e,
                        materialIndex: void 0 !== n ? n : 0
                    })
                },
                clearGroups: function() {
                    this.groups = []
                },
                setDrawRange: function(t, e) {
                    this.drawRange.start = t, this.drawRange.count = e
                },
                applyMatrix: function(t) {
                    var e = this.attributes.position;
                    void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0);
                    var n = this.attributes.normal;
                    if (void 0 !== n) {
                        var r = (new Ve).getNormalMatrix(t);
                        r.applyToBufferAttribute(n), n.needsUpdate = !0
                    }
                    var i = this.attributes.tangent;
                    return void 0 !== i && ((r = (new Ve).getNormalMatrix(t)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
                },
                rotateX: function() {
                    var t = new Qe;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new Qe;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new Qe;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new Qe;
                    return function(e, n, r) {
                        return t.makeTranslation(e, n, r), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new Qe;
                    return function(e, n, r) {
                        return t.makeScale(e, n, r), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new en;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                center: function() {
                    var t = new je;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                setFromObject: function(t) {
                    var e = t.geometry;
                    if (t.isPoints || t.isLine) {
                        var n = new Sn(3 * e.vertices.length, 3),
                            r = new Sn(3 * e.colors.length, 3);
                        if (this.addAttribute("position", n.copyVector3sArray(e.vertices)), this.addAttribute("color", r.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length) {
                            var i = new Sn(e.lineDistances.length, 1);
                            this.addAttribute("lineDistance", i.copyArray(e.lineDistances))
                        }
                        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
                    } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
                    return this
                },
                setFromPoints: function(t) {
                    for (var e = [], n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        e.push(i.x, i.y, i.z || 0)
                    }
                    return this.addAttribute("position", new Sn(e, 3)), this
                },
                updateFromObject: function(t) {
                    var e, n = t.geometry;
                    if (t.isMesh) {
                        var r = n.__directGeometry;
                        if (!0 === n.elementsNeedUpdate && (r = void 0, n.elementsNeedUpdate = !1), void 0 === r) return this.fromGeometry(n);
                        r.verticesNeedUpdate = n.verticesNeedUpdate, r.normalsNeedUpdate = n.normalsNeedUpdate, r.colorsNeedUpdate = n.colorsNeedUpdate, r.uvsNeedUpdate = n.uvsNeedUpdate, r.groupsNeedUpdate = n.groupsNeedUpdate, n.verticesNeedUpdate = !1, n.normalsNeedUpdate = !1, n.colorsNeedUpdate = !1, n.uvsNeedUpdate = !1, n.groupsNeedUpdate = !1, n = r
                    }
                    return !0 === n.verticesNeedUpdate && (void 0 !== (e = this.attributes.position) && (e.copyVector3sArray(n.vertices), e.needsUpdate = !0), n.verticesNeedUpdate = !1), !0 === n.normalsNeedUpdate && (void 0 !== (e = this.attributes.normal) && (e.copyVector3sArray(n.normals), e.needsUpdate = !0), n.normalsNeedUpdate = !1), !0 === n.colorsNeedUpdate && (void 0 !== (e = this.attributes.color) && (e.copyColorsArray(n.colors), e.needsUpdate = !0), n.colorsNeedUpdate = !1), n.uvsNeedUpdate && (void 0 !== (e = this.attributes.uv) && (e.copyVector2sArray(n.uvs), e.needsUpdate = !0), n.uvsNeedUpdate = !1), n.lineDistancesNeedUpdate && (void 0 !== (e = this.attributes.lineDistance) && (e.copyArray(n.lineDistances), e.needsUpdate = !0), n.lineDistancesNeedUpdate = !1), n.groupsNeedUpdate && (n.computeGroups(t.geometry), this.groups = n.groups, n.groupsNeedUpdate = !1), this
                },
                fromGeometry: function(t) {
                    return t.__directGeometry = (new An).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
                },
                fromDirectGeometry: function(t) {
                    var e = new Float32Array(3 * t.vertices.length);
                    if (this.addAttribute("position", new gn(e, 3).copyVector3sArray(t.vertices)), t.normals.length > 0) {
                        var n = new Float32Array(3 * t.normals.length);
                        this.addAttribute("normal", new gn(n, 3).copyVector3sArray(t.normals))
                    }
                    if (t.colors.length > 0) {
                        var r = new Float32Array(3 * t.colors.length);
                        this.addAttribute("color", new gn(r, 3).copyColorsArray(t.colors))
                    }
                    if (t.uvs.length > 0) {
                        var i = new Float32Array(2 * t.uvs.length);
                        this.addAttribute("uv", new gn(i, 2).copyVector2sArray(t.uvs))
                    }
                    if (t.uvs2.length > 0) {
                        var o = new Float32Array(2 * t.uvs2.length);
                        this.addAttribute("uv2", new gn(o, 2).copyVector2sArray(t.uvs2))
                    }
                    for (var a in this.groups = t.groups, t.morphTargets) {
                        for (var s = [], c = t.morphTargets[a], u = 0, l = c.length; u < l; u++) {
                            var h = c[u],
                                p = new Sn(3 * h.data.length, 3);
                            p.name = h.name, s.push(p.copyVector3sArray(h.data))
                        }
                        this.morphAttributes[a] = s
                    }
                    if (t.skinIndices.length > 0) {
                        var d = new Sn(4 * t.skinIndices.length, 4);
                        this.addAttribute("skinIndex", d.copyVector4sArray(t.skinIndices))
                    }
                    if (t.skinWeights.length > 0) {
                        var f = new Sn(4 * t.skinWeights.length, 4);
                        this.addAttribute("skinWeight", f.copyVector4sArray(t.skinWeights))
                    }
                    return null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
                },
                computeBoundingBox: function() {
                    var t = new rn;
                    return function() {
                        null === this.boundingBox && (this.boundingBox = new rn);
                        var e = this.attributes.position,
                            n = this.morphAttributes.position;
                        if (void 0 !== e) {
                            if (this.boundingBox.setFromBufferAttribute(e), n)
                                for (var r = 0, i = n.length; r < i; r++) {
                                    var o = n[r];
                                    t.setFromBufferAttribute(o), this.boundingBox.expandByPoint(t.min), this.boundingBox.expandByPoint(t.max)
                                }
                        } else this.boundingBox.makeEmpty();
                        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
                    }
                }(),
                computeBoundingSphere: function() {
                    var t = new rn,
                        e = new rn,
                        n = new je;
                    return function() {
                        null === this.boundingSphere && (this.boundingSphere = new on);
                        var r = this.attributes.position,
                            i = this.morphAttributes.position;
                        if (r) {
                            var o = this.boundingSphere.center;
                            if (t.setFromBufferAttribute(r), i)
                                for (var a = 0, s = i.length; a < s; a++) {
                                    var c = i[a];
                                    e.setFromBufferAttribute(c), t.expandByPoint(e.min), t.expandByPoint(e.max)
                                }
                            t.getCenter(o);
                            var u = 0;
                            for (a = 0, s = r.count; a < s; a++) n.fromBufferAttribute(r, a), u = Math.max(u, o.distanceToSquared(n));
                            if (i)
                                for (a = 0, s = i.length; a < s; a++)
                                    for (var l = 0, h = (c = i[a]).count; l < h; l++) n.fromBufferAttribute(c, l), u = Math.max(u, o.distanceToSquared(n));
                            this.boundingSphere.radius = Math.sqrt(u), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                        }
                    }
                }(),
                computeFaceNormals: function() {},
                computeVertexNormals: function() {
                    var t = this.index,
                        e = this.attributes;
                    if (e.position) {
                        var n = e.position.array;
                        if (void 0 === e.normal) this.addAttribute("normal", new gn(new Float32Array(n.length), 3));
                        else
                            for (var r = e.normal.array, i = 0, o = r.length; i < o; i++) r[i] = 0;
                        var a, s, c, u = e.normal.array,
                            l = new je,
                            h = new je,
                            p = new je,
                            d = new je,
                            f = new je;
                        if (t) {
                            var m = t.array;
                            for (i = 0, o = t.count; i < o; i += 3) a = 3 * m[i + 0], s = 3 * m[i + 1], c = 3 * m[i + 2], l.fromArray(n, a), h.fromArray(n, s), p.fromArray(n, c), d.subVectors(p, h), f.subVectors(l, h), d.cross(f), u[a] += d.x, u[a + 1] += d.y, u[a + 2] += d.z, u[s] += d.x, u[s + 1] += d.y, u[s + 2] += d.z, u[c] += d.x, u[c + 1] += d.y, u[c + 2] += d.z
                        } else
                            for (i = 0, o = n.length; i < o; i += 9) l.fromArray(n, i), h.fromArray(n, i + 3), p.fromArray(n, i + 6), d.subVectors(p, h), f.subVectors(l, h), d.cross(f), u[i] = d.x, u[i + 1] = d.y, u[i + 2] = d.z, u[i + 3] = d.x, u[i + 4] = d.y, u[i + 5] = d.z, u[i + 6] = d.x, u[i + 7] = d.y, u[i + 8] = d.z;
                        this.normalizeNormals(), e.normal.needsUpdate = !0
                    }
                },
                merge: function(t, e) {
                    if (t && t.isBufferGeometry) {
                        void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                        var n = this.attributes;
                        for (var r in n)
                            if (void 0 !== t.attributes[r])
                                for (var i = n[r].array, o = t.attributes[r], a = o.array, s = o.itemSize * e, c = Math.min(a.length, i.length - s), u = 0, l = s; u < c; u++, l++) i[l] = a[u];
                        return this
                    }
                    console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
                },
                normalizeNormals: function() {
                    var t = new je;
                    return function() {
                        for (var e = this.attributes.normal, n = 0, r = e.count; n < r; n++) t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.normalize(), e.setXYZ(n, t.x, t.y, t.z)
                    }
                }(),
                toNonIndexed: function() {
                    function t(t, e) {
                        for (var n = t.array, r = t.itemSize, i = new n.constructor(e.length * r), o = 0, a = 0, s = 0, c = e.length; s < c; s++) {
                            o = e[s] * r;
                            for (var u = 0; u < r; u++) i[a++] = n[o++]
                        }
                        return new gn(i, r)
                    }
                    if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
                    var e = new Rn,
                        n = this.index.array,
                        r = this.attributes;
                    for (var i in r) {
                        var o = r[i],
                            a = t(o, n);
                        e.addAttribute(i, a)
                    }
                    var s = this.morphAttributes;
                    for (i in s) {
                        for (var c = [], u = s[i], l = 0, h = u.length; l < h; l++) a = t(o = u[l], n), c.push(a);
                        e.morphAttributes[i] = c
                    }
                    for (var p = this.groups, d = (l = 0, p.length); l < d; l++) {
                        var f = p[l];
                        e.addGroup(f.start, f.count, f.materialIndex)
                    }
                    return e
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "BufferGeometry",
                            generator: "BufferGeometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    t.data = {
                        attributes: {}
                    };
                    var r = this.index;
                    null !== r && (t.data.index = {
                        type: r.array.constructor.name,
                        array: Array.prototype.slice.call(r.array)
                    });
                    var i = this.attributes;
                    for (var n in i) {
                        var o = i[n],
                            a = o.toJSON();
                        "" !== o.name && (a.name = o.name), t.data.attributes[n] = a
                    }
                    var s = {},
                        c = !1;
                    for (var n in this.morphAttributes) {
                        for (var u = this.morphAttributes[n], l = [], h = 0, p = u.length; h < p; h++) a = (o = u[h]).toJSON(), "" !== o.name && (a.name = o.name), l.push(a);
                        l.length > 0 && (s[n] = l, c = !0)
                    }
                    c && (t.data.morphAttributes = s);
                    var d = this.groups;
                    d.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(d)));
                    var f = this.boundingSphere;
                    return null !== f && (t.data.boundingSphere = {
                        center: f.center.toArray(),
                        radius: f.radius
                    }), t
                },
                clone: function() {
                    return (new Rn).copy(this)
                },
                copy: function(t) {
                    var e, n, r;
                    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var i = t.index;
                    null !== i && this.setIndex(i.clone());
                    var o = t.attributes;
                    for (e in o) {
                        var a = o[e];
                        this.addAttribute(e, a.clone())
                    }
                    var s = t.morphAttributes;
                    for (e in s) {
                        var c = [],
                            u = s[e];
                        for (n = 0, r = u.length; n < r; n++) c.push(u[n].clone());
                        this.morphAttributes[e] = c
                    }
                    var l = t.groups;
                    for (n = 0, r = l.length; n < r; n++) {
                        var h = l[n];
                        this.addGroup(h.start, h.count, h.materialIndex)
                    }
                    var p = t.boundingBox;
                    null !== p && (this.boundingBox = p.clone());
                    var d = t.boundingSphere;
                    return null !== d && (this.boundingSphere = d.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Pn.prototype = Object.assign(Object.create(en.prototype), {
                constructor: Pn,
                isMesh: !0,
                setDrawMode: function(t) {
                    this.drawMode = t
                },
                copy: function(t) {
                    return en.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
                },
                updateMorphTargets: function() {
                    var t, e, n, r = this.geometry;
                    if (r.isBufferGeometry) {
                        var i = r.morphAttributes,
                            o = Object.keys(i);
                        if (o.length > 0) {
                            var a = i[o[0]];
                            if (void 0 !== a)
                                for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = a.length; t < e; t++) n = a[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                        }
                    } else {
                        var s = r.morphTargets;
                        void 0 !== s && s.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
                    }
                },
                raycast: function() {
                    var t = new Qe,
                        e = new an,
                        n = new on,
                        r = new je,
                        i = new je,
                        o = new je,
                        a = new je,
                        s = new je,
                        c = new je,
                        u = new je,
                        l = new je,
                        h = new je,
                        p = new He,
                        d = new He,
                        f = new He,
                        m = new je,
                        v = new je;

                    function x(t, e, n, r, i, o, a, s) {
                        if (null === (e.side === g ? r.intersectTriangle(a, o, i, !0, s) : r.intersectTriangle(i, o, a, e.side !== y, s))) return null;
                        v.copy(s), v.applyMatrix4(t.matrixWorld);
                        var c = n.ray.origin.distanceTo(v);
                        return c < n.near || c > n.far ? null : {
                            distance: c,
                            point: v.clone(),
                            object: t
                        }
                    }

                    function b(t, e, n, v, g, y, b, w, _, M) {
                        r.fromBufferAttribute(g, w), i.fromBufferAttribute(g, _), o.fromBufferAttribute(g, M);
                        var E = t.morphTargetInfluences;
                        if (e.morphTargets && y && E) {
                            u.set(0, 0, 0), l.set(0, 0, 0), h.set(0, 0, 0);
                            for (var S = 0, T = y.length; S < T; S++) {
                                var A = E[S],
                                    L = y[S];
                                0 !== A && (a.fromBufferAttribute(L, w), s.fromBufferAttribute(L, _), c.fromBufferAttribute(L, M), u.addScaledVector(a.sub(r), A), l.addScaledVector(s.sub(i), A), h.addScaledVector(c.sub(o), A))
                            }
                            r.add(u), i.add(l), o.add(h)
                        }
                        var C = x(t, e, n, v, r, i, o, m);
                        if (C) {
                            b && (p.fromBufferAttribute(b, w), d.fromBufferAttribute(b, _), f.fromBufferAttribute(b, M), C.uv = sn.getUV(m, r, i, o, p, d, f, new He));
                            var R = new dn(w, _, M);
                            sn.getNormal(r, i, o, R.normal), C.face = R
                        }
                        return C
                    }
                    return function(r, i) {
                        var o, a = this.geometry,
                            s = this.material,
                            c = this.matrixWorld;
                        if (void 0 !== s && (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(c), !1 !== r.ray.intersectsSphere(n) && (t.getInverse(c), e.copy(r.ray).applyMatrix4(t), null === a.boundingBox || !1 !== e.intersectsBox(a.boundingBox))))
                            if (a.isBufferGeometry) {
                                var u, l, h, v, g, y, w, _, M, E = a.index,
                                    S = a.attributes.position,
                                    T = a.morphAttributes.position,
                                    A = a.attributes.uv,
                                    L = a.groups,
                                    C = a.drawRange;
                                if (null !== E)
                                    if (Array.isArray(s))
                                        for (v = 0, y = L.length; v < y; v++)
                                            for (M = s[(_ = L[v]).materialIndex], g = Math.max(_.start, C.start), w = Math.min(_.start + _.count, C.start + C.count); g < w; g += 3) u = E.getX(g), l = E.getX(g + 1), h = E.getX(g + 2), (o = b(this, M, r, e, S, T, A, u, l, h)) && (o.faceIndex = Math.floor(g / 3), o.face.materialIndex = _.materialIndex, i.push(o));
                                    else
                                        for (v = Math.max(0, C.start), y = Math.min(E.count, C.start + C.count); v < y; v += 3) u = E.getX(v), l = E.getX(v + 1), h = E.getX(v + 2), (o = b(this, s, r, e, S, T, A, u, l, h)) && (o.faceIndex = Math.floor(v / 3), i.push(o));
                                else if (void 0 !== S)
                                    if (Array.isArray(s))
                                        for (v = 0, y = L.length; v < y; v++)
                                            for (M = s[(_ = L[v]).materialIndex], g = Math.max(_.start, C.start), w = Math.min(_.start + _.count, C.start + C.count); g < w; g += 3)(o = b(this, M, r, e, S, T, A, u = g, l = g + 1, h = g + 2)) && (o.faceIndex = Math.floor(g / 3), o.face.materialIndex = _.materialIndex, i.push(o));
                                    else
                                        for (v = Math.max(0, C.start), y = Math.min(S.count, C.start + C.count); v < y; v += 3)(o = b(this, s, r, e, S, T, A, u = v, l = v + 1, h = v + 2)) && (o.faceIndex = Math.floor(v / 3), i.push(o))
                            } else if (a.isGeometry) {
                            var R, P, O, I, B = Array.isArray(s),
                                D = a.vertices,
                                F = a.faces,
                                k = a.faceVertexUvs[0];
                            k.length > 0 && (I = k);
                            for (var N = 0, z = F.length; N < z; N++) {
                                var G = F[N],
                                    H = B ? s[G.materialIndex] : s;
                                if (void 0 !== H && (R = D[G.a], P = D[G.b], O = D[G.c], o = x(this, H, r, e, R, P, O, m))) {
                                    if (I && I[N]) {
                                        var U = I[N];
                                        p.copy(U[0]), d.copy(U[1]), f.copy(U[2]), o.uv = sn.getUV(m, R, P, O, p, d, f, new He)
                                    }
                                    o.face = G, o.faceIndex = N, i.push(o)
                                }
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            });
            var On = 0;

            function In() {
                Object.defineProperty(this, "id", {
                    value: On += 2
                }), this.uuid = Ge.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                    []
                ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1
            }

            function Bn(t, e, n, r, i, o) {
                In.call(this), this.type = "BoxGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                }, this.fromBufferGeometry(new Dn(t, e, n, r, i, o)), this.mergeVertices()
            }

            function Dn(t, e, n, r, i, o) {
                Rn.call(this), this.type = "BoxBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    depth: n,
                    widthSegments: r,
                    heightSegments: i,
                    depthSegments: o
                };
                var a = this;
                t = t || 1, e = e || 1, n = n || 1, r = Math.floor(r) || 1, i = Math.floor(i) || 1, o = Math.floor(o) || 1;
                var s = [],
                    c = [],
                    u = [],
                    l = [],
                    h = 0,
                    p = 0;

                function d(t, e, n, r, i, o, d, f, m, v, g) {
                    var y, x, b = o / m,
                        w = d / v,
                        _ = o / 2,
                        M = d / 2,
                        E = f / 2,
                        S = m + 1,
                        T = v + 1,
                        A = 0,
                        L = 0,
                        C = new je;
                    for (x = 0; x < T; x++) {
                        var R = x * w - M;
                        for (y = 0; y < S; y++) {
                            var P = y * b - _;
                            C[t] = P * r, C[e] = R * i, C[n] = E, c.push(C.x, C.y, C.z), C[t] = 0, C[e] = 0, C[n] = f > 0 ? 1 : -1, u.push(C.x, C.y, C.z), l.push(y / m), l.push(1 - x / v), A += 1
                        }
                    }
                    for (x = 0; x < v; x++)
                        for (y = 0; y < m; y++) {
                            var O = h + y + S * x,
                                I = h + y + S * (x + 1),
                                B = h + (y + 1) + S * (x + 1),
                                D = h + (y + 1) + S * x;
                            s.push(O, I, D), s.push(I, B, D), L += 6
                        }
                    a.addGroup(p, L, g), p += L, h += A
                }
                d("z", "y", "x", -1, -1, n, e, t, o, i, 0), d("z", "y", "x", 1, -1, n, e, -t, o, i, 1), d("x", "z", "y", 1, 1, t, n, e, r, o, 2), d("x", "z", "y", 1, -1, t, n, -e, r, o, 3), d("x", "y", "z", 1, -1, t, e, n, r, i, 4), d("x", "y", "z", -1, -1, t, e, -n, r, i, 5), this.setIndex(s), this.addAttribute("position", new Sn(c, 3)), this.addAttribute("normal", new Sn(u, 3)), this.addAttribute("uv", new Sn(l, 2))
            }

            function Fn(t) {
                var e = {};
                for (var n in t)
                    for (var r in e[n] = {}, t[n]) {
                        var i = t[n][r];
                        i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture) ? e[n][r] = i.clone() : Array.isArray(i) ? e[n][r] = i.slice() : e[n][r] = i
                    }
                return e
            }

            function kn(t) {
                for (var e = {}, n = 0; n < t.length; n++) {
                    var r = Fn(t[n]);
                    for (var i in r) e[i] = r[i]
                }
                return e
            }
            In.prototype = Object.assign(Object.create(r.prototype), {
                constructor: In,
                isGeometry: !0,
                applyMatrix: function(t) {
                    for (var e = (new Ve).getNormalMatrix(t), n = 0, r = this.vertices.length; n < r; n++) {
                        this.vertices[n].applyMatrix4(t)
                    }
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n];
                        i.normal.applyMatrix3(e).normalize();
                        for (var o = 0, a = i.vertexNormals.length; o < a; o++) i.vertexNormals[o].applyMatrix3(e).normalize()
                    }
                    return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this
                },
                rotateX: function() {
                    var t = new Qe;
                    return function(e) {
                        return t.makeRotationX(e), this.applyMatrix(t), this
                    }
                }(),
                rotateY: function() {
                    var t = new Qe;
                    return function(e) {
                        return t.makeRotationY(e), this.applyMatrix(t), this
                    }
                }(),
                rotateZ: function() {
                    var t = new Qe;
                    return function(e) {
                        return t.makeRotationZ(e), this.applyMatrix(t), this
                    }
                }(),
                translate: function() {
                    var t = new Qe;
                    return function(e, n, r) {
                        return t.makeTranslation(e, n, r), this.applyMatrix(t), this
                    }
                }(),
                scale: function() {
                    var t = new Qe;
                    return function(e, n, r) {
                        return t.makeScale(e, n, r), this.applyMatrix(t), this
                    }
                }(),
                lookAt: function() {
                    var t = new en;
                    return function(e) {
                        t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
                    }
                }(),
                fromBufferGeometry: function(t) {
                    var e = this,
                        n = null !== t.index ? t.index.array : void 0,
                        r = t.attributes,
                        i = r.position.array,
                        o = void 0 !== r.normal ? r.normal.array : void 0,
                        a = void 0 !== r.color ? r.color.array : void 0,
                        s = void 0 !== r.uv ? r.uv.array : void 0,
                        c = void 0 !== r.uv2 ? r.uv2.array : void 0;
                    void 0 !== c && (this.faceVertexUvs[1] = []);
                    for (var u = 0; u < i.length; u += 3) e.vertices.push((new je).fromArray(i, u)), void 0 !== a && e.colors.push((new un).fromArray(a, u));

                    function l(t, n, r, i) {
                        var u = void 0 === a ? [] : [e.colors[t].clone(), e.colors[n].clone(), e.colors[r].clone()],
                            l = new dn(t, n, r, void 0 === o ? [] : [(new je).fromArray(o, 3 * t), (new je).fromArray(o, 3 * n), (new je).fromArray(o, 3 * r)], u, i);
                        e.faces.push(l), void 0 !== s && e.faceVertexUvs[0].push([(new He).fromArray(s, 2 * t), (new He).fromArray(s, 2 * n), (new He).fromArray(s, 2 * r)]), void 0 !== c && e.faceVertexUvs[1].push([(new He).fromArray(c, 2 * t), (new He).fromArray(c, 2 * n), (new He).fromArray(c, 2 * r)])
                    }
                    var h = t.groups;
                    if (h.length > 0)
                        for (u = 0; u < h.length; u++)
                            for (var p = h[u], d = p.start, f = d, m = d + p.count; f < m; f += 3) void 0 !== n ? l(n[f], n[f + 1], n[f + 2], p.materialIndex) : l(f, f + 1, f + 2, p.materialIndex);
                    else if (void 0 !== n)
                        for (u = 0; u < n.length; u += 3) l(n[u], n[u + 1], n[u + 2]);
                    else
                        for (u = 0; u < i.length / 3; u += 3) l(u, u + 1, u + 2);
                    return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
                },
                center: function() {
                    var t = new je;
                    return function() {
                        return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
                    }
                }(),
                normalize: function() {
                    this.computeBoundingSphere();
                    var t = this.boundingSphere.center,
                        e = this.boundingSphere.radius,
                        n = 0 === e ? 1 : 1 / e,
                        r = new Qe;
                    return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix(r), this
                },
                computeFaceNormals: function() {
                    for (var t = new je, e = new je, n = 0, r = this.faces.length; n < r; n++) {
                        var i = this.faces[n],
                            o = this.vertices[i.a],
                            a = this.vertices[i.b],
                            s = this.vertices[i.c];
                        t.subVectors(s, a), e.subVectors(o, a), t.cross(e), t.normalize(), i.normal.copy(t)
                    }
                },
                computeVertexNormals: function(t) {
                    var e, n, r, i, o, a;
                    for (void 0 === t && (t = !0), a = new Array(this.vertices.length), e = 0, n = this.vertices.length; e < n; e++) a[e] = new je;
                    if (t) {
                        var s, c, u, l = new je,
                            h = new je;
                        for (r = 0, i = this.faces.length; r < i; r++) o = this.faces[r], s = this.vertices[o.a], c = this.vertices[o.b], u = this.vertices[o.c], l.subVectors(u, c), h.subVectors(s, c), l.cross(h), a[o.a].add(l), a[o.b].add(l), a[o.c].add(l)
                    } else
                        for (this.computeFaceNormals(), r = 0, i = this.faces.length; r < i; r++) a[(o = this.faces[r]).a].add(o.normal), a[o.b].add(o.normal), a[o.c].add(o.normal);
                    for (e = 0, n = this.vertices.length; e < n; e++) a[e].normalize();
                    for (r = 0, i = this.faces.length; r < i; r++) {
                        var p = (o = this.faces[r]).vertexNormals;
                        3 === p.length ? (p[0].copy(a[o.a]), p[1].copy(a[o.b]), p[2].copy(a[o.c])) : (p[0] = a[o.a].clone(), p[1] = a[o.b].clone(), p[2] = a[o.c].clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeFlatVertexNormals: function() {
                    var t, e, n;
                    for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
                        var r = (n = this.faces[t]).vertexNormals;
                        3 === r.length ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone())
                    }
                    this.faces.length > 0 && (this.normalsNeedUpdate = !0)
                },
                computeMorphNormals: function() {
                    var t, e, n, r, i;
                    for (n = 0, r = this.faces.length; n < r; n++)
                        for ((i = this.faces[n]).__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), t = 0, e = i.vertexNormals.length; t < e; t++) i.__originalVertexNormals[t] ? i.__originalVertexNormals[t].copy(i.vertexNormals[t]) : i.__originalVertexNormals[t] = i.vertexNormals[t].clone();
                    var o = new In;
                    for (o.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
                        if (!this.morphNormals[t]) {
                            this.morphNormals[t] = {}, this.morphNormals[t].faceNormals = [], this.morphNormals[t].vertexNormals = [];
                            var a = this.morphNormals[t].faceNormals,
                                s = this.morphNormals[t].vertexNormals;
                            for (n = 0, r = this.faces.length; n < r; n++) c = new je, u = {
                                a: new je,
                                b: new je,
                                c: new je
                            }, a.push(c), s.push(u)
                        }
                        var c, u, l = this.morphNormals[t];
                        for (o.vertices = this.morphTargets[t].vertices, o.computeFaceNormals(), o.computeVertexNormals(), n = 0, r = this.faces.length; n < r; n++) i = this.faces[n], c = l.faceNormals[n], u = l.vertexNormals[n], c.copy(i.normal), u.a.copy(i.vertexNormals[0]), u.b.copy(i.vertexNormals[1]), u.c.copy(i.vertexNormals[2])
                    }
                    for (n = 0, r = this.faces.length; n < r; n++)(i = this.faces[n]).normal = i.__originalFaceNormal, i.vertexNormals = i.__originalVertexNormals
                },
                computeBoundingBox: function() {
                    null === this.boundingBox && (this.boundingBox = new rn), this.boundingBox.setFromPoints(this.vertices)
                },
                computeBoundingSphere: function() {
                    null === this.boundingSphere && (this.boundingSphere = new on), this.boundingSphere.setFromPoints(this.vertices)
                },
                merge: function(t, e, n) {
                    if (t && t.isGeometry) {
                        var r, i = this.vertices.length,
                            o = this.vertices,
                            a = t.vertices,
                            s = this.faces,
                            c = t.faces,
                            u = this.faceVertexUvs[0],
                            l = t.faceVertexUvs[0],
                            h = this.colors,
                            p = t.colors;
                        void 0 === n && (n = 0), void 0 !== e && (r = (new Ve).getNormalMatrix(e));
                        for (var d = 0, f = a.length; d < f; d++) {
                            var m = a[d].clone();
                            void 0 !== e && m.applyMatrix4(e), o.push(m)
                        }
                        for (d = 0, f = p.length; d < f; d++) h.push(p[d].clone());
                        for (d = 0, f = c.length; d < f; d++) {
                            var v, g, y, x = c[d],
                                b = x.vertexNormals,
                                w = x.vertexColors;
                            (v = new dn(x.a + i, x.b + i, x.c + i)).normal.copy(x.normal), void 0 !== r && v.normal.applyMatrix3(r).normalize();
                            for (var _ = 0, M = b.length; _ < M; _++) g = b[_].clone(), void 0 !== r && g.applyMatrix3(r).normalize(), v.vertexNormals.push(g);
                            for (v.color.copy(x.color), _ = 0, M = w.length; _ < M; _++) y = w[_], v.vertexColors.push(y.clone());
                            v.materialIndex = x.materialIndex + n, s.push(v)
                        }
                        for (d = 0, f = l.length; d < f; d++) {
                            var E = l[d],
                                S = [];
                            if (void 0 !== E) {
                                for (_ = 0, M = E.length; _ < M; _++) S.push(E[_].clone());
                                u.push(S)
                            }
                        }
                    } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
                },
                mergeMesh: function(t) {
                    t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
                },
                mergeVertices: function() {
                    var t, e, n, r, i, o, a, s, c = {},
                        u = [],
                        l = [],
                        h = Math.pow(10, 4);
                    for (n = 0, r = this.vertices.length; n < r; n++) t = this.vertices[n], void 0 === c[e = Math.round(t.x * h) + "_" + Math.round(t.y * h) + "_" + Math.round(t.z * h)] ? (c[e] = n, u.push(this.vertices[n]), l[n] = u.length - 1) : l[n] = l[c[e]];
                    var p = [];
                    for (n = 0, r = this.faces.length; n < r; n++) {
                        (i = this.faces[n]).a = l[i.a], i.b = l[i.b], i.c = l[i.c], o = [i.a, i.b, i.c];
                        for (var d = 0; d < 3; d++)
                            if (o[d] === o[(d + 1) % 3]) {
                                p.push(n);
                                break
                            }
                    }
                    for (n = p.length - 1; n >= 0; n--) {
                        var f = p[n];
                        for (this.faces.splice(f, 1), a = 0, s = this.faceVertexUvs.length; a < s; a++) this.faceVertexUvs[a].splice(f, 1)
                    }
                    var m = this.vertices.length - u.length;
                    return this.vertices = u, m
                },
                setFromPoints: function(t) {
                    this.vertices = [];
                    for (var e = 0, n = t.length; e < n; e++) {
                        var r = t[e];
                        this.vertices.push(new je(r.x, r.y, r.z || 0))
                    }
                    return this
                },
                sortFacesByMaterialIndex: function() {
                    for (var t = this.faces, e = t.length, n = 0; n < e; n++) t[n]._id = n;
                    t.sort(function(t, e) {
                        return t.materialIndex - e.materialIndex
                    });
                    var r, i, o = this.faceVertexUvs[0],
                        a = this.faceVertexUvs[1];
                    for (o && o.length === e && (r = []), a && a.length === e && (i = []), n = 0; n < e; n++) {
                        var s = t[n]._id;
                        r && r.push(o[s]), i && i.push(a[s])
                    }
                    r && (this.faceVertexUvs[0] = r), i && (this.faceVertexUvs[1] = i)
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Geometry",
                            generator: "Geometry.toJSON"
                        }
                    };
                    if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), void 0 !== this.parameters) {
                        var e = this.parameters;
                        for (var n in e) void 0 !== e[n] && (t[n] = e[n]);
                        return t
                    }
                    for (var r = [], i = 0; i < this.vertices.length; i++) {
                        var o = this.vertices[i];
                        r.push(o.x, o.y, o.z)
                    }
                    var a = [],
                        s = [],
                        c = {},
                        u = [],
                        l = {},
                        h = [],
                        p = {};
                    for (i = 0; i < this.faces.length; i++) {
                        var d = this.faces[i],
                            f = void 0 !== this.faceVertexUvs[0][i],
                            m = d.normal.length() > 0,
                            v = d.vertexNormals.length > 0,
                            g = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
                            y = d.vertexColors.length > 0,
                            x = 0;
                        if (x = M(x, 0, 0), x = M(x, 1, !0), x = M(x, 2, !1), x = M(x, 3, f), x = M(x, 4, m), x = M(x, 5, v), x = M(x, 6, g), x = M(x, 7, y), a.push(x), a.push(d.a, d.b, d.c), a.push(d.materialIndex), f) {
                            var b = this.faceVertexUvs[0][i];
                            a.push(T(b[0]), T(b[1]), T(b[2]))
                        }
                        if (m && a.push(E(d.normal)), v) {
                            var w = d.vertexNormals;
                            a.push(E(w[0]), E(w[1]), E(w[2]))
                        }
                        if (g && a.push(S(d.color)), y) {
                            var _ = d.vertexColors;
                            a.push(S(_[0]), S(_[1]), S(_[2]))
                        }
                    }

                    function M(t, e, n) {
                        return n ? t | 1 << e : t & ~(1 << e)
                    }

                    function E(t) {
                        var e = t.x.toString() + t.y.toString() + t.z.toString();
                        return void 0 !== c[e] ? c[e] : (c[e] = s.length / 3, s.push(t.x, t.y, t.z), c[e])
                    }

                    function S(t) {
                        var e = t.r.toString() + t.g.toString() + t.b.toString();
                        return void 0 !== l[e] ? l[e] : (l[e] = u.length, u.push(t.getHex()), l[e])
                    }

                    function T(t) {
                        var e = t.x.toString() + t.y.toString();
                        return void 0 !== p[e] ? p[e] : (p[e] = h.length / 2, h.push(t.x, t.y), p[e])
                    }
                    return t.data = {}, t.data.vertices = r, t.data.normals = s, u.length > 0 && (t.data.colors = u), h.length > 0 && (t.data.uvs = [h]), t.data.faces = a, t
                },
                clone: function() {
                    return (new In).copy(this)
                },
                copy: function(t) {
                    var e, n, r, i, o, a;
                    this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [
                        []
                    ], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name;
                    var s = t.vertices;
                    for (e = 0, n = s.length; e < n; e++) this.vertices.push(s[e].clone());
                    var c = t.colors;
                    for (e = 0, n = c.length; e < n; e++) this.colors.push(c[e].clone());
                    var u = t.faces;
                    for (e = 0, n = u.length; e < n; e++) this.faces.push(u[e].clone());
                    for (e = 0, n = t.faceVertexUvs.length; e < n; e++) {
                        var l = t.faceVertexUvs[e];
                        for (void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []), r = 0, i = l.length; r < i; r++) {
                            var h = l[r],
                                p = [];
                            for (o = 0, a = h.length; o < a; o++) {
                                var d = h[o];
                                p.push(d.clone())
                            }
                            this.faceVertexUvs[e].push(p)
                        }
                    }
                    var f = t.morphTargets;
                    for (e = 0, n = f.length; e < n; e++) {
                        var m = {};
                        if (m.name = f[e].name, void 0 !== f[e].vertices)
                            for (m.vertices = [], r = 0, i = f[e].vertices.length; r < i; r++) m.vertices.push(f[e].vertices[r].clone());
                        if (void 0 !== f[e].normals)
                            for (m.normals = [], r = 0, i = f[e].normals.length; r < i; r++) m.normals.push(f[e].normals[r].clone());
                        this.morphTargets.push(m)
                    }
                    var v = t.morphNormals;
                    for (e = 0, n = v.length; e < n; e++) {
                        var g = {};
                        if (void 0 !== v[e].vertexNormals)
                            for (g.vertexNormals = [], r = 0, i = v[e].vertexNormals.length; r < i; r++) {
                                var y = v[e].vertexNormals[r],
                                    x = {};
                                x.a = y.a.clone(), x.b = y.b.clone(), x.c = y.c.clone(), g.vertexNormals.push(x)
                            }
                        if (void 0 !== v[e].faceNormals)
                            for (g.faceNormals = [], r = 0, i = v[e].faceNormals.length; r < i; r++) g.faceNormals.push(v[e].faceNormals[r].clone());
                        this.morphNormals.push(g)
                    }
                    var b = t.skinWeights;
                    for (e = 0, n = b.length; e < n; e++) this.skinWeights.push(b[e].clone());
                    var w = t.skinIndices;
                    for (e = 0, n = w.length; e < n; e++) this.skinIndices.push(w[e].clone());
                    var _ = t.lineDistances;
                    for (e = 0, n = _.length; e < n; e++) this.lineDistances.push(_[e]);
                    var M = t.boundingBox;
                    null !== M && (this.boundingBox = M.clone());
                    var E = t.boundingSphere;
                    return null !== E && (this.boundingSphere = E.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
                },
                dispose: function() {
                    this.dispatchEvent({
                        type: "dispose"
                    })
                }
            }), Bn.prototype = Object.create(In.prototype), Bn.prototype.constructor = Bn, Dn.prototype = Object.create(Rn.prototype), Dn.prototype.constructor = Dn;
            var Nn = {
                    clone: Fn,
                    merge: kn
                },
                zn = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
                Gn = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

            function Hn(t) {
                mn.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = zn, this.fragmentShader = Gn, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.extensions = {
                    derivatives: !1,
                    fragDepth: !1,
                    drawBuffers: !1,
                    shaderTextureLOD: !1
                }, this.defaultAttributeValues = {
                    color: [1, 1, 1],
                    uv: [0, 0],
                    uv2: [0, 0]
                }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
            }

            function Un() {
                en.call(this), this.type = "Camera", this.matrixWorldInverse = new Qe, this.projectionMatrix = new Qe, this.projectionMatrixInverse = new Qe
            }

            function jn(t, e, n, r) {
                Un.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== n ? n : .1, this.far = void 0 !== r ? r : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
            }
            Hn.prototype = Object.create(mn.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isShaderMaterial = !0, Hn.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Fn(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
            }, Hn.prototype.toJSON = function(t) {
                var e = mn.prototype.toJSON.call(this, t);
                for (var n in e.uniforms = {}, this.uniforms) {
                    var r = this.uniforms[n].value;
                    r && r.isTexture ? e.uniforms[n] = {
                        type: "t",
                        value: r.toJSON(t).uuid
                    } : r && r.isColor ? e.uniforms[n] = {
                        type: "c",
                        value: r.getHex()
                    } : r && r.isVector2 ? e.uniforms[n] = {
                        type: "v2",
                        value: r.toArray()
                    } : r && r.isVector3 ? e.uniforms[n] = {
                        type: "v3",
                        value: r.toArray()
                    } : r && r.isVector4 ? e.uniforms[n] = {
                        type: "v4",
                        value: r.toArray()
                    } : r && r.isMatrix3 ? e.uniforms[n] = {
                        type: "m3",
                        value: r.toArray()
                    } : r && r.isMatrix4 ? e.uniforms[n] = {
                        type: "m4",
                        value: r.toArray()
                    } : e.uniforms[n] = {
                        value: r
                    }
                }
                Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader;
                var i = {};
                for (var o in this.extensions) !0 === this.extensions[o] && (i[o] = !0);
                return Object.keys(i).length > 0 && (e.extensions = i), e
            }, Un.prototype = Object.assign(Object.create(en.prototype), {
                constructor: Un,
                isCamera: !0,
                copy: function(t, e) {
                    return en.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
                },
                getWorldDirection: function(t) {
                    void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new je), this.updateMatrixWorld(!0);
                    var e = this.matrixWorld.elements;
                    return t.set(-e[8], -e[9], -e[10]).normalize()
                },
                updateMatrixWorld: function(t) {
                    en.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), jn.prototype = Object.assign(Object.create(Un.prototype), {
                constructor: jn,
                isPerspectiveCamera: !0,
                copy: function(t, e) {
                    return Un.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
                },
                setFocalLength: function(t) {
                    var e = .5 * this.getFilmHeight() / t;
                    this.fov = 2 * Ge.RAD2DEG * Math.atan(e), this.updateProjectionMatrix()
                },
                getFocalLength: function() {
                    var t = Math.tan(.5 * Ge.DEG2RAD * this.fov);
                    return .5 * this.getFilmHeight() / t
                },
                getEffectiveFOV: function() {
                    return 2 * Ge.RAD2DEG * Math.atan(Math.tan(.5 * Ge.DEG2RAD * this.fov) / this.zoom)
                },
                getFilmWidth: function() {
                    return this.filmGauge * Math.min(this.aspect, 1)
                },
                getFilmHeight: function() {
                    return this.filmGauge / Math.max(this.aspect, 1)
                },
                setViewOffset: function(t, e, n, r, i, o) {
                    this.aspect = t / e, null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = this.near,
                        e = t * Math.tan(.5 * Ge.DEG2RAD * this.fov) / this.zoom,
                        n = 2 * e,
                        r = this.aspect * n,
                        i = -.5 * r,
                        o = this.view;
                    if (null !== this.view && this.view.enabled) {
                        var a = o.fullWidth,
                            s = o.fullHeight;
                        i += o.offsetX * r / a, e -= o.offsetY * n / s, r *= o.width / a, n *= o.height / s
                    }
                    var c = this.filmOffset;
                    0 !== c && (i += t * c / this.getFilmWidth()), this.projectionMatrix.makePerspective(i, i + r, e, e - n, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = en.prototype.toJSON.call(this, t);
                    return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, null !== this.view && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e
                }
            });
            var Vn = 90,
                Wn = 1;

            function qn(t, e, n, r) {
                en.call(this), this.type = "CubeCamera";
                var i = new jn(Vn, Wn, t, e);
                i.up.set(0, -1, 0), i.lookAt(new je(1, 0, 0)), this.add(i);
                var o = new jn(Vn, Wn, t, e);
                o.up.set(0, -1, 0), o.lookAt(new je(-1, 0, 0)), this.add(o);
                var a = new jn(Vn, Wn, t, e);
                a.up.set(0, 0, 1), a.lookAt(new je(0, 1, 0)), this.add(a);
                var s = new jn(Vn, Wn, t, e);
                s.up.set(0, 0, -1), s.lookAt(new je(0, -1, 0)), this.add(s);
                var c = new jn(Vn, Wn, t, e);
                c.up.set(0, -1, 0), c.lookAt(new je(0, 0, 1)), this.add(c);
                var u = new jn(Vn, Wn, t, e);
                u.up.set(0, -1, 0), u.lookAt(new je(0, 0, -1)), this.add(u), r = r || {
                    format: zt,
                    magFilter: Mt,
                    minFilter: Mt
                }, this.renderTarget = new Xn(n, n, r), this.renderTarget.texture.name = "CubeCamera", this.update = function(t, e) {
                    null === this.parent && this.updateMatrixWorld();
                    var n = t.getRenderTarget(),
                        r = this.renderTarget,
                        l = r.texture.generateMipmaps;
                    r.texture.generateMipmaps = !1, t.setRenderTarget(r, 0), t.render(e, i), t.setRenderTarget(r, 1), t.render(e, o), t.setRenderTarget(r, 2), t.render(e, a), t.setRenderTarget(r, 3), t.render(e, s), t.setRenderTarget(r, 4), t.render(e, c), r.texture.generateMipmaps = l, t.setRenderTarget(r, 5), t.render(e, u), t.setRenderTarget(n)
                }, this.clear = function(t, e, n, r) {
                    for (var i = t.getRenderTarget(), o = this.renderTarget, a = 0; a < 6; a++) t.setRenderTarget(o, a), t.clear(e, n, r);
                    t.setRenderTarget(i)
                }
            }

            function Xn(t, e, n) {
                Je.call(this, t, e, n)
            }

            function Yn(t, e, n, r, i, o, a, s, c, u, l, h) {
                Xe.call(this, null, o, a, s, c, u, r, i, l, h), this.image = {
                    data: t,
                    width: e,
                    height: n
                }, this.magFilter = void 0 !== c ? c : bt, this.minFilter = void 0 !== u ? u : bt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
            }

            function Jn(t, e) {
                this.normal = void 0 !== t ? t : new je(1, 0, 0), this.constant = void 0 !== e ? e : 0
            }

            function Zn(t, e, n, r, i, o) {
                this.planes = [void 0 !== t ? t : new Jn, void 0 !== e ? e : new Jn, void 0 !== n ? n : new Jn, void 0 !== r ? r : new Jn, void 0 !== i ? i : new Jn, void 0 !== o ? o : new Jn]
            }
            qn.prototype = Object.create(en.prototype), qn.prototype.constructor = qn, Xn.prototype = Object.create(Je.prototype), Xn.prototype.constructor = Xn, Xn.prototype.isWebGLRenderTargetCube = !0, Xn.prototype.fromEquirectangularTexture = function(t, e) {
                this.texture.type = e.type, this.texture.format = e.format, this.texture.encoding = e.encoding;
                var n = new nn,
                    r = {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
                        fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
                    },
                    i = new Hn({
                        type: "CubemapFromEquirect",
                        uniforms: Fn(r.uniforms),
                        vertexShader: r.vertexShader,
                        fragmentShader: r.fragmentShader,
                        side: g,
                        blending: E
                    });
                i.uniforms.tEquirect.value = e;
                var o = new Pn(new Dn(5, 5, 5), i);
                n.add(o);
                var a = new qn(1, 10, 1);
                return a.renderTarget = this, a.renderTarget.texture.name = "CubeCameraTexture", a.update(t, n), o.geometry.dispose(), o.material.dispose(), this
            }, Yn.prototype = Object.create(Xe.prototype), Yn.prototype.constructor = Yn, Yn.prototype.isDataTexture = !0, Object.assign(Jn.prototype, {
                isPlane: !0,
                set: function(t, e) {
                    return this.normal.copy(t), this.constant = e, this
                },
                setComponents: function(t, e, n, r) {
                    return this.normal.set(t, e, n), this.constant = r, this
                },
                setFromNormalAndCoplanarPoint: function(t, e) {
                    return this.normal.copy(t), this.constant = -e.dot(this.normal), this
                },
                setFromCoplanarPoints: function() {
                    var t = new je,
                        e = new je;
                    return function(n, r, i) {
                        var o = t.subVectors(i, r).cross(e.subVectors(n, r)).normalize();
                        return this.setFromNormalAndCoplanarPoint(o, n), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.normal.copy(t.normal), this.constant = t.constant, this
                },
                normalize: function() {
                    var t = 1 / this.normal.length();
                    return this.normal.multiplyScalar(t), this.constant *= t, this
                },
                negate: function() {
                    return this.constant *= -1, this.normal.negate(), this
                },
                distanceToPoint: function(t) {
                    return this.normal.dot(t) + this.constant
                },
                distanceToSphere: function(t) {
                    return this.distanceToPoint(t.center) - t.radius
                },
                projectPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new je), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
                },
                intersectLine: function() {
                    var t = new je;
                    return function(e, n) {
                        void 0 === n && (console.warn("THREE.Plane: .intersectLine() target is now required"), n = new je);
                        var r = e.delta(t),
                            i = this.normal.dot(r);
                        if (0 === i) return 0 === this.distanceToPoint(e.start) ? n.copy(e.start) : void 0;
                        var o = -(e.start.dot(this.normal) + this.constant) / i;
                        return o < 0 || o > 1 ? void 0 : n.copy(r).multiplyScalar(o).add(e.start)
                    }
                }(),
                intersectsLine: function(t) {
                    var e = this.distanceToPoint(t.start),
                        n = this.distanceToPoint(t.end);
                    return e < 0 && n > 0 || n < 0 && e > 0
                },
                intersectsBox: function(t) {
                    return t.intersectsPlane(this)
                },
                intersectsSphere: function(t) {
                    return t.intersectsPlane(this)
                },
                coplanarPoint: function(t) {
                    return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new je), t.copy(this.normal).multiplyScalar(-this.constant)
                },
                applyMatrix4: function() {
                    var t = new je,
                        e = new Ve;
                    return function(n, r) {
                        var i = r || e.getNormalMatrix(n),
                            o = this.coplanarPoint(t).applyMatrix4(n),
                            a = this.normal.applyMatrix3(i).normalize();
                        return this.constant = -o.dot(a), this
                    }
                }(),
                translate: function(t) {
                    return this.constant -= t.dot(this.normal), this
                },
                equals: function(t) {
                    return t.normal.equals(this.normal) && t.constant === this.constant
                }
            }), Object.assign(Zn.prototype, {
                set: function(t, e, n, r, i, o) {
                    var a = this.planes;
                    return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(i), a[5].copy(o), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++) e[n].copy(t.planes[n]);
                    return this
                },
                setFromMatrix: function(t) {
                    var e = this.planes,
                        n = t.elements,
                        r = n[0],
                        i = n[1],
                        o = n[2],
                        a = n[3],
                        s = n[4],
                        c = n[5],
                        u = n[6],
                        l = n[7],
                        h = n[8],
                        p = n[9],
                        d = n[10],
                        f = n[11],
                        m = n[12],
                        v = n[13],
                        g = n[14],
                        y = n[15];
                    return e[0].setComponents(a - r, l - s, f - h, y - m).normalize(), e[1].setComponents(a + r, l + s, f + h, y + m).normalize(), e[2].setComponents(a + i, l + c, f + p, y + v).normalize(), e[3].setComponents(a - i, l - c, f - p, y - v).normalize(), e[4].setComponents(a - o, l - u, f - d, y - g).normalize(), e[5].setComponents(a + o, l + u, f + d, y + g).normalize(), this
                },
                intersectsObject: function() {
                    var t = new on;
                    return function(e) {
                        var n = e.geometry;
                        return null === n.boundingSphere && n.computeBoundingSphere(), t.copy(n.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSprite: function() {
                    var t = new on;
                    return function(e) {
                        return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
                    }
                }(),
                intersectsSphere: function(t) {
                    for (var e = this.planes, n = t.center, r = -t.radius, i = 0; i < 6; i++) {
                        if (e[i].distanceToPoint(n) < r) return !1
                    }
                    return !0
                },
                intersectsBox: function() {
                    var t = new je;
                    return function(e) {
                        for (var n = this.planes, r = 0; r < 6; r++) {
                            var i = n[r];
                            if (t.x = i.normal.x > 0 ? e.max.x : e.min.x, t.y = i.normal.y > 0 ? e.max.y : e.min.y, t.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(t) < 0) return !1
                        }
                        return !0
                    }
                }(),
                containsPoint: function(t) {
                    for (var e = this.planes, n = 0; n < 6; n++)
                        if (e[n].distanceToPoint(t) < 0) return !1;
                    return !0
                }
            });
            var Qn = {
                    alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
                    alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
                    alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
                    aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
                    aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
                    begin_vertex: "vec3 transformed = vec3( position );",
                    beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
                    bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
                    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
                    clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
                    clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
                    clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
                    clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
                    color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
                    color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
                    color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
                    common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
                    cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
                    defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
                    displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
                    displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
                    emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
                    emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
                    encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
                    encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
                    envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
                    envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
                    envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
                    envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
                    envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
                    fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
                    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
                    fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
                    fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
                    gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
                    lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
                    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
                    lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
                    lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
                    lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
                    lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
                    lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
                    lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
                    lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
                    lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
                    lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
                    logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
                    logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
                    logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
                    logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
                    map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
                    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
                    map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
                    map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
                    metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
                    metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
                    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
                    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
                    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
                    normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif",
                    normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
                    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
                    packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
                    premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
                    project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
                    dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
                    dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
                    roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
                    roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
                    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
                    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
                    shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
                    shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
                    skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
                    skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
                    skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
                    skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
                    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
                    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
                    tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
                    tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
                    uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
                    uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
                    uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
                    uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
                    uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
                    uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
                    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
                    background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
                    cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
                    depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
                    depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
                    distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
                    distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
                    equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
                    equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
                    linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
                    meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
                    meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
                    meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
                    normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
                    points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
                    shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
                    shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
                    sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
                    sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
                },
                Kn = {
                    common: {
                        diffuse: {
                            value: new un(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ve
                        },
                        alphaMap: {
                            value: null
                        }
                    },
                    specularmap: {
                        specularMap: {
                            value: null
                        }
                    },
                    envmap: {
                        envMap: {
                            value: null
                        },
                        flipEnvMap: {
                            value: -1
                        },
                        reflectivity: {
                            value: 1
                        },
                        refractionRatio: {
                            value: .98
                        },
                        maxMipLevel: {
                            value: 0
                        }
                    },
                    aomap: {
                        aoMap: {
                            value: null
                        },
                        aoMapIntensity: {
                            value: 1
                        }
                    },
                    lightmap: {
                        lightMap: {
                            value: null
                        },
                        lightMapIntensity: {
                            value: 1
                        }
                    },
                    emissivemap: {
                        emissiveMap: {
                            value: null
                        }
                    },
                    bumpmap: {
                        bumpMap: {
                            value: null
                        },
                        bumpScale: {
                            value: 1
                        }
                    },
                    normalmap: {
                        normalMap: {
                            value: null
                        },
                        normalScale: {
                            value: new He(1, 1)
                        }
                    },
                    displacementmap: {
                        displacementMap: {
                            value: null
                        },
                        displacementScale: {
                            value: 1
                        },
                        displacementBias: {
                            value: 0
                        }
                    },
                    roughnessmap: {
                        roughnessMap: {
                            value: null
                        }
                    },
                    metalnessmap: {
                        metalnessMap: {
                            value: null
                        }
                    },
                    gradientmap: {
                        gradientMap: {
                            value: null
                        }
                    },
                    fog: {
                        fogDensity: {
                            value: 25e-5
                        },
                        fogNear: {
                            value: 1
                        },
                        fogFar: {
                            value: 2e3
                        },
                        fogColor: {
                            value: new un(16777215)
                        }
                    },
                    lights: {
                        ambientLightColor: {
                            value: []
                        },
                        lightProbe: {
                            value: []
                        },
                        directionalLights: {
                            value: [],
                            properties: {
                                direction: {},
                                color: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        directionalShadowMap: {
                            value: []
                        },
                        directionalShadowMatrix: {
                            value: []
                        },
                        spotLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                direction: {},
                                distance: {},
                                coneCos: {},
                                penumbraCos: {},
                                decay: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {}
                            }
                        },
                        spotShadowMap: {
                            value: []
                        },
                        spotShadowMatrix: {
                            value: []
                        },
                        pointLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                decay: {},
                                distance: {},
                                shadow: {},
                                shadowBias: {},
                                shadowRadius: {},
                                shadowMapSize: {},
                                shadowCameraNear: {},
                                shadowCameraFar: {}
                            }
                        },
                        pointShadowMap: {
                            value: []
                        },
                        pointShadowMatrix: {
                            value: []
                        },
                        hemisphereLights: {
                            value: [],
                            properties: {
                                direction: {},
                                skyColor: {},
                                groundColor: {}
                            }
                        },
                        rectAreaLights: {
                            value: [],
                            properties: {
                                color: {},
                                position: {},
                                width: {},
                                height: {}
                            }
                        }
                    },
                    points: {
                        diffuse: {
                            value: new un(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        size: {
                            value: 1
                        },
                        scale: {
                            value: 1
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ve
                        }
                    },
                    sprite: {
                        diffuse: {
                            value: new un(15658734)
                        },
                        opacity: {
                            value: 1
                        },
                        center: {
                            value: new He(.5, .5)
                        },
                        rotation: {
                            value: 0
                        },
                        map: {
                            value: null
                        },
                        uvTransform: {
                            value: new Ve
                        }
                    }
                },
                $n = {
                    basic: {
                        uniforms: kn([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.fog]),
                        vertexShader: Qn.meshbasic_vert,
                        fragmentShader: Qn.meshbasic_frag
                    },
                    lambert: {
                        uniforms: kn([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.fog, Kn.lights, {
                            emissive: {
                                value: new un(0)
                            }
                        }]),
                        vertexShader: Qn.meshlambert_vert,
                        fragmentShader: Qn.meshlambert_frag
                    },
                    phong: {
                        uniforms: kn([Kn.common, Kn.specularmap, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.gradientmap, Kn.fog, Kn.lights, {
                            emissive: {
                                value: new un(0)
                            },
                            specular: {
                                value: new un(1118481)
                            },
                            shininess: {
                                value: 30
                            }
                        }]),
                        vertexShader: Qn.meshphong_vert,
                        fragmentShader: Qn.meshphong_frag
                    },
                    standard: {
                        uniforms: kn([Kn.common, Kn.envmap, Kn.aomap, Kn.lightmap, Kn.emissivemap, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.roughnessmap, Kn.metalnessmap, Kn.fog, Kn.lights, {
                            emissive: {
                                value: new un(0)
                            },
                            roughness: {
                                value: .5
                            },
                            metalness: {
                                value: .5
                            },
                            envMapIntensity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Qn.meshphysical_vert,
                        fragmentShader: Qn.meshphysical_frag
                    },
                    matcap: {
                        uniforms: kn([Kn.common, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, Kn.fog, {
                            matcap: {
                                value: null
                            }
                        }]),
                        vertexShader: Qn.meshmatcap_vert,
                        fragmentShader: Qn.meshmatcap_frag
                    },
                    points: {
                        uniforms: kn([Kn.points, Kn.fog]),
                        vertexShader: Qn.points_vert,
                        fragmentShader: Qn.points_frag
                    },
                    dashed: {
                        uniforms: kn([Kn.common, Kn.fog, {
                            scale: {
                                value: 1
                            },
                            dashSize: {
                                value: 1
                            },
                            totalSize: {
                                value: 2
                            }
                        }]),
                        vertexShader: Qn.linedashed_vert,
                        fragmentShader: Qn.linedashed_frag
                    },
                    depth: {
                        uniforms: kn([Kn.common, Kn.displacementmap]),
                        vertexShader: Qn.depth_vert,
                        fragmentShader: Qn.depth_frag
                    },
                    normal: {
                        uniforms: kn([Kn.common, Kn.bumpmap, Kn.normalmap, Kn.displacementmap, {
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Qn.normal_vert,
                        fragmentShader: Qn.normal_frag
                    },
                    sprite: {
                        uniforms: kn([Kn.sprite, Kn.fog]),
                        vertexShader: Qn.sprite_vert,
                        fragmentShader: Qn.sprite_frag
                    },
                    background: {
                        uniforms: {
                            uvTransform: {
                                value: new Ve
                            },
                            t2D: {
                                value: null
                            }
                        },
                        vertexShader: Qn.background_vert,
                        fragmentShader: Qn.background_frag
                    },
                    cube: {
                        uniforms: {
                            tCube: {
                                value: null
                            },
                            tFlip: {
                                value: -1
                            },
                            opacity: {
                                value: 1
                            }
                        },
                        vertexShader: Qn.cube_vert,
                        fragmentShader: Qn.cube_frag
                    },
                    equirect: {
                        uniforms: {
                            tEquirect: {
                                value: null
                            }
                        },
                        vertexShader: Qn.equirect_vert,
                        fragmentShader: Qn.equirect_frag
                    },
                    distanceRGBA: {
                        uniforms: kn([Kn.common, Kn.displacementmap, {
                            referencePosition: {
                                value: new je
                            },
                            nearDistance: {
                                value: 1
                            },
                            farDistance: {
                                value: 1e3
                            }
                        }]),
                        vertexShader: Qn.distanceRGBA_vert,
                        fragmentShader: Qn.distanceRGBA_frag
                    },
                    shadow: {
                        uniforms: kn([Kn.lights, Kn.fog, {
                            color: {
                                value: new un(0)
                            },
                            opacity: {
                                value: 1
                            }
                        }]),
                        vertexShader: Qn.shadow_vert,
                        fragmentShader: Qn.shadow_frag
                    }
                };

            function tr() {
                var t = null,
                    e = !1,
                    n = null;

                function r(i, o) {
                    !1 !== e && (n(i, o), t.requestAnimationFrame(r))
                }
                return {
                    start: function() {
                        !0 !== e && null !== n && (t.requestAnimationFrame(r), e = !0)
                    },
                    stop: function() {
                        e = !1
                    },
                    setAnimationLoop: function(t) {
                        n = t
                    },
                    setContext: function(e) {
                        t = e
                    }
                }
            }

            function er(t) {
                var e = new WeakMap;

                function n(e, n) {
                    var r = e.array,
                        i = e.dynamic ? 35048 : 35044,
                        o = t.createBuffer();
                    t.bindBuffer(n, o), t.bufferData(n, r, i), e.onUploadCallback();
                    var a = 5126;
                    return r instanceof Float32Array ? a = 5126 : r instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : r instanceof Uint16Array ? a = 5123 : r instanceof Int16Array ? a = 5122 : r instanceof Uint32Array ? a = 5125 : r instanceof Int32Array ? a = 5124 : r instanceof Int8Array ? a = 5120 : r instanceof Uint8Array && (a = 5121), {
                        buffer: o,
                        type: a,
                        bytesPerElement: r.BYTES_PER_ELEMENT,
                        version: e.version
                    }
                }

                function r(e, n, r) {
                    var i = n.array,
                        o = n.updateRange;
                    t.bindBuffer(r, e), !1 === n.dynamic ? t.bufferData(r, i, 35044) : -1 === o.count ? t.bufferSubData(r, 0, i) : 0 === o.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(r, o.offset * i.BYTES_PER_ELEMENT, i.subarray(o.offset, o.offset + o.count)), o.count = -1)
                }
                return {
                    get: function(t) {
                        return t.isInterleavedBufferAttribute && (t = t.data), e.get(t)
                    },
                    remove: function(n) {
                        n.isInterleavedBufferAttribute && (n = n.data);
                        var r = e.get(n);
                        r && (t.deleteBuffer(r.buffer), e.delete(n))
                    },
                    update: function(t, i) {
                        t.isInterleavedBufferAttribute && (t = t.data);
                        var o = e.get(t);
                        void 0 === o ? e.set(t, n(t, i)) : o.version < t.version && (r(o.buffer, t, i), o.version = t.version)
                    }
                }
            }

            function nr(t, e, n, r) {
                In.call(this), this.type = "PlaneGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r
                }, this.fromBufferGeometry(new rr(t, e, n, r)), this.mergeVertices()
            }

            function rr(t, e, n, r) {
                Rn.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
                    width: t,
                    height: e,
                    widthSegments: n,
                    heightSegments: r
                };
                var i, o, a = (t = t || 1) / 2,
                    s = (e = e || 1) / 2,
                    c = Math.floor(n) || 1,
                    u = Math.floor(r) || 1,
                    l = c + 1,
                    h = u + 1,
                    p = t / c,
                    d = e / u,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (o = 0; o < h; o++) {
                    var y = o * d - s;
                    for (i = 0; i < l; i++) {
                        var x = i * p - a;
                        m.push(x, -y, 0), v.push(0, 0, 1), g.push(i / c), g.push(1 - o / u)
                    }
                }
                for (o = 0; o < u; o++)
                    for (i = 0; i < c; i++) {
                        var b = i + l * o,
                            w = i + l * (o + 1),
                            _ = i + 1 + l * (o + 1),
                            M = i + 1 + l * o;
                        f.push(b, w, M), f.push(w, _, M)
                    }
                this.setIndex(f), this.addAttribute("position", new Sn(m, 3)), this.addAttribute("normal", new Sn(v, 3)), this.addAttribute("uv", new Sn(g, 2))
            }

            function ir(t, e, n, r) {
                var i, o, a = new un(0),
                    s = 0,
                    c = null,
                    u = 0;

                function l(t, n) {
                    e.buffers.color.setClear(t.r, t.g, t.b, n, r)
                }
                return {
                    getClearColor: function() {
                        return a
                    },
                    setClearColor: function(t, e) {
                        a.set(t), l(a, s = void 0 !== e ? e : 1)
                    },
                    getClearAlpha: function() {
                        return s
                    },
                    setClearAlpha: function(t) {
                        l(a, s = t)
                    },
                    render: function(e, r, h, p) {
                        var d = r.background,
                            f = t.vr,
                            m = f.getSession && f.getSession();
                        if (m && "additive" === m.environmentBlendMode && (d = null), null === d ? (l(a, s), c = null, u = 0) : d && d.isColor && (l(d, 1), p = !0, c = null, u = 0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
                            void 0 === o && ((o = new Pn(new Dn(1, 1, 1), new Hn({
                                type: "BackgroundCubeMaterial",
                                uniforms: Fn($n.cube.uniforms),
                                vertexShader: $n.cube.vertexShader,
                                fragmentShader: $n.cube.fragmentShader,
                                side: g,
                                depthTest: !1,
                                depthWrite: !1,
                                fog: !1
                            }))).geometry.removeAttribute("normal"), o.geometry.removeAttribute("uv"), o.onBeforeRender = function(t, e, n) {
                                this.matrixWorld.copyPosition(n.matrixWorld)
                            }, Object.defineProperty(o.material, "map", {
                                get: function() {
                                    return this.uniforms.tCube.value
                                }
                            }), n.update(o));
                            var y = d.isWebGLRenderTargetCube ? d.texture : d;
                            o.material.uniforms.tCube.value = y, o.material.uniforms.tFlip.value = d.isWebGLRenderTargetCube ? 1 : -1, c === d && u === y.version || (o.material.needsUpdate = !0, c = d, u = y.version), e.unshift(o, o.geometry, o.material, 0, 0, null)
                        } else d && d.isTexture && (void 0 === i && ((i = new Pn(new rr(2, 2), new Hn({
                            type: "BackgroundMaterial",
                            uniforms: Fn($n.background.uniforms),
                            vertexShader: $n.background.vertexShader,
                            fragmentShader: $n.background.fragmentShader,
                            side: v,
                            depthTest: !1,
                            depthWrite: !1,
                            fog: !1
                        }))).geometry.removeAttribute("normal"), Object.defineProperty(i.material, "map", {
                            get: function() {
                                return this.uniforms.t2D.value
                            }
                        }), n.update(i)), i.material.uniforms.t2D.value = d, !0 === d.matrixAutoUpdate && d.updateMatrix(), i.material.uniforms.uvTransform.value.copy(d.matrix), c === d && u === d.version || (i.material.needsUpdate = !0, c = d, u = d.version), e.unshift(i, i.geometry, i.material, 0, 0, null))
                    }
                }
            }

            function or(t, e, n, r) {
                var i;
                this.setMode = function(t) {
                    i = t
                }, this.render = function(e, r) {
                    t.drawArrays(i, e, r), n.update(r, i)
                }, this.renderInstances = function(o, a, s) {
                    var c;
                    if (r.isWebGL2) c = t;
                    else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    c[r.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](i, a, s, o.maxInstancedCount), n.update(s, i, o.maxInstancedCount)
                }
            }

            function ar(t, e, n) {
                var r;

                function i(e) {
                    if ("highp" === e) {
                        if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
                        e = "mediump"
                    }
                    return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
                }
                var o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
                    a = void 0 !== n.precision ? n.precision : "highp",
                    s = i(a);
                s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s);
                var c = !0 === n.logarithmicDepthBuffer,
                    u = t.getParameter(34930),
                    l = t.getParameter(35660),
                    h = t.getParameter(3379),
                    p = t.getParameter(34076),
                    d = t.getParameter(34921),
                    f = t.getParameter(36347),
                    m = t.getParameter(36348),
                    v = t.getParameter(36349),
                    g = l > 0,
                    y = o || !!e.get("OES_texture_float");
                return {
                    isWebGL2: o,
                    getMaxAnisotropy: function() {
                        if (void 0 !== r) return r;
                        var n = e.get("EXT_texture_filter_anisotropic");
                        return r = null !== n ? t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
                    },
                    getMaxPrecision: i,
                    precision: a,
                    logarithmicDepthBuffer: c,
                    maxTextures: u,
                    maxVertexTextures: l,
                    maxTextureSize: h,
                    maxCubemapSize: p,
                    maxAttributes: d,
                    maxVertexUniforms: f,
                    maxVaryings: m,
                    maxFragmentUniforms: v,
                    vertexTextures: g,
                    floatFragmentTextures: y,
                    floatVertexTextures: g && y,
                    maxSamples: o ? t.getParameter(36183) : 0
                }
            }

            function sr() {
                var t = this,
                    e = null,
                    n = 0,
                    r = !1,
                    i = !1,
                    o = new Jn,
                    a = new Ve,
                    s = {
                        value: null,
                        needsUpdate: !1
                    };

                function c() {
                    s.value !== e && (s.value = e, s.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0
                }

                function u(e, n, r, i) {
                    var c = null !== e ? e.length : 0,
                        u = null;
                    if (0 !== c) {
                        if (u = s.value, !0 !== i || null === u) {
                            var l = r + 4 * c,
                                h = n.matrixWorldInverse;
                            a.getNormalMatrix(h), (null === u || u.length < l) && (u = new Float32Array(l));
                            for (var p = 0, d = r; p !== c; ++p, d += 4) o.copy(e[p]).applyMatrix4(h, a), o.normal.toArray(u, d), u[d + 3] = o.constant
                        }
                        s.value = u, s.needsUpdate = !0
                    }
                    return t.numPlanes = c, u
                }
                this.uniform = s, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, i, o) {
                    var a = 0 !== t.length || i || 0 !== n || r;
                    return r = i, e = u(t, o, 0), n = t.length, a
                }, this.beginShadows = function() {
                    i = !0, u(null)
                }, this.endShadows = function() {
                    i = !1, c()
                }, this.setState = function(t, o, a, l, h, p) {
                    if (!r || null === t || 0 === t.length || i && !a) i ? u(null) : c();
                    else {
                        var d = i ? 0 : n,
                            f = 4 * d,
                            m = h.clippingState || null;
                        s.value = m, m = u(t, l, f, p);
                        for (var v = 0; v !== f; ++v) m[v] = e[v];
                        h.clippingState = m, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += d
                    }
                }
            }

            function cr(t) {
                var e = {};
                return {
                    get: function(n) {
                        if (void 0 !== e[n]) return e[n];
                        var r;
                        switch (n) {
                            case "WEBGL_depth_texture":
                                r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                                break;
                            case "EXT_texture_filter_anisotropic":
                                r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                                break;
                            case "WEBGL_compressed_texture_s3tc":
                                r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                                break;
                            case "WEBGL_compressed_texture_pvrtc":
                                r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                                break;
                            default:
                                r = t.getExtension(n)
                        }
                        return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), e[n] = r, r
                    }
                }
            }

            function ur(t, e, n) {
                var r = {},
                    i = {};

                function o(t) {
                    var a = t.target,
                        s = r[a.id];
                    for (var c in null !== s.index && e.remove(s.index), s.attributes) e.remove(s.attributes[c]);
                    a.removeEventListener("dispose", o), delete r[a.id];
                    var u = i[s.id];
                    u && (e.remove(u), delete i[s.id]), n.memory.geometries--
                }
                return {
                    get: function(t, e) {
                        var i = r[e.id];
                        return i || (e.addEventListener("dispose", o), e.isBufferGeometry ? i = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new Rn).setFromObject(t)), i = e._bufferGeometry), r[e.id] = i, n.memory.geometries++, i)
                    },
                    update: function(t) {
                        var n = t.index,
                            r = t.attributes;
                        for (var i in null !== n && e.update(n, 34963), r) e.update(r[i], 34962);
                        var o = t.morphAttributes;
                        for (var i in o)
                            for (var a = o[i], s = 0, c = a.length; s < c; s++) e.update(a[s], 34962)
                    },
                    getWireframeAttribute: function(t) {
                        var n = i[t.id];
                        if (n) return n;
                        var r = [],
                            o = t.index,
                            a = t.attributes;
                        if (null !== o)
                            for (var s = o.array, c = 0, u = s.length; c < u; c += 3) {
                                var l = s[c + 0],
                                    h = s[c + 1],
                                    p = s[c + 2];
                                r.push(l, h, h, p, p, l)
                            } else
                                for (c = 0, u = (s = a.position.array).length / 3 - 1; c < u; c += 3) l = c + 0, h = c + 1, p = c + 2, r.push(l, h, h, p, p, l);
                        return n = new(Ln(r) > 65535 ? En : _n)(r, 1), e.update(n, 34963), i[t.id] = n, n
                    }
                }
            }

            function lr(t, e, n, r) {
                var i, o, a;
                this.setMode = function(t) {
                    i = t
                }, this.setIndex = function(t) {
                    o = t.type, a = t.bytesPerElement
                }, this.render = function(e, r) {
                    t.drawElements(i, r, o, e * a), n.update(r, i)
                }, this.renderInstances = function(s, c, u) {
                    if (r.isWebGL2) l = t;
                    else {
                        var l = e.get("ANGLE_instanced_arrays");
                        if (null === l) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.")
                    }
                    l[r.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](i, u, o, c * a, s.maxInstancedCount), n.update(u, i, s.maxInstancedCount)
                }
            }

            function hr(t) {
                var e = {
                    frame: 0,
                    calls: 0,
                    triangles: 0,
                    points: 0,
                    lines: 0
                };
                return {
                    memory: {
                        geometries: 0,
                        textures: 0
                    },
                    render: e,
                    programs: null,
                    autoReset: !0,
                    reset: function() {
                        e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
                    },
                    update: function(t, n, r) {
                        switch (r = r || 1, e.calls++, n) {
                            case 4:
                                e.triangles += r * (t / 3);
                                break;
                            case 5:
                            case 6:
                                e.triangles += r * (t - 2);
                                break;
                            case 1:
                                e.lines += r * (t / 2);
                                break;
                            case 3:
                                e.lines += r * (t - 1);
                                break;
                            case 2:
                                e.lines += r * t;
                                break;
                            case 0:
                                e.points += r * t;
                                break;
                            default:
                                console.error("THREE.WebGLInfo: Unknown draw mode:", n)
                        }
                    }
                }
            }

            function pr(t, e) {
                return Math.abs(e[1]) - Math.abs(t[1])
            }

            function dr(t) {
                var e = {},
                    n = new Float32Array(8);
                return {
                    update: function(r, i, o, a) {
                        var s = r.morphTargetInfluences,
                            c = s.length,
                            u = e[i.id];
                        if (void 0 === u) {
                            u = [];
                            for (var l = 0; l < c; l++) u[l] = [l, 0];
                            e[i.id] = u
                        }
                        var h = o.morphTargets && i.morphAttributes.position,
                            p = o.morphNormals && i.morphAttributes.normal;
                        for (l = 0; l < c; l++) {
                            var d = u[l];
                            0 !== d[1] && (h && i.removeAttribute("morphTarget" + l), p && i.removeAttribute("morphNormal" + l))
                        }
                        for (l = 0; l < c; l++)(d = u[l])[0] = l, d[1] = s[l];
                        for (u.sort(pr), l = 0; l < 8; l++) {
                            if (d = u[l]) {
                                var f = d[0],
                                    m = d[1];
                                if (m) {
                                    h && i.addAttribute("morphTarget" + l, h[f]), p && i.addAttribute("morphNormal" + l, p[f]), n[l] = m;
                                    continue
                                }
                            }
                            n[l] = 0
                        }
                        a.getUniforms().setValue(t, "morphTargetInfluences", n)
                    }
                }
            }

            function fr(t, e) {
                var n = {};
                return {
                    update: function(r) {
                        var i = e.render.frame,
                            o = r.geometry,
                            a = t.get(r, o);
                        return n[a.id] !== i && (o.isGeometry && a.updateFromObject(r), t.update(a), n[a.id] = i), a
                    },
                    dispose: function() {
                        n = {}
                    }
                }
            }

            function mr(t, e, n, r, i, o, a, s, c, u) {
                t = void 0 !== t ? t : [], e = void 0 !== e ? e : lt, a = void 0 !== a ? a : zt, Xe.call(this, t, e, n, r, i, o, a, s, c, u), this.flipY = !1
            }

            function vr(t, e, n, r) {
                Xe.call(this, null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: r
                }, this.magFilter = bt, this.minFilter = bt, this.wrapR = yt, this.generateMipmaps = !1, this.flipY = !1
            }

            function gr(t, e, n, r) {
                Xe.call(this, null), this.image = {
                    data: t,
                    width: e,
                    height: n,
                    depth: r
                }, this.magFilter = bt, this.minFilter = bt, this.wrapR = yt, this.generateMipmaps = !1, this.flipY = !1
            }
            $n.physical = {
                uniforms: kn([$n.standard.uniforms, {
                    clearCoat: {
                        value: 0
                    },
                    clearCoatRoughness: {
                        value: 0
                    }
                }]),
                vertexShader: Qn.meshphysical_vert,
                fragmentShader: Qn.meshphysical_frag
            }, nr.prototype = Object.create(In.prototype), nr.prototype.constructor = nr, rr.prototype = Object.create(Rn.prototype), rr.prototype.constructor = rr, mr.prototype = Object.create(Xe.prototype), mr.prototype.constructor = mr, mr.prototype.isCubeTexture = !0, Object.defineProperty(mr.prototype, "images", {
                get: function() {
                    return this.image
                },
                set: function(t) {
                    this.image = t
                }
            }), vr.prototype = Object.create(Xe.prototype), vr.prototype.constructor = vr, vr.prototype.isDataTexture2DArray = !0, gr.prototype = Object.create(Xe.prototype), gr.prototype.constructor = gr, gr.prototype.isDataTexture3D = !0;
            var yr = new Xe,
                xr = new vr,
                br = new gr,
                wr = new mr,
                _r = [],
                Mr = [],
                Er = new Float32Array(16),
                Sr = new Float32Array(9),
                Tr = new Float32Array(4);

            function Ar(t, e, n) {
                var r = t[0];
                if (r <= 0 || r > 0) return t;
                var i = e * n,
                    o = _r[i];
                if (void 0 === o && (o = new Float32Array(i), _r[i] = o), 0 !== e) {
                    r.toArray(o, 0);
                    for (var a = 1, s = 0; a !== e; ++a) s += n, t[a].toArray(o, s)
                }
                return o
            }

            function Lr(t, e) {
                if (t.length !== e.length) return !1;
                for (var n = 0, r = t.length; n < r; n++)
                    if (t[n] !== e[n]) return !1;
                return !0
            }

            function Cr(t, e) {
                for (var n = 0, r = e.length; n < r; n++) t[n] = e[n]
            }

            function Rr(t, e) {
                var n = Mr[e];
                void 0 === n && (n = new Int32Array(e), Mr[e] = n);
                for (var r = 0; r !== e; ++r) n[r] = t.allocateTextureUnit();
                return n
            }

            function Pr(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
            }

            function Or(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
                else {
                    if (Lr(n, e)) return;
                    t.uniform2fv(this.addr, e), Cr(n, e)
                }
            }

            function Ir(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
                else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
                else {
                    if (Lr(n, e)) return;
                    t.uniform3fv(this.addr, e), Cr(n, e)
                }
            }

            function Br(t, e) {
                var n = this.cache;
                if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
                else {
                    if (Lr(n, e)) return;
                    t.uniform4fv(this.addr, e), Cr(n, e)
                }
            }

            function Dr(t, e) {
                var n = this.cache,
                    r = e.elements;
                if (void 0 === r) {
                    if (Lr(n, e)) return;
                    t.uniformMatrix2fv(this.addr, !1, e), Cr(n, e)
                } else {
                    if (Lr(n, r)) return;
                    Tr.set(r), t.uniformMatrix2fv(this.addr, !1, Tr), Cr(n, r)
                }
            }

            function Fr(t, e) {
                var n = this.cache,
                    r = e.elements;
                if (void 0 === r) {
                    if (Lr(n, e)) return;
                    t.uniformMatrix3fv(this.addr, !1, e), Cr(n, e)
                } else {
                    if (Lr(n, r)) return;
                    Sr.set(r), t.uniformMatrix3fv(this.addr, !1, Sr), Cr(n, r)
                }
            }

            function kr(t, e) {
                var n = this.cache,
                    r = e.elements;
                if (void 0 === r) {
                    if (Lr(n, e)) return;
                    t.uniformMatrix4fv(this.addr, !1, e), Cr(n, e)
                } else {
                    if (Lr(n, r)) return;
                    Er.set(r), t.uniformMatrix4fv(this.addr, !1, Er), Cr(n, r)
                }
            }

            function Nr(t, e, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTexture2D(e || yr, i)
            }

            function zr(t, e, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture2DArray(e || xr, i)
            }

            function Gr(t, e, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.setTexture3D(e || br, i)
            }

            function Hr(t, e, n) {
                var r = this.cache,
                    i = n.allocateTextureUnit();
                r[0] !== i && (t.uniform1i(this.addr, i), r[0] = i), n.safeSetTextureCube(e || wr, i)
            }

            function Ur(t, e) {
                var n = this.cache;
                n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
            }

            function jr(t, e) {
                var n = this.cache;
                Lr(n, e) || (t.uniform2iv(this.addr, e), Cr(n, e))
            }

            function Vr(t, e) {
                var n = this.cache;
                Lr(n, e) || (t.uniform3iv(this.addr, e), Cr(n, e))
            }

            function Wr(t, e) {
                var n = this.cache;
                Lr(n, e) || (t.uniform4iv(this.addr, e), Cr(n, e))
            }

            function qr(t, e) {
                t.uniform1fv(this.addr, e)
            }

            function Xr(t, e) {
                t.uniform1iv(this.addr, e)
            }

            function Yr(t, e) {
                t.uniform2iv(this.addr, e)
            }

            function Jr(t, e) {
                t.uniform3iv(this.addr, e)
            }

            function Zr(t, e) {
                t.uniform4iv(this.addr, e)
            }

            function Qr(t, e) {
                var n = Ar(e, this.size, 2);
                t.uniform2fv(this.addr, n)
            }

            function Kr(t, e) {
                var n = Ar(e, this.size, 3);
                t.uniform3fv(this.addr, n)
            }

            function $r(t, e) {
                var n = Ar(e, this.size, 4);
                t.uniform4fv(this.addr, n)
            }

            function ti(t, e) {
                var n = Ar(e, this.size, 4);
                t.uniformMatrix2fv(this.addr, !1, n)
            }

            function ei(t, e) {
                var n = Ar(e, this.size, 9);
                t.uniformMatrix3fv(this.addr, !1, n)
            }

            function ni(t, e) {
                var n = Ar(e, this.size, 16);
                t.uniformMatrix4fv(this.addr, !1, n)
            }

            function ri(t, e, n) {
                var r = e.length,
                    i = Rr(n, r);
                t.uniform1iv(this.addr, i);
                for (var o = 0; o !== r; ++o) n.safeSetTexture2D(e[o] || yr, i[o])
            }

            function ii(t, e, n) {
                var r = e.length,
                    i = Rr(n, r);
                t.uniform1iv(this.addr, i);
                for (var o = 0; o !== r; ++o) n.safeSetTextureCube(e[o] || wr, i[o])
            }

            function oi(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return Pr;
                        case 35664:
                            return Or;
                        case 35665:
                            return Ir;
                        case 35666:
                            return Br;
                        case 35674:
                            return Dr;
                        case 35675:
                            return Fr;
                        case 35676:
                            return kr;
                        case 35678:
                        case 36198:
                            return Nr;
                        case 35679:
                            return Gr;
                        case 35680:
                            return Hr;
                        case 36289:
                            return zr;
                        case 5124:
                        case 35670:
                            return Ur;
                        case 35667:
                        case 35671:
                            return jr;
                        case 35668:
                        case 35672:
                            return Vr;
                        case 35669:
                        case 35673:
                            return Wr
                    }
                }(e.type)
            }

            function ai(t, e, n) {
                this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
                    switch (t) {
                        case 5126:
                            return qr;
                        case 35664:
                            return Qr;
                        case 35665:
                            return Kr;
                        case 35666:
                            return $r;
                        case 35674:
                            return ti;
                        case 35675:
                            return ei;
                        case 35676:
                            return ni;
                        case 35678:
                            return ri;
                        case 35680:
                            return ii;
                        case 5124:
                        case 35670:
                            return Xr;
                        case 35667:
                        case 35671:
                            return Yr;
                        case 35668:
                        case 35672:
                            return Jr;
                        case 35669:
                        case 35673:
                            return Zr
                    }
                }(e.type)
            }

            function si(t) {
                this.id = t, this.seq = [], this.map = {}
            }
            ai.prototype.updateCache = function(t) {
                var e = this.cache;
                t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), Cr(e, t)
            }, si.prototype.setValue = function(t, e, n) {
                for (var r = this.seq, i = 0, o = r.length; i !== o; ++i) {
                    var a = r[i];
                    a.setValue(t, e[a.id], n)
                }
            };
            var ci = /([\w\d_]+)(\])?(\[|\.)?/g;

            function ui(t, e) {
                t.seq.push(e), t.map[e.id] = e
            }

            function li(t, e, n) {
                var r = t.name,
                    i = r.length;
                for (ci.lastIndex = 0;;) {
                    var o = ci.exec(r),
                        a = ci.lastIndex,
                        s = o[1],
                        c = "]" === o[2],
                        u = o[3];
                    if (c && (s |= 0), void 0 === u || "[" === u && a + 2 === i) {
                        ui(n, void 0 === u ? new oi(s, t, e) : new ai(s, t, e));
                        break
                    }
                    var l = n.map[s];
                    void 0 === l && ui(n, l = new si(s)), n = l
                }
            }

            function hi(t, e) {
                this.seq = [], this.map = {};
                for (var n = t.getProgramParameter(e, 35718), r = 0; r < n; ++r) {
                    var i = t.getActiveUniform(e, r);
                    li(i, t.getUniformLocation(e, i.name), this)
                }
            }

            function pi(t, e, n) {
                var r = t.createShader(e);
                return t.shaderSource(r, n), t.compileShader(r), r
            }
            hi.prototype.setValue = function(t, e, n, r) {
                var i = this.map[e];
                void 0 !== i && i.setValue(t, n, r)
            }, hi.prototype.setOptional = function(t, e, n) {
                var r = e[n];
                void 0 !== r && this.setValue(t, n, r)
            }, hi.upload = function(t, e, n, r) {
                for (var i = 0, o = e.length; i !== o; ++i) {
                    var a = e[i],
                        s = n[a.id];
                    !1 !== s.needsUpdate && a.setValue(t, s.value, r)
                }
            }, hi.seqWithValue = function(t, e) {
                for (var n = [], r = 0, i = t.length; r !== i; ++r) {
                    var o = t[r];
                    o.id in e && n.push(o)
                }
                return n
            };
            var di = 0;

            function fi(t) {
                switch (t) {
                    case Le:
                        return ["Linear", "( value )"];
                    case Ce:
                        return ["sRGB", "( value )"];
                    case Pe:
                        return ["RGBE", "( value )"];
                    case Ie:
                        return ["RGBM", "( value, 7.0 )"];
                    case Be:
                        return ["RGBM", "( value, 16.0 )"];
                    case De:
                        return ["RGBD", "( value, 256.0 )"];
                    case Re:
                        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
                    default:
                        throw new Error("unsupported encoding: " + t)
                }
            }

            function mi(t, e, n) {
                var r = t.getShaderParameter(e, 35713),
                    i = t.getShaderInfoLog(e).trim();
                return r && "" === i ? "" : "THREE.WebGLShader: gl.getShaderInfoLog() " + n + "\n" + i + function(t) {
                    for (var e = t.split("\n"), n = 0; n < e.length; n++) e[n] = n + 1 + ": " + e[n];
                    return e.join("\n")
                }(t.getShaderSource(e))
            }

            function vi(t, e) {
                var n = fi(e);
                return "vec4 " + t + "( vec4 value ) { return " + n[0] + "ToLinear" + n[1] + "; }"
            }

            function gi(t, e) {
                var n = fi(e);
                return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
            }

            function yi(t, e) {
                var n;
                switch (e) {
                    case it:
                        n = "Linear";
                        break;
                    case ot:
                        n = "Reinhard";
                        break;
                    case at:
                        n = "Uncharted2";
                        break;
                    case st:
                        n = "OptimizedCineon";
                        break;
                    case ct:
                        n = "ACESFilmic";
                        break;
                    default:
                        throw new Error("unsupported toneMapping: " + e)
                }
                return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
            }

            function xi(t) {
                return "" !== t
            }

            function bi(t, e) {
                return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
            }

            function wi(t, e) {
                return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
            }

            function _i(t) {
                return t.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function(t, e) {
                    var n = Qn[e];
                    if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
                    return _i(n)
                })
            }

            function Mi(t) {
                return t.replace(/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function(t, e, n, r) {
                    for (var i = "", o = parseInt(e); o < parseInt(n); o++) i += r.replace(/\[ i \]/g, "[ " + o + " ]");
                    return i
                })
            }

            function Ei(t, e, n, r, i, o, a) {
                var s = t.context,
                    c = r.defines,
                    u = i.vertexShader,
                    l = i.fragmentShader,
                    h = "SHADOWMAP_TYPE_BASIC";
                o.shadowMapType === f ? h = "SHADOWMAP_TYPE_PCF" : o.shadowMapType === m && (h = "SHADOWMAP_TYPE_PCF_SOFT");
                var p = "ENVMAP_TYPE_CUBE",
                    d = "ENVMAP_MODE_REFLECTION",
                    v = "ENVMAP_BLENDING_MULTIPLY";
                if (o.envMap) {
                    switch (r.envMap.mapping) {
                        case lt:
                        case ht:
                            p = "ENVMAP_TYPE_CUBE";
                            break;
                        case mt:
                        case vt:
                            p = "ENVMAP_TYPE_CUBE_UV";
                            break;
                        case pt:
                        case dt:
                            p = "ENVMAP_TYPE_EQUIREC";
                            break;
                        case ft:
                            p = "ENVMAP_TYPE_SPHERE"
                    }
                    switch (r.envMap.mapping) {
                        case ht:
                        case dt:
                            d = "ENVMAP_MODE_REFRACTION"
                    }
                    switch (r.combine) {
                        case tt:
                            v = "ENVMAP_BLENDING_MULTIPLY";
                            break;
                        case et:
                            v = "ENVMAP_BLENDING_MIX";
                            break;
                        case nt:
                            v = "ENVMAP_BLENDING_ADD"
                    }
                }
                var g, y, x = t.gammaFactor > 0 ? t.gammaFactor : 1,
                    b = a.isWebGL2 ? "" : function(t, e, n) {
                        return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(xi).join("\n")
                    }(r.extensions, o, e),
                    w = function(t) {
                        var e = [];
                        for (var n in t) {
                            var r = t[n];
                            !1 !== r && e.push("#define " + n + " " + r)
                        }
                        return e.join("\n")
                    }(c),
                    _ = s.createProgram();
                if (r.isRawShaderMaterial ? ((g = [w].filter(xi).join("\n")).length > 0 && (g += "\n"), (y = [b, w].filter(xi).join("\n")).length > 0 && (y += "\n")) : (g = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + x, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + d : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + h : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(xi).join("\n"), y = [b, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + i.name, w, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + x, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + d : "", o.envMap ? "#define " + v : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + h : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", o.toneMapping !== rt ? "#define TONE_MAPPING" : "", o.toneMapping !== rt ? Qn.tonemapping_pars_fragment : "", o.toneMapping !== rt ? yi("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? Qn.encodings_pars_fragment : "", o.mapEncoding ? vi("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? vi("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? vi("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? vi("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? gi("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + r.depthPacking : "", "\n"].filter(xi).join("\n")), u = wi(u = bi(u = _i(u), o), o), l = wi(l = bi(l = _i(l), o), o), u = Mi(u), l = Mi(l), a.isWebGL2 && !r.isRawShaderMaterial) {
                    var M = !1,
                        E = /^\s*#version\s+300\s+es\s*\n/;
                    r.isShaderMaterial && null !== u.match(E) && null !== l.match(E) && (M = !0, u = u.replace(E, ""), l = l.replace(E, "")), g = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + g, y = ["#version 300 es\n", "#define varying in", M ? "" : "out highp vec4 pc_fragColor;", M ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + y
                }
                var S, T, A = y + l,
                    L = pi(s, 35633, g + u),
                    C = pi(s, 35632, A);
                if (s.attachShader(_, L), s.attachShader(_, C), void 0 !== r.index0AttributeName ? s.bindAttribLocation(_, 0, r.index0AttributeName) : !0 === o.morphTargets && s.bindAttribLocation(_, 0, "position"), s.linkProgram(_), t.debug.checkShaderErrors) {
                    var R = s.getProgramInfoLog(_).trim(),
                        P = s.getShaderInfoLog(L).trim(),
                        O = s.getShaderInfoLog(C).trim(),
                        I = !0,
                        B = !0;
                    if (!1 === s.getProgramParameter(_, 35714)) {
                        I = !1;
                        var D = mi(s, L, "vertex"),
                            F = mi(s, C, "fragment");
                        console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(_, 35715), "gl.getProgramInfoLog", R, D, F)
                    } else "" !== R ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", R) : "" !== P && "" !== O || (B = !1);
                    B && (this.diagnostics = {
                        runnable: I,
                        material: r,
                        programLog: R,
                        vertexShader: {
                            log: P,
                            prefix: g
                        },
                        fragmentShader: {
                            log: O,
                            prefix: y
                        }
                    })
                }
                return s.deleteShader(L), s.deleteShader(C), this.getUniforms = function() {
                    return void 0 === S && (S = new hi(s, _)), S
                }, this.getAttributes = function() {
                    return void 0 === T && (T = function(t, e) {
                        for (var n = {}, r = t.getProgramParameter(e, 35721), i = 0; i < r; i++) {
                            var o = t.getActiveAttrib(e, i).name;
                            n[o] = t.getAttribLocation(e, o)
                        }
                        return n
                    }(s, _)), T
                }, this.destroy = function() {
                    s.deleteProgram(_), this.program = void 0
                }, this.name = i.name, this.id = di++, this.code = n, this.usedTimes = 1, this.program = _, this.vertexShader = L, this.fragmentShader = C, this
            }

            function Si(t, e, n) {
                var r = [],
                    i = {
                        MeshDepthMaterial: "depth",
                        MeshDistanceMaterial: "distanceRGBA",
                        MeshNormalMaterial: "normal",
                        MeshBasicMaterial: "basic",
                        MeshLambertMaterial: "lambert",
                        MeshPhongMaterial: "phong",
                        MeshToonMaterial: "phong",
                        MeshStandardMaterial: "physical",
                        MeshPhysicalMaterial: "physical",
                        MeshMatcapMaterial: "matcap",
                        LineBasicMaterial: "basic",
                        LineDashedMaterial: "dashed",
                        PointsMaterial: "points",
                        ShadowMaterial: "shadow",
                        SpriteMaterial: "sprite"
                    },
                    o = ["precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "fog", "useFog", "fogExp", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"];

                function a(t, e) {
                    var n;
                    return t ? t.isTexture ? n = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), n = t.texture.encoding) : n = Le, n === Le && e && (n = Re), n
                }
                this.getParameters = function(e, r, o, s, c, u, l) {
                    var h = i[e.type],
                        p = l.isSkinnedMesh ? function(t) {
                            var e = t.skeleton.bones;
                            if (n.floatVertexTextures) return 1024;
                            var r = n.maxVertexUniforms,
                                i = Math.floor((r - 20) / 4),
                                o = Math.min(i, e.length);
                            return o < e.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + e.length + " bones. This GPU supports " + o + "."), 0) : o
                        }(l) : 0,
                        d = n.precision;
                    null !== e.precision && ((d = n.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d, "instead."));
                    var f = t.getRenderTarget();
                    return {
                        shaderID: h,
                        precision: d,
                        supportsVertexTextures: n.vertexTextures,
                        outputEncoding: a(f ? f.texture : null, t.gammaOutput),
                        map: !!e.map,
                        mapEncoding: a(e.map, t.gammaInput),
                        matcap: !!e.matcap,
                        matcapEncoding: a(e.matcap, t.gammaInput),
                        envMap: !!e.envMap,
                        envMapMode: e.envMap && e.envMap.mapping,
                        envMapEncoding: a(e.envMap, t.gammaInput),
                        envMapCubeUV: !!e.envMap && (e.envMap.mapping === mt || e.envMap.mapping === vt),
                        lightMap: !!e.lightMap,
                        aoMap: !!e.aoMap,
                        emissiveMap: !!e.emissiveMap,
                        emissiveMapEncoding: a(e.emissiveMap, t.gammaInput),
                        bumpMap: !!e.bumpMap,
                        normalMap: !!e.normalMap,
                        objectSpaceNormalMap: e.normalMapType === ze,
                        displacementMap: !!e.displacementMap,
                        roughnessMap: !!e.roughnessMap,
                        metalnessMap: !!e.metalnessMap,
                        specularMap: !!e.specularMap,
                        alphaMap: !!e.alphaMap,
                        gradientMap: !!e.gradientMap,
                        combine: e.combine,
                        vertexTangents: e.normalMap && e.vertexTangents,
                        vertexColors: e.vertexColors,
                        fog: !!s,
                        useFog: e.fog,
                        fogExp: s && s.isFogExp2,
                        flatShading: e.flatShading,
                        sizeAttenuation: e.sizeAttenuation,
                        logarithmicDepthBuffer: n.logarithmicDepthBuffer,
                        skinning: e.skinning && p > 0,
                        maxBones: p,
                        useVertexTexture: n.floatVertexTextures,
                        morphTargets: e.morphTargets,
                        morphNormals: e.morphNormals,
                        maxMorphTargets: t.maxMorphTargets,
                        maxMorphNormals: t.maxMorphNormals,
                        numDirLights: r.directional.length,
                        numPointLights: r.point.length,
                        numSpotLights: r.spot.length,
                        numRectAreaLights: r.rectArea.length,
                        numHemiLights: r.hemi.length,
                        numClippingPlanes: c,
                        numClipIntersection: u,
                        dithering: e.dithering,
                        shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && o.length > 0,
                        shadowMapType: t.shadowMap.type,
                        toneMapping: t.toneMapping,
                        physicallyCorrectLights: t.physicallyCorrectLights,
                        premultipliedAlpha: e.premultipliedAlpha,
                        alphaTest: e.alphaTest,
                        doubleSided: e.side === y,
                        flipSided: e.side === g,
                        depthPacking: void 0 !== e.depthPacking && e.depthPacking
                    }
                }, this.getProgramCode = function(e, n) {
                    var r = [];
                    if (n.shaderID ? r.push(n.shaderID) : (r.push(e.fragmentShader), r.push(e.vertexShader)), void 0 !== e.defines)
                        for (var i in e.defines) r.push(i), r.push(e.defines[i]);
                    for (var a = 0; a < o.length; a++) r.push(n[o[a]]);
                    return r.push(e.onBeforeCompile.toString()), r.push(t.gammaOutput), r.push(t.gammaFactor), r.join()
                }, this.acquireProgram = function(i, o, a, s) {
                    for (var c, u = 0, l = r.length; u < l; u++) {
                        var h = r[u];
                        if (h.code === s) {
                            ++(c = h).usedTimes;
                            break
                        }
                    }
                    return void 0 === c && (c = new Ei(t, e, s, i, o, a, n), r.push(c)), c
                }, this.releaseProgram = function(t) {
                    if (0 == --t.usedTimes) {
                        var e = r.indexOf(t);
                        r[e] = r[r.length - 1], r.pop(), t.destroy()
                    }
                }, this.programs = r
            }

            function Ti() {
                var t = new WeakMap;
                return {
                    get: function(e) {
                        var n = t.get(e);
                        return void 0 === n && (n = {}, t.set(e, n)), n
                    },
                    remove: function(e) {
                        t.delete(e)
                    },
                    update: function(e, n, r) {
                        t.get(e)[n] = r
                    },
                    dispose: function() {
                        t = new WeakMap
                    }
                }
            }

            function Ai(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
            }

            function Li(t, e) {
                return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
            }

            function Ci() {
                var t = [],
                    e = 0,
                    n = [],
                    r = [],
                    i = {
                        id: -1
                    };

                function o(n, r, o, a, s, c) {
                    var u = t[e];
                    return void 0 === u ? (u = {
                        id: n.id,
                        object: n,
                        geometry: r,
                        material: o,
                        program: o.program || i,
                        groupOrder: a,
                        renderOrder: n.renderOrder,
                        z: s,
                        group: c
                    }, t[e] = u) : (u.id = n.id, u.object = n, u.geometry = r, u.material = o, u.program = o.program || i, u.groupOrder = a, u.renderOrder = n.renderOrder, u.z = s, u.group = c), e++, u
                }
                return {
                    opaque: n,
                    transparent: r,
                    init: function() {
                        e = 0, n.length = 0, r.length = 0
                    },
                    push: function(t, e, i, a, s, c) {
                        var u = o(t, e, i, a, s, c);
                        (!0 === i.transparent ? r : n).push(u)
                    },
                    unshift: function(t, e, i, a, s, c) {
                        var u = o(t, e, i, a, s, c);
                        (!0 === i.transparent ? r : n).unshift(u)
                    },
                    sort: function() {
                        n.length > 1 && n.sort(Ai), r.length > 1 && r.sort(Li)
                    }
                }
            }

            function Ri() {
                var t = {};

                function e(n) {
                    var r = n.target;
                    r.removeEventListener("dispose", e), delete t[r.id]
                }
                return {
                    get: function(n, r) {
                        var i, o = t[n.id];
                        return void 0 === o ? (i = new Ci, t[n.id] = {}, t[n.id][r.id] = i, n.addEventListener("dispose", e)) : void 0 === (i = o[r.id]) && (i = new Ci, o[r.id] = i), i
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }

            function Pi() {
                var t = {};
                return {
                    get: function(e) {
                        if (void 0 !== t[e.id]) return t[e.id];
                        var n;
                        switch (e.type) {
                            case "DirectionalLight":
                                n = {
                                    direction: new je,
                                    color: new un,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new He
                                };
                                break;
                            case "SpotLight":
                                n = {
                                    position: new je,
                                    direction: new je,
                                    color: new un,
                                    distance: 0,
                                    coneCos: 0,
                                    penumbraCos: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new He
                                };
                                break;
                            case "PointLight":
                                n = {
                                    position: new je,
                                    color: new un,
                                    distance: 0,
                                    decay: 0,
                                    shadow: !1,
                                    shadowBias: 0,
                                    shadowRadius: 1,
                                    shadowMapSize: new He,
                                    shadowCameraNear: 1,
                                    shadowCameraFar: 1e3
                                };
                                break;
                            case "HemisphereLight":
                                n = {
                                    direction: new je,
                                    skyColor: new un,
                                    groundColor: new un
                                };
                                break;
                            case "RectAreaLight":
                                n = {
                                    color: new un,
                                    position: new je,
                                    halfWidth: new je,
                                    halfHeight: new je
                                }
                        }
                        return t[e.id] = n, n
                    }
                }
            }
            var Oi = 0;

            function Ii() {
                for (var t = new Pi, e = {
                        version: 0,
                        hash: {
                            directionalLength: -1,
                            pointLength: -1,
                            spotLength: -1,
                            rectAreaLength: -1,
                            hemiLength: -1,
                            shadowsLength: -1
                        },
                        ambient: [0, 0, 0],
                        probe: [],
                        directional: [],
                        directionalShadowMap: [],
                        directionalShadowMatrix: [],
                        spot: [],
                        spotShadowMap: [],
                        spotShadowMatrix: [],
                        rectArea: [],
                        point: [],
                        pointShadowMap: [],
                        pointShadowMatrix: [],
                        hemi: []
                    }, n = 0; n < 9; n++) e.probe.push(new je);
                var r = new je,
                    i = new Qe,
                    o = new Qe;
                return {
                    setup: function(n, a, s) {
                        for (var c = 0, u = 0, l = 0, h = 0; h < 9; h++) e.probe[h].set(0, 0, 0);
                        for (var p = 0, d = 0, f = 0, m = 0, v = 0, g = s.matrixWorldInverse, y = (h = 0, n.length); h < y; h++) {
                            var x = n[h],
                                b = x.color,
                                w = x.intensity,
                                _ = x.distance,
                                M = x.shadow && x.shadow.map ? x.shadow.map.texture : null;
                            if (x.isAmbientLight) c += b.r * w, u += b.g * w, l += b.b * w;
                            else if (x.isLightProbe)
                                for (var E = 0; E < 9; E++) e.probe[E].addScaledVector(x.sh.coefficients[E], w);
                            else if (x.isDirectionalLight) {
                                var S = t.get(x);
                                if (S.color.copy(x.color).multiplyScalar(x.intensity), S.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), S.direction.sub(r), S.direction.transformDirection(g), S.shadow = x.castShadow, x.castShadow) {
                                    var T = x.shadow;
                                    S.shadowBias = T.bias, S.shadowRadius = T.radius, S.shadowMapSize = T.mapSize
                                }
                                e.directionalShadowMap[p] = M, e.directionalShadowMatrix[p] = x.shadow.matrix, e.directional[p] = S, p++
                            } else x.isSpotLight ? ((S = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(g), S.color.copy(b).multiplyScalar(w), S.distance = _, S.direction.setFromMatrixPosition(x.matrixWorld), r.setFromMatrixPosition(x.target.matrixWorld), S.direction.sub(r), S.direction.transformDirection(g), S.coneCos = Math.cos(x.angle), S.penumbraCos = Math.cos(x.angle * (1 - x.penumbra)), S.decay = x.decay, S.shadow = x.castShadow, x.castShadow && (T = x.shadow, S.shadowBias = T.bias, S.shadowRadius = T.radius, S.shadowMapSize = T.mapSize), e.spotShadowMap[f] = M, e.spotShadowMatrix[f] = x.shadow.matrix, e.spot[f] = S, f++) : x.isRectAreaLight ? ((S = t.get(x)).color.copy(b).multiplyScalar(w), S.position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(g), o.identity(), i.copy(x.matrixWorld), i.premultiply(g), o.extractRotation(i), S.halfWidth.set(.5 * x.width, 0, 0), S.halfHeight.set(0, .5 * x.height, 0), S.halfWidth.applyMatrix4(o), S.halfHeight.applyMatrix4(o), e.rectArea[m] = S, m++) : x.isPointLight ? ((S = t.get(x)).position.setFromMatrixPosition(x.matrixWorld), S.position.applyMatrix4(g), S.color.copy(x.color).multiplyScalar(x.intensity), S.distance = x.distance, S.decay = x.decay, S.shadow = x.castShadow, x.castShadow && (T = x.shadow, S.shadowBias = T.bias, S.shadowRadius = T.radius, S.shadowMapSize = T.mapSize, S.shadowCameraNear = T.camera.near, S.shadowCameraFar = T.camera.far), e.pointShadowMap[d] = M, e.pointShadowMatrix[d] = x.shadow.matrix, e.point[d] = S, d++) : x.isHemisphereLight && ((S = t.get(x)).direction.setFromMatrixPosition(x.matrixWorld), S.direction.transformDirection(g), S.direction.normalize(), S.skyColor.copy(x.color).multiplyScalar(w), S.groundColor.copy(x.groundColor).multiplyScalar(w), e.hemi[v] = S, v++)
                        }
                        e.ambient[0] = c, e.ambient[1] = u, e.ambient[2] = l;
                        var A = e.hash;
                        A.directionalLength === p && A.pointLength === d && A.spotLength === f && A.rectAreaLength === m && A.hemiLength === v && A.shadowsLength === a.length || (e.directional.length = p, e.spot.length = f, e.rectArea.length = m, e.point.length = d, e.hemi.length = v, A.directionalLength = p, A.pointLength = d, A.spotLength = f, A.rectAreaLength = m, A.hemiLength = v, A.shadowsLength = a.length, e.version = Oi++)
                    },
                    state: e
                }
            }

            function Bi() {
                var t = new Ii,
                    e = [],
                    n = [];
                return {
                    init: function() {
                        e.length = 0, n.length = 0
                    },
                    state: {
                        lightsArray: e,
                        shadowsArray: n,
                        lights: t
                    },
                    setupLights: function(r) {
                        t.setup(e, n, r)
                    },
                    pushLight: function(t) {
                        e.push(t)
                    },
                    pushShadow: function(t) {
                        n.push(t)
                    }
                }
            }

            function Di() {
                var t = {};

                function e(n) {
                    var r = n.target;
                    r.removeEventListener("dispose", e), delete t[r.id]
                }
                return {
                    get: function(n, r) {
                        var i;
                        return void 0 === t[n.id] ? (i = new Bi, t[n.id] = {}, t[n.id][r.id] = i, n.addEventListener("dispose", e)) : void 0 === t[n.id][r.id] ? (i = new Bi, t[n.id][r.id] = i) : i = t[n.id][r.id], i
                    },
                    dispose: function() {
                        t = {}
                    }
                }
            }

            function Fi(t) {
                mn.call(this), this.type = "MeshDepthMaterial", this.depthPacking = Fe, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function ki(t) {
                mn.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new je, this.nearDistance = 1, this.farDistance = 1e3, this.skinning = !1, this.morphTargets = !1, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.lights = !1, this.setValues(t)
            }

            function Ni(t, e, n) {
                for (var r = new Zn, i = new Qe, o = new He, a = new He(n, n), s = new je, c = new je, u = 1, l = 2, h = 1 + (u | l), p = new Array(h), d = new Array(h), m = {}, x = {
                        0: g,
                        1: v,
                        2: y
                    }, b = [new je(1, 0, 0), new je(-1, 0, 0), new je(0, 0, 1), new je(0, 0, -1), new je(0, 1, 0), new je(0, -1, 0)], w = [new je(0, 1, 0), new je(0, 1, 0), new je(0, 1, 0), new je(0, 1, 0), new je(0, 0, 1), new je(0, 0, -1)], _ = [new Ye, new Ye, new Ye, new Ye, new Ye, new Ye], M = 0; M !== h; ++M) {
                    var S = 0 != (M & u),
                        T = 0 != (M & l),
                        A = new Fi({
                            depthPacking: ke,
                            morphTargets: S,
                            skinning: T
                        });
                    p[M] = A;
                    var L = new ki({
                        morphTargets: S,
                        skinning: T
                    });
                    d[M] = L
                }
                var C = this;

                function R(e, n, r, i, o, a) {
                    var s = e.geometry,
                        c = null,
                        h = p,
                        f = e.customDepthMaterial;
                    if (r && (h = d, f = e.customDistanceMaterial), f) c = f;
                    else {
                        var v = !1;
                        n.morphTargets && (s && s.isBufferGeometry ? v = s.morphAttributes && s.morphAttributes.position && s.morphAttributes.position.length > 0 : s && s.isGeometry && (v = s.morphTargets && s.morphTargets.length > 0)), e.isSkinnedMesh && !1 === n.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e);
                        var g = e.isSkinnedMesh && n.skinning,
                            y = 0;
                        v && (y |= u), g && (y |= l), c = h[y]
                    }
                    if (t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length) {
                        var b = c.uuid,
                            w = n.uuid,
                            _ = m[b];
                        void 0 === _ && (_ = {}, m[b] = _);
                        var M = _[w];
                        void 0 === M && (M = c.clone(), _[w] = M), c = M
                    }
                    return c.visible = n.visible, c.wireframe = n.wireframe, c.side = null != n.shadowSide ? n.shadowSide : x[n.side], c.clipShadows = n.clipShadows, c.clippingPlanes = n.clippingPlanes, c.clipIntersection = n.clipIntersection, c.wireframeLinewidth = n.wireframeLinewidth, c.linewidth = n.linewidth, r && c.isMeshDistanceMaterial && (c.referencePosition.copy(i), c.nearDistance = o, c.farDistance = a), c
                }

                function P(n, i, o, a) {
                    if (!1 !== n.visible) {
                        if (n.layers.test(i.layers) && (n.isMesh || n.isLine || n.isPoints) && n.castShadow && (!n.frustumCulled || r.intersectsObject(n))) {
                            n.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, n.matrixWorld);
                            var s = e.update(n),
                                u = n.material;
                            if (Array.isArray(u))
                                for (var l = s.groups, h = 0, p = l.length; h < p; h++) {
                                    var d = l[h],
                                        f = u[d.materialIndex];
                                    if (f && f.visible) {
                                        var m = R(n, f, a, c, o.near, o.far);
                                        t.renderBufferDirect(o, null, s, m, n, d)
                                    }
                                } else u.visible && (m = R(n, u, a, c, o.near, o.far), t.renderBufferDirect(o, null, s, m, n, null))
                        }
                        for (var v = n.children, g = 0, y = v.length; g < y; g++) P(v[g], i, o, a)
                    }
                }
                this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = f, this.render = function(e, n, u) {
                    if (!1 !== C.enabled && (!1 !== C.autoUpdate || !1 !== C.needsUpdate) && 0 !== e.length) {
                        var l, h = t.getRenderTarget(),
                            p = t.getActiveCubeFace(),
                            d = t.getActiveMipMapLevel(),
                            f = t.state;
                        f.setBlending(E), f.buffers.color.setClear(1, 1, 1, 1), f.buffers.depth.setTest(!0), f.setScissorTest(!1);
                        for (var m = 0, v = e.length; m < v; m++) {
                            var g = e[m],
                                y = g.shadow,
                                x = g && g.isPointLight;
                            if (void 0 !== y) {
                                var M = y.camera;
                                if (o.copy(y.mapSize), o.min(a), x) {
                                    var S = o.x,
                                        T = o.y;
                                    _[0].set(2 * S, T, S, T), _[1].set(0, T, S, T), _[2].set(3 * S, T, S, T), _[3].set(S, T, S, T), _[4].set(3 * S, 0, S, T), _[5].set(S, 0, S, T), o.x *= 4, o.y *= 2
                                }
                                if (null === y.map) {
                                    var A = {
                                        minFilter: bt,
                                        magFilter: bt,
                                        format: Gt
                                    };
                                    y.map = new Je(o.x, o.y, A), y.map.texture.name = g.name + ".shadowMap", M.updateProjectionMatrix()
                                }
                                y.isSpotLightShadow && y.update(g);
                                var L = y.map,
                                    R = y.matrix;
                                c.setFromMatrixPosition(g.matrixWorld), M.position.copy(c), x ? (l = 6, R.makeTranslation(-c.x, -c.y, -c.z)) : (l = 1, s.setFromMatrixPosition(g.target.matrixWorld), M.lookAt(s), M.updateMatrixWorld(), R.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), R.multiply(M.projectionMatrix), R.multiply(M.matrixWorldInverse)), t.setRenderTarget(L), t.clear();
                                for (var O = 0; O < l; O++) {
                                    if (x) {
                                        s.copy(M.position), s.add(b[O]), M.up.copy(w[O]), M.lookAt(s), M.updateMatrixWorld();
                                        var I = _[O];
                                        f.viewport(I)
                                    }
                                    i.multiplyMatrices(M.projectionMatrix, M.matrixWorldInverse), r.setFromMatrix(i), P(n, u, M, x)
                                }
                            } else console.warn("THREE.WebGLShadowMap:", g, "has no shadow.")
                        }
                        C.needsUpdate = !1, t.setRenderTarget(h, p, d)
                    }
                }
            }

            function zi(t, e, n, r) {
                var i = new function() {
                        var e = !1,
                            n = new Ye,
                            r = null,
                            i = new Ye(0, 0, 0, 0);
                        return {
                            setMask: function(n) {
                                r === n || e || (t.colorMask(n, n, n, n), r = n)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e, r, o, a, s) {
                                !0 === s && (e *= a, r *= a, o *= a), n.set(e, r, o, a), !1 === i.equals(n) && (t.clearColor(e, r, o, a), i.copy(n))
                            },
                            reset: function() {
                                e = !1, r = null, i.set(-1, 0, 0, 0)
                            }
                        }
                    },
                    o = new function() {
                        var e = !1,
                            n = null,
                            r = null,
                            i = null;
                        return {
                            setTest: function(t) {
                                t ? ot(2929) : at(2929)
                            },
                            setMask: function(r) {
                                n === r || e || (t.depthMask(r), n = r)
                            },
                            setFunc: function(e) {
                                if (r !== e) {
                                    if (e) switch (e) {
                                        case q:
                                            t.depthFunc(512);
                                            break;
                                        case X:
                                            t.depthFunc(519);
                                            break;
                                        case Y:
                                            t.depthFunc(513);
                                            break;
                                        case J:
                                            t.depthFunc(515);
                                            break;
                                        case Z:
                                            t.depthFunc(514);
                                            break;
                                        case Q:
                                            t.depthFunc(518);
                                            break;
                                        case K:
                                            t.depthFunc(516);
                                            break;
                                        case $:
                                            t.depthFunc(517);
                                            break;
                                        default:
                                            t.depthFunc(515)
                                    } else t.depthFunc(515);
                                    r = e
                                }
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                i !== e && (t.clearDepth(e), i = e)
                            },
                            reset: function() {
                                e = !1, n = null, r = null, i = null
                            }
                        }
                    },
                    a = new function() {
                        var e = !1,
                            n = null,
                            r = null,
                            i = null,
                            o = null,
                            a = null,
                            s = null,
                            c = null,
                            u = null;
                        return {
                            setTest: function(t) {
                                t ? ot(2960) : at(2960)
                            },
                            setMask: function(r) {
                                n === r || e || (t.stencilMask(r), n = r)
                            },
                            setFunc: function(e, n, a) {
                                r === e && i === n && o === a || (t.stencilFunc(e, n, a), r = e, i = n, o = a)
                            },
                            setOp: function(e, n, r) {
                                a === e && s === n && c === r || (t.stencilOp(e, n, r), a = e, s = n, c = r)
                            },
                            setLocked: function(t) {
                                e = t
                            },
                            setClear: function(e) {
                                u !== e && (t.clearStencil(e), u = e)
                            },
                            reset: function() {
                                e = !1, n = null, r = null, i = null, o = null, a = null, s = null, c = null, u = null
                            }
                        }
                    },
                    l = t.getParameter(34921),
                    h = new Uint8Array(l),
                    p = new Uint8Array(l),
                    d = new Uint8Array(l),
                    f = {},
                    m = null,
                    v = null,
                    x = null,
                    b = null,
                    w = null,
                    _ = null,
                    M = null,
                    P = null,
                    O = null,
                    I = null,
                    B = !1,
                    D = null,
                    F = null,
                    k = null,
                    N = null,
                    z = null,
                    G = t.getParameter(35661),
                    H = !1,
                    U = 0,
                    j = t.getParameter(7938); - 1 !== j.indexOf("WebGL") ? (U = parseFloat(/^WebGL\ ([0-9])/.exec(j)[1]), H = U >= 1) : -1 !== j.indexOf("OpenGL ES") && (U = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(j)[1]), H = U >= 2);
                var V = null,
                    W = {},
                    tt = new Ye,
                    et = new Ye;

                function nt(e, n, r) {
                    var i = new Uint8Array(4),
                        o = t.createTexture();
                    t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
                    for (var a = 0; a < r; a++) t.texImage2D(n + a, 0, 6408, 1, 1, 0, 6408, 5121, i);
                    return o
                }
                var rt = {};

                function it(n, i) {
                    (h[n] = 1, 0 === p[n] && (t.enableVertexAttribArray(n), p[n] = 1), d[n] !== i) && ((r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, i), d[n] = i)
                }

                function ot(e) {
                    !0 !== f[e] && (t.enable(e), f[e] = !0)
                }

                function at(e) {
                    !1 !== f[e] && (t.disable(e), f[e] = !1)
                }

                function st(e, r, i, o, a, s, c, u) {
                    if (e !== E) {
                        if (x || (ot(3042), x = !0), e === C) a = a || r, s = s || i, c = c || o, r === w && a === P || (t.blendEquationSeparate(n.convert(r), n.convert(a)), w = r, P = a), i === _ && o === M && s === O && c === I || (t.blendFuncSeparate(n.convert(i), n.convert(o), n.convert(s), n.convert(c)), _ = i, M = o, O = s, I = c), b = e, B = null;
                        else if (e !== b || u !== B) {
                            if (w === R && P === R || (t.blendEquation(32774), w = R, P = R), u) switch (e) {
                                case S:
                                    t.blendFuncSeparate(1, 771, 1, 771);
                                    break;
                                case T:
                                    t.blendFunc(1, 1);
                                    break;
                                case A:
                                    t.blendFuncSeparate(0, 0, 769, 771);
                                    break;
                                case L:
                                    t.blendFuncSeparate(0, 768, 0, 770);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            } else switch (e) {
                                case S:
                                    t.blendFuncSeparate(770, 771, 1, 771);
                                    break;
                                case T:
                                    t.blendFunc(770, 1);
                                    break;
                                case A:
                                    t.blendFunc(0, 769);
                                    break;
                                case L:
                                    t.blendFunc(0, 768);
                                    break;
                                default:
                                    console.error("THREE.WebGLState: Invalid blending: ", e)
                            }
                            _ = null, M = null, O = null, I = null, b = e, B = u
                        }
                    } else x && (at(3042), x = !1)
                }

                function ct(e) {
                    D !== e && (e ? t.frontFace(2304) : t.frontFace(2305), D = e)
                }

                function ut(e) {
                    e !== s ? (ot(2884), e !== F && (e === c ? t.cullFace(1029) : e === u ? t.cullFace(1028) : t.cullFace(1032))) : at(2884), F = e
                }

                function lt(e, n, r) {
                    e ? (ot(32823), N === n && z === r || (t.polygonOffset(n, r), N = n, z = r)) : at(32823)
                }

                function ht(e) {
                    void 0 === e && (e = 33984 + G - 1), V !== e && (t.activeTexture(e), V = e)
                }
                return rt[3553] = nt(3553, 3553, 1), rt[34067] = nt(34067, 34069, 6), i.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ot(2929), o.setFunc(J), ct(!1), ut(c), ot(2884), st(E), {
                    buffers: {
                        color: i,
                        depth: o,
                        stencil: a
                    },
                    initAttributes: function() {
                        for (var t = 0, e = h.length; t < e; t++) h[t] = 0
                    },
                    enableAttribute: function(t) {
                        it(t, 0)
                    },
                    enableAttributeAndDivisor: it,
                    disableUnusedAttributes: function() {
                        for (var e = 0, n = p.length; e !== n; ++e) p[e] !== h[e] && (t.disableVertexAttribArray(e), p[e] = 0)
                    },
                    enable: ot,
                    disable: at,
                    getCompressedTextureFormats: function() {
                        if (null === m && (m = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc")))
                            for (var n = t.getParameter(34467), r = 0; r < n.length; r++) m.push(n[r]);
                        return m
                    },
                    useProgram: function(e) {
                        return v !== e && (t.useProgram(e), v = e, !0)
                    },
                    setBlending: st,
                    setMaterial: function(t, e) {
                        t.side === y ? at(2884) : ot(2884);
                        var n = t.side === g;
                        e && (n = !n), ct(n), t.blending === S && !1 === t.transparent ? st(E) : st(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), o.setFunc(t.depthFunc), o.setTest(t.depthTest), o.setMask(t.depthWrite), i.setMask(t.colorWrite), lt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
                    },
                    setFlipSided: ct,
                    setCullFace: ut,
                    setLineWidth: function(e) {
                        e !== k && (H && t.lineWidth(e), k = e)
                    },
                    setPolygonOffset: lt,
                    setScissorTest: function(t) {
                        t ? ot(3089) : at(3089)
                    },
                    activeTexture: ht,
                    bindTexture: function(e, n) {
                        null === V && ht();
                        var r = W[V];
                        void 0 === r && (r = {
                            type: void 0,
                            texture: void 0
                        }, W[V] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || rt[e]), r.type = e, r.texture = n)
                    },
                    compressedTexImage2D: function() {
                        try {
                            t.compressedTexImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage2D: function() {
                        try {
                            t.texImage2D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    texImage3D: function() {
                        try {
                            t.texImage3D.apply(t, arguments)
                        } catch (t) {
                            console.error("THREE.WebGLState:", t)
                        }
                    },
                    scissor: function(e) {
                        !1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
                    },
                    viewport: function(e) {
                        !1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
                    },
                    reset: function() {
                        for (var e = 0; e < p.length; e++) 1 === p[e] && (t.disableVertexAttribArray(e), p[e] = 0);
                        f = {}, m = null, V = null, W = {}, v = null, b = null, D = null, F = null, i.reset(), o.reset(), a.reset()
                    }
                }
            }

            function Gi(t, e, n, r, i, o, a) {
                var s, c = {},
                    u = "undefined" != typeof OffscreenCanvas;

                function l(t, e) {
                    return u ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
                }

                function h(t, e, n, r) {
                    var i = 1;
                    if ((t.width > r || t.height > r) && (i = r / Math.max(t.width, t.height)), i < 1 || !0 === e) {
                        if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) {
                            var o = e ? Ge.floorPowerOfTwo : Math.floor,
                                a = o(i * t.width),
                                c = o(i * t.height);
                            void 0 === s && (s = l(a, c));
                            var u = n ? l(a, c) : s;
                            return u.width = a, u.height = c, u.getContext("2d").drawImage(t, 0, 0, a, c), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + a + "x" + c + ")."), u
                        }
                        return "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ")."), t
                    }
                    return t
                }

                function p(t) {
                    return Ge.isPowerOfTwo(t.width) && Ge.isPowerOfTwo(t.height)
                }

                function d(t, e) {
                    return t.generateMipmaps && e && t.minFilter !== bt && t.minFilter !== Mt
                }

                function f(e, n, i, o) {
                    t.generateMipmap(e), r.get(n).__maxMipLevel = Math.log(Math.max(i, o)) * Math.LOG2E
                }

                function m(t, n) {
                    if (!i.isWebGL2) return t;
                    var r = t;
                    return 6403 === t && (5126 === n && (r = 33326), 5131 === n && (r = 33325), 5121 === n && (r = 33321)), 6407 === t && (5126 === n && (r = 34837), 5131 === n && (r = 34843), 5121 === n && (r = 32849)), 6408 === t && (5126 === n && (r = 34836), 5131 === n && (r = 34842), 5121 === n && (r = 32856)), 33325 === r || 33326 === r || 34842 === r || 34836 === r ? e.get("EXT_color_buffer_float") : 34843 !== r && 34837 !== r || console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), r
                }

                function v(t) {
                    return t === bt || t === wt || t === _t ? 9728 : 9729
                }

                function g(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", g), x(e), e.isVideoTexture && delete c[e.id], a.memory.textures--
                }

                function y(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", y), b(e), a.memory.textures--
                }

                function x(e) {
                    var n = r.get(e);
                    void 0 !== n.__webglInit && (t.deleteTexture(n.__webglTexture), r.remove(e))
                }

                function b(e) {
                    var n = r.get(e),
                        i = r.get(e.texture);
                    if (e) {
                        if (void 0 !== i.__webglTexture && t.deleteTexture(i.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube)
                            for (var o = 0; o < 6; o++) t.deleteFramebuffer(n.__webglFramebuffer[o]), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer[o]);
                        else t.deleteFramebuffer(n.__webglFramebuffer), n.__webglDepthbuffer && t.deleteRenderbuffer(n.__webglDepthbuffer);
                        r.remove(e.texture), r.remove(e)
                    }
                }
                var w = 0;

                function _(t, e) {
                    var i = r.get(t);
                    if (t.isVideoTexture && function(t) {
                            var e = t.id,
                                n = a.render.frame;
                            c[e] !== n && (c[e] = n, t.update())
                        }(t), t.version > 0 && i.__version !== t.version) {
                        var o = t.image;
                        if (void 0 === o) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
                        else {
                            if (!1 !== o.complete) return void A(i, t, e);
                            console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
                        }
                    }
                    n.activeTexture(33984 + e), n.bindTexture(3553, i.__webglTexture)
                }

                function M(e, a) {
                    var s = r.get(e);
                    if (6 === e.image.length)
                        if (e.version > 0 && s.__version !== e.version) {
                            T(s, e), n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY);
                            for (var c = e && e.isCompressedTexture, u = e.image[0] && e.image[0].isDataTexture, l = [], v = 0; v < 6; v++) l[v] = c || u ? u ? e.image[v].image : e.image[v] : h(e.image[v], !1, !0, i.maxCubemapSize);
                            var g = l[0],
                                y = p(g) || i.isWebGL2,
                                x = o.convert(e.format),
                                b = o.convert(e.type),
                                w = m(x, b);
                            for (S(34067, e, y), v = 0; v < 6; v++)
                                if (c)
                                    for (var _, M = l[v].mipmaps, E = 0, A = M.length; E < A; E++) _ = M[E], e.format !== Gt && e.format !== zt ? n.getCompressedTextureFormats().indexOf(x) > -1 ? n.compressedTexImage2D(34069 + v, E, w, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : n.texImage2D(34069 + v, E, w, _.width, _.height, 0, x, b, _.data);
                                else u ? n.texImage2D(34069 + v, 0, w, l[v].width, l[v].height, 0, x, b, l[v].data) : n.texImage2D(34069 + v, 0, w, x, b, l[v]);
                            s.__maxMipLevel = c ? M.length - 1 : 0, d(e, y) && f(34067, e, g.width, g.height), s.__version = e.version, e.onUpdate && e.onUpdate(e)
                        } else n.activeTexture(33984 + a), n.bindTexture(34067, s.__webglTexture)
                }

                function E(t, e) {
                    n.activeTexture(33984 + e), n.bindTexture(34067, r.get(t).__webglTexture)
                }

                function S(n, a, s) {
                    var c;
                    if (s ? (t.texParameteri(n, 10242, o.convert(a.wrapS)), t.texParameteri(n, 10243, o.convert(a.wrapT)), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, o.convert(a.wrapR)), t.texParameteri(n, 10240, o.convert(a.magFilter)), t.texParameteri(n, 10241, o.convert(a.minFilter))) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), a.wrapS === yt && a.wrapT === yt || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, v(a.magFilter)), t.texParameteri(n, 10241, v(a.minFilter)), a.minFilter !== bt && a.minFilter !== Mt && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), c = e.get("EXT_texture_filter_anisotropic")) {
                        if (a.type === Ot && null === e.get("OES_texture_float_linear")) return;
                        if (a.type === It && null === (i.isWebGL2 || e.get("OES_texture_half_float_linear"))) return;
                        (a.anisotropy > 1 || r.get(a).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, i.getMaxAnisotropy())), r.get(a).__currentAnisotropy = a.anisotropy)
                    }
                }

                function T(e, n) {
                    void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", g), e.__webglTexture = t.createTexture(), a.memory.textures++)
                }

                function A(e, r, a) {
                    var s = 3553;
                    r.isDataTexture2DArray && (s = 35866), r.isDataTexture3D && (s = 32879), T(e, r), n.activeTexture(33984 + a), n.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment);
                    var c = function(t) {
                            return !i.isWebGL2 && (t.wrapS !== yt || t.wrapT !== yt || t.minFilter !== bt && t.minFilter !== Mt)
                        }(r) && !1 === p(r.image),
                        u = h(r.image, c, !1, i.maxTextureSize),
                        l = p(u) || i.isWebGL2,
                        v = o.convert(r.format),
                        g = o.convert(r.type),
                        y = m(v, g);
                    S(s, r, l);
                    var x, b = r.mipmaps;
                    if (r.isDepthTexture) {
                        if (y = 6402, r.type === Ot) {
                            if (!i.isWebGL2) throw new Error("Float Depth Texture only supported in WebGL2.0");
                            y = 36012
                        } else i.isWebGL2 && (y = 33189);
                        r.format === Vt && 6402 === y && r.type !== Ct && r.type !== Pt && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = Ct, g = o.convert(r.type)), r.format === Wt && (y = 34041, r.type !== kt && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = kt, g = o.convert(r.type))), n.texImage2D(3553, 0, y, u.width, u.height, 0, v, g, null)
                    } else if (r.isDataTexture)
                        if (b.length > 0 && l) {
                            for (var w = 0, _ = b.length; w < _; w++) x = b[w], n.texImage2D(3553, w, y, x.width, x.height, 0, v, g, x.data);
                            r.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                        } else n.texImage2D(3553, 0, y, u.width, u.height, 0, v, g, u.data), e.__maxMipLevel = 0;
                    else if (r.isCompressedTexture) {
                        for (w = 0, _ = b.length; w < _; w++) x = b[w], r.format !== Gt && r.format !== zt ? n.getCompressedTextureFormats().indexOf(v) > -1 ? n.compressedTexImage2D(3553, w, y, x.width, x.height, 0, x.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texImage2D(3553, w, y, x.width, x.height, 0, v, g, x.data);
                        e.__maxMipLevel = b.length - 1
                    } else if (r.isDataTexture2DArray) n.texImage3D(35866, 0, y, u.width, u.height, u.depth, 0, v, g, u.data), e.__maxMipLevel = 0;
                    else if (r.isDataTexture3D) n.texImage3D(32879, 0, y, u.width, u.height, u.depth, 0, v, g, u.data), e.__maxMipLevel = 0;
                    else if (b.length > 0 && l) {
                        for (w = 0, _ = b.length; w < _; w++) x = b[w], n.texImage2D(3553, w, y, v, g, x);
                        r.generateMipmaps = !1, e.__maxMipLevel = b.length - 1
                    } else n.texImage2D(3553, 0, y, v, g, u), e.__maxMipLevel = 0;
                    d(r, l) && f(3553, r, u.width, u.height), e.__version = r.version, r.onUpdate && r.onUpdate(r)
                }

                function L(e, i, a, s) {
                    var c = o.convert(i.texture.format),
                        u = o.convert(i.texture.type),
                        l = m(c, u);
                    n.texImage2D(s, 0, l, i.width, i.height, 0, c, u, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, r.get(i.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
                }

                function C(e, n, r) {
                    if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
                        if (r) {
                            var i = P(n);
                            t.renderbufferStorageMultisample(36161, i, 33189, n.width, n.height)
                        } else t.renderbufferStorage(36161, 33189, n.width, n.height);
                        t.framebufferRenderbuffer(36160, 36096, 36161, e)
                    } else if (n.depthBuffer && n.stencilBuffer) r ? (i = P(n), t.renderbufferStorageMultisample(36161, i, 35056, n.width, n.height)) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e);
                    else {
                        var a = m(o.convert(n.texture.format), o.convert(n.texture.type));
                        r ? (i = P(n), t.renderbufferStorageMultisample(36161, i, a, n.width, n.height)) : t.renderbufferStorage(36161, a, n.width, n.height)
                    }
                    t.bindRenderbuffer(36161, null)
                }

                function R(e) {
                    var n = r.get(e),
                        i = !0 === e.isWebGLRenderTargetCube;
                    if (e.depthTexture) {
                        if (i) throw new Error("target.depthTexture not supported in Cube render targets");
                        ! function(e, n) {
                            if (n && n.isWebGLRenderTargetCube) throw new Error("Depth Texture with cube render targets is not supported");
                            if (t.bindFramebuffer(36160, e), !n.depthTexture || !n.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                            r.get(n.depthTexture).__webglTexture && n.depthTexture.image.width === n.width && n.depthTexture.image.height === n.height || (n.depthTexture.image.width = n.width, n.depthTexture.image.height = n.height, n.depthTexture.needsUpdate = !0), _(n.depthTexture, 0);
                            var i = r.get(n.depthTexture).__webglTexture;
                            if (n.depthTexture.format === Vt) t.framebufferTexture2D(36160, 36096, 3553, i, 0);
                            else {
                                if (n.depthTexture.format !== Wt) throw new Error("Unknown depthTexture format");
                                t.framebufferTexture2D(36160, 33306, 3553, i, 0)
                            }
                        }(n.__webglFramebuffer, e)
                    } else if (i) {
                        n.__webglDepthbuffer = [];
                        for (var o = 0; o < 6; o++) t.bindFramebuffer(36160, n.__webglFramebuffer[o]), n.__webglDepthbuffer[o] = t.createRenderbuffer(), C(n.__webglDepthbuffer[o], e)
                    } else t.bindFramebuffer(36160, n.__webglFramebuffer), n.__webglDepthbuffer = t.createRenderbuffer(), C(n.__webglDepthbuffer, e);
                    t.bindFramebuffer(36160, null)
                }

                function P(t) {
                    return i.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(i.maxSamples, t.samples) : 0
                }
                var O = !1,
                    I = !1;
                this.allocateTextureUnit = function() {
                    var t = w;
                    return t >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + i.maxTextures), w += 1, t
                }, this.resetTextureUnits = function() {
                    w = 0
                }, this.setTexture2D = _, this.setTexture2DArray = function(t, e) {
                    var i = r.get(t);
                    t.version > 0 && i.__version !== t.version ? A(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(35866, i.__webglTexture))
                }, this.setTexture3D = function(t, e) {
                    var i = r.get(t);
                    t.version > 0 && i.__version !== t.version ? A(i, t, e) : (n.activeTexture(33984 + e), n.bindTexture(32879, i.__webglTexture))
                }, this.setTextureCube = M, this.setTextureCubeDynamic = E, this.setupRenderTarget = function(e) {
                    var s = r.get(e),
                        c = r.get(e.texture);
                    e.addEventListener("dispose", y), c.__webglTexture = t.createTexture(), a.memory.textures++;
                    var u = !0 === e.isWebGLRenderTargetCube,
                        l = !0 === e.isWebGLMultisampleRenderTarget,
                        h = p(e) || i.isWebGL2;
                    if (u) {
                        s.__webglFramebuffer = [];
                        for (var v = 0; v < 6; v++) s.__webglFramebuffer[v] = t.createFramebuffer()
                    } else if (s.__webglFramebuffer = t.createFramebuffer(), l)
                        if (i.isWebGL2) {
                            s.__webglMultisampledFramebuffer = t.createFramebuffer(), s.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, s.__webglColorRenderbuffer);
                            var g = m(o.convert(e.texture.format), o.convert(e.texture.type)),
                                x = P(e);
                            t.renderbufferStorageMultisample(36161, x, g, e.width, e.height), t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(), C(s.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
                    if (u) {
                        for (n.bindTexture(34067, c.__webglTexture), S(34067, e.texture, h), v = 0; v < 6; v++) L(s.__webglFramebuffer[v], e, 36064, 34069 + v);
                        d(e.texture, h) && f(34067, e.texture, e.width, e.height), n.bindTexture(34067, null)
                    } else n.bindTexture(3553, c.__webglTexture), S(3553, e.texture, h), L(s.__webglFramebuffer, e, 36064, 3553), d(e.texture, h) && f(3553, e.texture, e.width, e.height), n.bindTexture(3553, null);
                    e.depthBuffer && R(e)
                }, this.updateRenderTargetMipmap = function(t) {
                    var e = t.texture;
                    if (d(e, p(t) || i.isWebGL2)) {
                        var o = t.isWebGLRenderTargetCube ? 34067 : 3553,
                            a = r.get(e).__webglTexture;
                        n.bindTexture(o, a), f(o, e, t.width, t.height), n.bindTexture(o, null)
                    }
                }, this.updateMultisampleRenderTarget = function(e) {
                    if (e.isWebGLMultisampleRenderTarget)
                        if (i.isWebGL2) {
                            var n = r.get(e);
                            t.bindFramebuffer(36008, n.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, n.__webglFramebuffer);
                            var o = e.width,
                                a = e.height,
                                s = 16384;
                            e.depthBuffer && (s |= 256), e.stencilBuffer && (s |= 1024), t.blitFramebuffer(0, 0, o, a, 0, 0, o, a, s, 9728)
                        } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
                }, this.safeSetTexture2D = function(t, e) {
                    t && t.isWebGLRenderTarget && (!1 === O && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), O = !0), t = t.texture), _(t, e)
                }, this.safeSetTextureCube = function(t, e) {
                    t && t.isWebGLRenderTargetCube && (!1 === I && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), I = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? M(t, e) : E(t, e)
                }
            }

            function Hi(t, e, n) {
                return {
                    convert: function(t) {
                        var r;
                        if (t === gt) return 10497;
                        if (t === yt) return 33071;
                        if (t === xt) return 33648;
                        if (t === bt) return 9728;
                        if (t === wt) return 9984;
                        if (t === _t) return 9986;
                        if (t === Mt) return 9729;
                        if (t === Et) return 9985;
                        if (t === St) return 9987;
                        if (t === Tt) return 5121;
                        if (t === Bt) return 32819;
                        if (t === Dt) return 32820;
                        if (t === Ft) return 33635;
                        if (t === At) return 5120;
                        if (t === Lt) return 5122;
                        if (t === Ct) return 5123;
                        if (t === Rt) return 5124;
                        if (t === Pt) return 5125;
                        if (t === Ot) return 5126;
                        if (t === It) {
                            if (n.isWebGL2) return 5131;
                            if (null !== (r = e.get("OES_texture_half_float"))) return r.HALF_FLOAT_OES
                        }
                        if (t === Nt) return 6406;
                        if (t === zt) return 6407;
                        if (t === Gt) return 6408;
                        if (t === Ht) return 6409;
                        if (t === Ut) return 6410;
                        if (t === Vt) return 6402;
                        if (t === Wt) return 34041;
                        if (t === qt) return 6403;
                        if (t === R) return 32774;
                        if (t === P) return 32778;
                        if (t === O) return 32779;
                        if (t === D) return 0;
                        if (t === F) return 1;
                        if (t === k) return 768;
                        if (t === N) return 769;
                        if (t === z) return 770;
                        if (t === G) return 771;
                        if (t === H) return 772;
                        if (t === U) return 773;
                        if (t === j) return 774;
                        if (t === V) return 775;
                        if (t === W) return 776;
                        if ((t === Xt || t === Yt || t === Jt || t === Zt) && null !== (r = e.get("WEBGL_compressed_texture_s3tc"))) {
                            if (t === Xt) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                            if (t === Yt) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                            if (t === Jt) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                            if (t === Zt) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
                        }
                        if ((t === Qt || t === Kt || t === $t || t === te) && null !== (r = e.get("WEBGL_compressed_texture_pvrtc"))) {
                            if (t === Qt) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                            if (t === Kt) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                            if (t === $t) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                            if (t === te) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                        }
                        if (t === ee && null !== (r = e.get("WEBGL_compressed_texture_etc1"))) return r.COMPRESSED_RGB_ETC1_WEBGL;
                        if ((t === ne || t === re || t === ie || t === oe || t === ae || t === se || t === ce || t === ue || t === le || t === he || t === pe || t === de || t === fe || t === me) && null !== (r = e.get("WEBGL_compressed_texture_astc"))) return t;
                        if (t === I || t === B) {
                            if (n.isWebGL2) {
                                if (t === I) return 32775;
                                if (t === B) return 32776
                            }
                            if (null !== (r = e.get("EXT_blend_minmax"))) {
                                if (t === I) return r.MIN_EXT;
                                if (t === B) return r.MAX_EXT
                            }
                        }
                        if (t === kt) {
                            if (n.isWebGL2) return 34042;
                            if (null !== (r = e.get("WEBGL_depth_texture"))) return r.UNSIGNED_INT_24_8_WEBGL
                        }
                        return 0
                    }
                }
            }

            function Ui() {
                en.call(this), this.type = "Group"
            }

            function ji(t) {
                jn.call(this), this.cameras = t || []
            }
            Fi.prototype = Object.create(mn.prototype), Fi.prototype.constructor = Fi, Fi.prototype.isMeshDepthMaterial = !0, Fi.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
            }, ki.prototype = Object.create(mn.prototype), ki.prototype.constructor = ki, ki.prototype.isMeshDistanceMaterial = !0, ki.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
            }, Ui.prototype = Object.assign(Object.create(en.prototype), {
                constructor: Ui,
                isGroup: !0
            }), ji.prototype = Object.assign(Object.create(jn.prototype), {
                constructor: ji,
                isArrayCamera: !0
            });
            var Vi, Wi = new je,
                qi = new je;

            function Xi(t, e, n) {
                Wi.setFromMatrixPosition(e.matrixWorld), qi.setFromMatrixPosition(n.matrixWorld);
                var r = Wi.distanceTo(qi),
                    i = e.projectionMatrix.elements,
                    o = n.projectionMatrix.elements,
                    a = i[14] / (i[10] - 1),
                    s = i[14] / (i[10] + 1),
                    c = (i[9] + 1) / i[5],
                    u = (i[9] - 1) / i[5],
                    l = (i[8] - 1) / i[0],
                    h = (o[8] + 1) / o[0],
                    p = a * l,
                    d = a * h,
                    f = r / (-l + h),
                    m = f * -l;
                e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(m), t.translateZ(f), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld);
                var v = a + f,
                    g = s + f,
                    y = p - m,
                    x = d + (r - m),
                    b = c * s / g * v,
                    w = u * s / g * v;
                t.projectionMatrix.makePerspective(y, x, b, w, v, g)
            }

            function Yi(t) {
                var e, n, r = this,
                    i = null,
                    o = null,
                    a = null,
                    s = [],
                    c = new Qe,
                    u = new Qe,
                    l = 1,
                    h = "local-floor";
                "undefined" != typeof window && "VRFrameData" in window && (o = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", w, !1));
                var p = new Qe,
                    d = new Ue,
                    f = new je,
                    m = new jn;
                m.viewport = new Ye, m.layers.enable(1);
                var v = new jn;
                v.viewport = new Ye, v.layers.enable(2);
                var g = new ji([m, v]);

                function y() {
                    return null !== i && !0 === i.isPresenting
                }
                g.layers.enable(1), g.layers.enable(2);
                var x, b = new He;

                function w() {
                    if (y()) {
                        var o = i.getEyeParameters("left");
                        e = 2 * o.renderWidth * l, n = o.renderHeight * l, x = t.getPixelRatio(), t.getSize(b), t.setDrawingBufferSize(e, n, 1), m.viewport.set(0, 0, e / 2, n), v.viewport.set(e / 2, 0, e / 2, n), T.start(), r.dispatchEvent({
                            type: "sessionstart"
                        })
                    } else r.enabled && t.setDrawingBufferSize(b.width, b.height, x), T.stop(), r.dispatchEvent({
                        type: "sessionend"
                    })
                }
                var _ = [];

                function M(t) {
                    for (var e = navigator.getGamepads && navigator.getGamepads(), n = 0, r = 0, i = e.length; n < i; n++) {
                        var o = e[n];
                        if (o && ("Daydream Controller" === o.id || "Gear VR Controller" === o.id || "Oculus Go Controller" === o.id || "OpenVR Gamepad" === o.id || o.id.startsWith("Oculus Touch") || o.id.startsWith("HTC Vive Focus") || o.id.startsWith("Spatial Controller"))) {
                            if (r === t) return o;
                            r++
                        }
                    }
                }

                function E() {
                    for (var t = 0; t < s.length; t++) {
                        var e = s[t],
                            n = M(t);
                        if (void 0 !== n && void 0 !== n.pose) {
                            if (null === n.pose) return;
                            var r = n.pose;
                            !1 === r.hasPosition && e.position.set(.2, -.6, -.05), null !== r.position && e.position.fromArray(r.position), null !== r.orientation && e.quaternion.fromArray(r.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(c), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0;
                            var i = "Daydream Controller" === n.id ? 0 : 1;
                            void 0 === _[t] && (_[t] = !1), _[t] !== n.buttons[i].pressed && (_[t] = n.buttons[i].pressed, !0 === _[t] ? e.dispatchEvent({
                                type: "selectstart"
                            }) : (e.dispatchEvent({
                                type: "selectend"
                            }), e.dispatchEvent({
                                type: "select"
                            })))
                        } else e.visible = !1
                    }
                }

                function S(t, r) {
                    null !== r && 4 === r.length && t.set(r[0] * e, r[1] * n, r[2] * e, r[3] * n)
                }
                this.enabled = !1, this.getController = function(t) {
                    var e = s[t];
                    return void 0 === e && ((e = new Ui).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e
                }, this.getDevice = function() {
                    return i
                }, this.setDevice = function(t) {
                    void 0 !== t && (i = t), T.setContext(t)
                }, this.setFramebufferScaleFactor = function(t) {
                    l = t
                }, this.setReferenceSpaceType = function(t) {
                    h = t
                }, this.setPoseTarget = function(t) {
                    void 0 !== t && (a = t)
                }, this.getCamera = function(t) {
                    var e = "local-floor" === h ? 1.6 : 0;
                    if (!1 === y()) return t.position.set(0, e, 0), t.rotation.set(0, 0, 0), t;
                    if (i.depthNear = t.near, i.depthFar = t.far, i.getFrameData(o), "local-floor" === h) {
                        var n = i.stageParameters;
                        n ? c.fromArray(n.sittingToStandingTransform) : c.makeTranslation(0, e, 0)
                    }
                    var r = o.pose,
                        s = null !== a ? a : t;
                    s.matrix.copy(c), s.matrix.decompose(s.position, s.quaternion, s.scale), null !== r.orientation && (d.fromArray(r.orientation), s.quaternion.multiply(d)), null !== r.position && (d.setFromRotationMatrix(c), f.fromArray(r.position), f.applyQuaternion(d), s.position.add(f)), s.updateMatrixWorld(), m.near = t.near, v.near = t.near, m.far = t.far, v.far = t.far, m.matrixWorldInverse.fromArray(o.leftViewMatrix), v.matrixWorldInverse.fromArray(o.rightViewMatrix), u.getInverse(c), "local-floor" === h && (m.matrixWorldInverse.multiply(u), v.matrixWorldInverse.multiply(u));
                    var l = s.parent;
                    null !== l && (p.getInverse(l.matrixWorld), m.matrixWorldInverse.multiply(p), v.matrixWorldInverse.multiply(p)), m.matrixWorld.getInverse(m.matrixWorldInverse), v.matrixWorld.getInverse(v.matrixWorldInverse), m.projectionMatrix.fromArray(o.leftProjectionMatrix), v.projectionMatrix.fromArray(o.rightProjectionMatrix), Xi(g, m, v);
                    var x = i.getLayers();
                    if (x.length) {
                        var b = x[0];
                        S(m.viewport, b.leftBounds), S(v.viewport, b.rightBounds)
                    }
                    return E(), g
                }, this.getStandingMatrix = function() {
                    return c
                }, this.isPresenting = y;
                var T = new tr;
                this.setAnimationLoop = function(t) {
                    T.setAnimationLoop(t), y() && T.start()
                }, this.submitFrame = function() {
                    y() && i.submitFrame()
                }, this.dispose = function() {
                    "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", w)
                }, this.setFrameOfReferenceType = function() {
                    console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
                }
            }

            function Ji(t) {
                var e = this,
                    n = t.context,
                    r = null,
                    i = null,
                    o = "local-floor",
                    a = null,
                    s = [],
                    c = [];

                function u() {
                    return null !== r && null !== i
                }
                var l = new jn;
                l.layers.enable(1), l.viewport = new Ye;
                var h = new jn;
                h.layers.enable(2), h.viewport = new Ye;
                var p = new ji([l, h]);

                function d(t) {
                    for (var e = 0; e < s.length; e++) c[e] === t.inputSource && s[e].dispatchEvent({
                        type: t.type
                    })
                }

                function f() {
                    t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), y.stop(), e.dispatchEvent({
                        type: "sessionend"
                    })
                }

                function m(t) {
                    i = t, y.setContext(r), y.start(), e.dispatchEvent({
                        type: "sessionstart"
                    })
                }

                function v(t, e) {
                    null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
                }
                p.layers.enable(1), p.layers.enable(2), this.enabled = !1, this.getController = function(t) {
                    var e = s[t];
                    return void 0 === e && ((e = new Ui).matrixAutoUpdate = !1, e.visible = !1, s[t] = e), e
                }, this.setFramebufferScaleFactor = function(t) {}, this.setReferenceSpaceType = function(t) {
                    o = t
                }, this.getSession = function() {
                    return r
                }, this.setSession = function(t) {
                    null !== (r = t) && (r.addEventListener("select", d), r.addEventListener("selectstart", d), r.addEventListener("selectend", d), r.addEventListener("end", f), r.updateRenderState({
                        baseLayer: new XRWebGLLayer(r, n)
                    }), r.requestReferenceSpace(o).then(m), c = r.inputSources, r.addEventListener("inputsourceschange", function() {
                        c = r.inputSources, console.log(c);
                        for (var t = 0; t < s.length; t++) {
                            s[t].userData.inputSource = c[t]
                        }
                    }))
                }, this.getCamera = function(t) {
                    if (u()) {
                        var e = t.parent,
                            n = p.cameras;
                        v(p, e);
                        for (var r = 0; r < n.length; r++) v(n[r], e);
                        t.matrixWorld.copy(p.matrixWorld);
                        for (var i = t.children, o = (r = 0, i.length); r < o; r++) i[r].updateMatrixWorld(!0);
                        return Xi(p, l, h), p
                    }
                    return t
                }, this.isPresenting = u;
                var g = null;
                var y = new tr;
                y.setAnimationLoop(function(e, n) {
                    if (null !== (a = n.getViewerPose(i))) {
                        var o = a.views,
                            u = r.renderState.baseLayer;
                        t.setFramebuffer(u.framebuffer);
                        for (var l = 0; l < o.length; l++) {
                            var h = o[l],
                                d = u.getViewport(h),
                                f = h.transform.inverse.matrix,
                                m = p.cameras[l];
                            m.matrix.fromArray(f).getInverse(m.matrix), m.projectionMatrix.fromArray(h.projectionMatrix), m.viewport.set(d.x, d.y, d.width, d.height), 0 === l && p.matrix.copy(m.matrix)
                        }
                    }
                    for (l = 0; l < s.length; l++) {
                        var v = s[l],
                            y = c[l];
                        if (y) {
                            var x = n.getPose(y.targetRaySpace, i);
                            if (null !== x) {
                                v.matrix.fromArray(x.transform.matrix), v.matrix.decompose(v.position, v.rotation, v.scale), v.visible = !0;
                                continue
                            }
                        }
                        v.visible = !1
                    }
                    g && g(e)
                }), this.setAnimationLoop = function(t) {
                    g = t
                }, this.dispose = function() {}, this.getStandingMatrix = function() {
                    return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new Qe
                }, this.getDevice = function() {
                    console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
                }, this.setDevice = function() {
                    console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
                }, this.setFrameOfReferenceType = function() {
                    console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
                }, this.submitFrame = function() {}
            }

            function Zi(t) {
                console.log("THREE.WebGLRenderer", o);
                var e = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
                    n = void 0 !== t.context ? t.context : null,
                    r = void 0 !== t.alpha && t.alpha,
                    i = void 0 === t.depth || t.depth,
                    a = void 0 === t.stencil || t.stencil,
                    s = void 0 !== t.antialias && t.antialias,
                    c = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
                    u = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
                    l = void 0 !== t.powerPreference ? t.powerPreference : "default",
                    h = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat,
                    p = null,
                    d = null;
                this.domElement = e, this.context = null, this.debug = {
                    checkShaderErrors: !0
                }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.gammaInput = !1, this.gammaOutput = !1, this.physicallyCorrectLights = !1, this.toneMapping = it, this.toneMappingExposure = 1, this.toneMappingWhitePoint = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
                var f, m, v, y, x, b, w, _, M, E, S, T, A, L, C, R, P, O, I = this,
                    B = !1,
                    D = null,
                    F = 0,
                    k = 0,
                    N = null,
                    z = null,
                    G = -1,
                    H = {
                        geometry: null,
                        program: null,
                        wireframe: !1
                    },
                    U = null,
                    j = null,
                    V = new Ye,
                    W = new Ye,
                    q = null,
                    X = e.width,
                    Y = e.height,
                    J = 1,
                    Z = new Ye(0, 0, X, Y),
                    Q = new Ye(0, 0, X, Y),
                    K = !1,
                    $ = new Zn,
                    tt = new sr,
                    et = !1,
                    nt = !1,
                    rt = new Qe,
                    ot = new je;

                function at() {
                    return null === N ? J : 1
                }
                try {
                    var st = {
                        alpha: r,
                        depth: i,
                        stencil: a,
                        antialias: s,
                        premultipliedAlpha: c,
                        preserveDrawingBuffer: u,
                        powerPreference: l,
                        failIfMajorPerformanceCaveat: h,
                        xrCompatible: !0
                    };
                    if (e.addEventListener("webglcontextlost", ht, !1), e.addEventListener("webglcontextrestored", pt, !1), null === (f = n || e.getContext("webgl", st) || e.getContext("experimental-webgl", st))) throw null !== e.getContext("webgl") ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.");
                    void 0 === f.getShaderPrecisionFormat && (f.getShaderPrecisionFormat = function() {
                        return {
                            rangeMin: 1,
                            rangeMax: 1,
                            precision: 1
                        }
                    })
                } catch (t) {
                    throw console.error("THREE.WebGLRenderer: " + t.message), t
                }

                function ct() {
                    m = new cr(f), (v = new ar(f, m, t)).isWebGL2 || (m.get("WEBGL_depth_texture"), m.get("OES_texture_float"), m.get("OES_texture_half_float"), m.get("OES_texture_half_float_linear"), m.get("OES_standard_derivatives"), m.get("OES_element_index_uint"), m.get("ANGLE_instanced_arrays")), m.get("OES_texture_float_linear"), O = new Hi(f, m, v), (y = new zi(f, m, O, v)).scissor(W.copy(Q).multiplyScalar(J).floor()), y.viewport(V.copy(Z).multiplyScalar(J).floor()), x = new hr(f), b = new Ti, w = new Gi(f, m, y, b, v, O, x), _ = new er(f), M = new ur(f, _, x), E = new fr(M, x), C = new dr(f), S = new Si(I, m, v), T = new Ri, A = new Di, L = new ir(I, y, E, c), R = new or(f, m, x, v), P = new lr(f, m, x, v), x.programs = S.programs, I.context = f, I.capabilities = v, I.extensions = m, I.properties = b, I.renderLists = T, I.state = y, I.info = x
                }
                ct();
                var ut = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Ji(I) : new Yi(I);
                this.vr = ut;
                var lt = new Ni(I, E, v.maxTextureSize);

                function ht(t) {
                    t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), B = !0
                }

                function pt() {
                    console.log("THREE.WebGLRenderer: Context Restored."), B = !1, ct()
                }

                function dt(t) {
                    var e = t.target;
                    e.removeEventListener("dispose", dt),
                        function(t) {
                            ft(t), b.remove(t)
                        }(e)
                }

                function ft(t) {
                    var e = b.get(t).program;
                    t.program = void 0, void 0 !== e && S.releaseProgram(e)
                }

                function mt(t, e, n) {
                    if (n && n.isInstancedBufferGeometry && !v.isWebGL2 && null === m.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    else {
                        y.initAttributes();
                        var r = n.attributes,
                            i = e.getAttributes(),
                            o = t.defaultAttributeValues;
                        for (var a in i) {
                            var s = i[a];
                            if (s >= 0) {
                                var c = r[a];
                                if (void 0 !== c) {
                                    var u = c.normalized,
                                        l = c.itemSize,
                                        h = _.get(c);
                                    if (void 0 === h) continue;
                                    var p = h.buffer,
                                        d = h.type,
                                        g = h.bytesPerElement;
                                    if (c.isInterleavedBufferAttribute) {
                                        var x = c.data,
                                            b = x.stride,
                                            w = c.offset;
                                        x && x.isInstancedInterleavedBuffer ? (y.enableAttributeAndDivisor(s, x.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = x.meshPerAttribute * x.count)) : y.enableAttribute(s), f.bindBuffer(34962, p), f.vertexAttribPointer(s, l, d, u, b * g, w * g)
                                    } else c.isInstancedBufferAttribute ? (y.enableAttributeAndDivisor(s, c.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = c.meshPerAttribute * c.count)) : y.enableAttribute(s), f.bindBuffer(34962, p), f.vertexAttribPointer(s, l, d, u, 0, 0)
                                } else if (void 0 !== o) {
                                    var M = o[a];
                                    if (void 0 !== M) switch (M.length) {
                                        case 2:
                                            f.vertexAttrib2fv(s, M);
                                            break;
                                        case 3:
                                            f.vertexAttrib3fv(s, M);
                                            break;
                                        case 4:
                                            f.vertexAttrib4fv(s, M);
                                            break;
                                        default:
                                            f.vertexAttrib1fv(s, M)
                                    }
                                }
                            }
                        }
                        y.disableUnusedAttributes()
                    }
                }
                this.shadowMap = lt, this.getContext = function() {
                    return f
                }, this.getContextAttributes = function() {
                    return f.getContextAttributes()
                }, this.forceContextLoss = function() {
                    var t = m.get("WEBGL_lose_context");
                    t && t.loseContext()
                }, this.forceContextRestore = function() {
                    var t = m.get("WEBGL_lose_context");
                    t && t.restoreContext()
                }, this.getPixelRatio = function() {
                    return J
                }, this.setPixelRatio = function(t) {
                    void 0 !== t && (J = t, this.setSize(X, Y, !1))
                }, this.getSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new He), t.set(X, Y)
                }, this.setSize = function(t, n, r) {
                    ut.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (X = t, Y = n, e.width = Math.floor(t * J), e.height = Math.floor(n * J), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
                }, this.getDrawingBufferSize = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new He), t.set(X * J, Y * J).floor()
                }, this.setDrawingBufferSize = function(t, n, r) {
                    X = t, Y = n, J = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
                }, this.getCurrentViewport = function(t) {
                    return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new Ye), t.copy(V)
                }, this.getViewport = function(t) {
                    return t.copy(Z)
                }, this.setViewport = function(t, e, n, r) {
                    t.isVector4 ? Z.set(t.x, t.y, t.z, t.w) : Z.set(t, e, n, r), y.viewport(V.copy(Z).multiplyScalar(J).floor())
                }, this.getScissor = function(t) {
                    return t.copy(Q)
                }, this.setScissor = function(t, e, n, r) {
                    t.isVector4 ? Q.set(t.x, t.y, t.z, t.w) : Q.set(t, e, n, r), y.scissor(W.copy(Q).multiplyScalar(J).floor())
                }, this.getScissorTest = function() {
                    return K
                }, this.setScissorTest = function(t) {
                    y.setScissorTest(K = t)
                }, this.getClearColor = function() {
                    return L.getClearColor()
                }, this.setClearColor = function() {
                    L.setClearColor.apply(L, arguments)
                }, this.getClearAlpha = function() {
                    return L.getClearAlpha()
                }, this.setClearAlpha = function() {
                    L.setClearAlpha.apply(L, arguments)
                }, this.clear = function(t, e, n) {
                    var r = 0;
                    (void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), f.clear(r)
                }, this.clearColor = function() {
                    this.clear(!0, !1, !1)
                }, this.clearDepth = function() {
                    this.clear(!1, !0, !1)
                }, this.clearStencil = function() {
                    this.clear(!1, !1, !0)
                }, this.dispose = function() {
                    e.removeEventListener("webglcontextlost", ht, !1), e.removeEventListener("webglcontextrestored", pt, !1), T.dispose(), A.dispose(), b.dispose(), E.dispose(), ut.dispose(), gt.stop()
                }, this.renderBufferImmediate = function(t, e) {
                    y.initAttributes();
                    var n = b.get(t);
                    t.hasPositions && !n.position && (n.position = f.createBuffer()), t.hasNormals && !n.normal && (n.normal = f.createBuffer()), t.hasUvs && !n.uv && (n.uv = f.createBuffer()), t.hasColors && !n.color && (n.color = f.createBuffer());
                    var r = e.getAttributes();
                    t.hasPositions && (f.bindBuffer(34962, n.position), f.bufferData(34962, t.positionArray, 35048), y.enableAttribute(r.position), f.vertexAttribPointer(r.position, 3, 5126, !1, 0, 0)), t.hasNormals && (f.bindBuffer(34962, n.normal), f.bufferData(34962, t.normalArray, 35048), y.enableAttribute(r.normal), f.vertexAttribPointer(r.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (f.bindBuffer(34962, n.uv), f.bufferData(34962, t.uvArray, 35048), y.enableAttribute(r.uv), f.vertexAttribPointer(r.uv, 2, 5126, !1, 0, 0)), t.hasColors && (f.bindBuffer(34962, n.color), f.bufferData(34962, t.colorArray, 35048), y.enableAttribute(r.color), f.vertexAttribPointer(r.color, 3, 5126, !1, 0, 0)), y.disableUnusedAttributes(), f.drawArrays(4, 0, t.count), t.count = 0
                }, this.renderBufferDirect = function(t, e, n, r, i, o) {
                    var a = i.isMesh && i.matrixWorld.determinant() < 0;
                    y.setMaterial(r, a);
                    var s = _t(t, e, r, i),
                        c = !1;
                    H.geometry === n.id && H.program === s.id && H.wireframe === (!0 === r.wireframe) || (H.geometry = n.id, H.program = s.id, H.wireframe = !0 === r.wireframe, c = !0), i.morphTargetInfluences && (C.update(i, n, r, s), c = !0);
                    var u, l = n.index,
                        h = n.attributes.position,
                        p = 1;
                    !0 === r.wireframe && (l = M.getWireframeAttribute(n), p = 2);
                    var d = R;
                    null !== l && (u = _.get(l), (d = P).setIndex(u)), c && (mt(r, s, n), null !== l && f.bindBuffer(34963, u.buffer));
                    var m = 1 / 0;
                    null !== l ? m = l.count : void 0 !== h && (m = h.count);
                    var v = n.drawRange.start * p,
                        g = n.drawRange.count * p,
                        x = null !== o ? o.start * p : 0,
                        b = null !== o ? o.count * p : 1 / 0,
                        w = Math.max(v, x),
                        E = Math.min(m, v + g, x + b) - 1,
                        S = Math.max(0, E - w + 1);
                    if (0 !== S) {
                        if (i.isMesh)
                            if (!0 === r.wireframe) y.setLineWidth(r.wireframeLinewidth * at()), d.setMode(1);
                            else switch (i.drawMode) {
                                case Se:
                                    d.setMode(4);
                                    break;
                                case Te:
                                    d.setMode(5);
                                    break;
                                case Ae:
                                    d.setMode(6)
                            } else if (i.isLine) {
                                var T = r.linewidth;
                                void 0 === T && (T = 1), y.setLineWidth(T * at()), i.isLineSegments ? d.setMode(1) : i.isLineLoop ? d.setMode(2) : d.setMode(3)
                            } else i.isPoints ? d.setMode(0) : i.isSprite && d.setMode(4);
                        n && n.isInstancedBufferGeometry ? n.maxInstancedCount > 0 && d.renderInstances(n, w, S) : d.render(w, S)
                    }
                }, this.compile = function(t, e) {
                    (d = A.get(t, e)).init(), t.traverse(function(t) {
                        t.isLight && (d.pushLight(t), t.castShadow && d.pushShadow(t))
                    }), d.setupLights(e), t.traverse(function(e) {
                        if (e.material)
                            if (Array.isArray(e.material))
                                for (var n = 0; n < e.material.length; n++) wt(e.material[n], t.fog, e);
                            else wt(e.material, t.fog, e)
                    })
                };
                var vt = null;
                var gt = new tr;

                function yt(t, e, n, r) {
                    if (!1 !== t.visible) {
                        if (t.layers.test(e.layers))
                            if (t.isGroup) n = t.renderOrder;
                            else if (t.isLOD) !0 === t.autoUpdate && t.update(e);
                        else if (t.isLight) d.pushLight(t), t.castShadow && d.pushShadow(t);
                        else if (t.isSprite) {
                            if (!t.frustumCulled || $.intersectsSprite(t)) {
                                r && ot.setFromMatrixPosition(t.matrixWorld).applyMatrix4(rt);
                                var i = E.update(t),
                                    o = t.material;
                                o.visible && p.push(t, i, o, n, ot.z, null)
                            }
                        } else if (t.isImmediateRenderObject) r && ot.setFromMatrixPosition(t.matrixWorld).applyMatrix4(rt), p.push(t, null, t.material, n, ot.z, null);
                        else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || $.intersectsObject(t)))
                            if (r && ot.setFromMatrixPosition(t.matrixWorld).applyMatrix4(rt), i = E.update(t), o = t.material, Array.isArray(o))
                                for (var a = i.groups, s = 0, c = a.length; s < c; s++) {
                                    var u = a[s],
                                        l = o[u.materialIndex];
                                    l && l.visible && p.push(t, i, l, n, ot.z, u)
                                } else o.visible && p.push(t, i, o, n, ot.z, null);
                        var h = t.children;
                        for (s = 0, c = h.length; s < c; s++) yt(h[s], e, n, r)
                    }
                }

                function xt(t, e, n, r) {
                    for (var i = 0, o = t.length; i < o; i++) {
                        var a = t[i],
                            s = a.object,
                            c = a.geometry,
                            u = void 0 === r ? a.material : r,
                            l = a.group;
                        if (n.isArrayCamera) {
                            j = n;
                            for (var h = n.cameras, p = 0, f = h.length; p < f; p++) {
                                var m = h[p];
                                s.layers.test(m.layers) && (y.viewport(V.copy(m.viewport)), d.setupLights(m), bt(s, e, m, c, u, l))
                            }
                        } else j = null, bt(s, e, n, c, u, l)
                    }
                }

                function bt(t, e, n, r, i, o) {
                    if (t.onBeforeRender(I, e, n, r, i, o), d = A.get(e, j || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                        y.setMaterial(i);
                        var a = _t(n, e.fog, i, t);
                        H.geometry = null, H.program = null, H.wireframe = !1,
                            function(t, e) {
                                t.render(function(t) {
                                    I.renderBufferImmediate(t, e)
                                })
                            }(t, a)
                    } else I.renderBufferDirect(n, e.fog, r, i, t, o);
                    t.onAfterRender(I, e, n, r, i, o), d = A.get(e, j || n)
                }

                function wt(t, e, n) {
                    var r = b.get(t),
                        i = d.state.lights,
                        o = d.state.shadowsArray,
                        a = i.state.version,
                        s = S.getParameters(t, i.state, o, e, tt.numPlanes, tt.numIntersection, n),
                        c = S.getProgramCode(t, s),
                        u = r.program,
                        l = !0;
                    if (void 0 === u) t.addEventListener("dispose", dt);
                    else if (u.code !== c) ft(t);
                    else if (r.lightsStateVersion !== a) r.lightsStateVersion = a, l = !1;
                    else {
                        if (void 0 !== s.shaderID) return;
                        l = !1
                    }
                    if (l) {
                        if (s.shaderID) {
                            var h = $n[s.shaderID];
                            r.shader = {
                                name: t.type,
                                uniforms: Fn(h.uniforms),
                                vertexShader: h.vertexShader,
                                fragmentShader: h.fragmentShader
                            }
                        } else r.shader = {
                            name: t.type,
                            uniforms: t.uniforms,
                            vertexShader: t.vertexShader,
                            fragmentShader: t.fragmentShader
                        };
                        t.onBeforeCompile(r.shader, I), c = S.getProgramCode(t, s), u = S.acquireProgram(t, r.shader, s, c), r.program = u, t.program = u
                    }
                    var p = u.getAttributes();
                    if (t.morphTargets) {
                        t.numSupportedMorphTargets = 0;
                        for (var f = 0; f < I.maxMorphTargets; f++) p["morphTarget" + f] >= 0 && t.numSupportedMorphTargets++
                    }
                    if (t.morphNormals)
                        for (t.numSupportedMorphNormals = 0, f = 0; f < I.maxMorphNormals; f++) p["morphNormal" + f] >= 0 && t.numSupportedMorphNormals++;
                    var m = r.shader.uniforms;
                    (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (r.numClippingPlanes = tt.numPlanes, r.numIntersection = tt.numIntersection, m.clippingPlanes = tt.uniform), r.fog = e, r.lightsStateVersion = a, t.lights && (m.ambientLightColor.value = i.state.ambient, m.lightProbe.value = i.state.probe, m.directionalLights.value = i.state.directional, m.spotLights.value = i.state.spot, m.rectAreaLights.value = i.state.rectArea, m.pointLights.value = i.state.point, m.hemisphereLights.value = i.state.hemi, m.directionalShadowMap.value = i.state.directionalShadowMap, m.directionalShadowMatrix.value = i.state.directionalShadowMatrix, m.spotShadowMap.value = i.state.spotShadowMap, m.spotShadowMatrix.value = i.state.spotShadowMatrix, m.pointShadowMap.value = i.state.pointShadowMap, m.pointShadowMatrix.value = i.state.pointShadowMatrix);
                    var v = r.program.getUniforms(),
                        g = hi.seqWithValue(v.seq, m);
                    r.uniformsList = g
                }

                function _t(t, e, n, r) {
                    w.resetTextureUnits();
                    var i = b.get(n),
                        o = d.state.lights;
                    if (et && (nt || t !== U)) {
                        var a = t === U && n.id === G;
                        tt.setState(n.clippingPlanes, n.clipIntersection, n.clipShadows, t, i, a)
                    }!1 === n.needsUpdate && (void 0 === i.program ? n.needsUpdate = !0 : n.fog && i.fog !== e ? n.needsUpdate = !0 : n.lights && i.lightsStateVersion !== o.state.version ? n.needsUpdate = !0 : void 0 === i.numClippingPlanes || i.numClippingPlanes === tt.numPlanes && i.numIntersection === tt.numIntersection || (n.needsUpdate = !0)), n.needsUpdate && (wt(n, e, r), n.needsUpdate = !1);
                    var s = !1,
                        c = !1,
                        u = !1,
                        l = i.program,
                        h = l.getUniforms(),
                        p = i.shader.uniforms;
                    if (y.useProgram(l.program) && (s = !0, c = !0, u = !0), n.id !== G && (G = n.id, c = !0), s || U !== t) {
                        if (h.setValue(f, "projectionMatrix", t.projectionMatrix), v.logarithmicDepthBuffer && h.setValue(f, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), U !== t && (U = t, c = !0, u = !0), n.isShaderMaterial || n.isMeshPhongMaterial || n.isMeshStandardMaterial || n.envMap) {
                            var m = h.map.cameraPosition;
                            void 0 !== m && m.setValue(f, ot.setFromMatrixPosition(t.matrixWorld))
                        }(n.isMeshPhongMaterial || n.isMeshLambertMaterial || n.isMeshBasicMaterial || n.isMeshStandardMaterial || n.isShaderMaterial || n.skinning) && h.setValue(f, "viewMatrix", t.matrixWorldInverse)
                    }
                    if (n.skinning) {
                        h.setOptional(f, r, "bindMatrix"), h.setOptional(f, r, "bindMatrixInverse");
                        var g = r.skeleton;
                        if (g) {
                            var x = g.bones;
                            if (v.floatVertexTextures) {
                                if (void 0 === g.boneTexture) {
                                    var _ = Math.sqrt(4 * x.length);
                                    _ = Ge.ceilPowerOfTwo(_), _ = Math.max(_, 4);
                                    var M = new Float32Array(_ * _ * 4);
                                    M.set(g.boneMatrices);
                                    var E = new Yn(M, _, _, Gt, Ot);
                                    E.needsUpdate = !0, g.boneMatrices = M, g.boneTexture = E, g.boneTextureSize = _
                                }
                                h.setValue(f, "boneTexture", g.boneTexture, w), h.setValue(f, "boneTextureSize", g.boneTextureSize)
                            } else h.setOptional(f, g, "boneMatrices")
                        }
                    }
                    return c && (h.setValue(f, "toneMappingExposure", I.toneMappingExposure), h.setValue(f, "toneMappingWhitePoint", I.toneMappingWhitePoint), n.lights && function(t, e) {
                        t.ambientLightColor.needsUpdate = e, t.lightProbe.needsUpdate = e, t.directionalLights.needsUpdate = e, t.pointLights.needsUpdate = e, t.spotLights.needsUpdate = e, t.rectAreaLights.needsUpdate = e, t.hemisphereLights.needsUpdate = e
                    }(p, u), e && n.fog && function(t, e) {
                        t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
                    }(p, e), n.isMeshBasicMaterial ? Mt(p, n) : n.isMeshLambertMaterial ? (Mt(p, n), function(t, e) {
                        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
                    }(p, n)) : n.isMeshPhongMaterial ? (Mt(p, n), n.isMeshToonMaterial ? function(t, e) {
                        Et(t, e), e.gradientMap && (t.gradientMap.value = e.gradientMap)
                    }(p, n) : Et(p, n)) : n.isMeshStandardMaterial ? (Mt(p, n), n.isMeshPhysicalMaterial ? function(t, e) {
                        St(t, e), t.reflectivity.value = e.reflectivity, t.clearCoat.value = e.clearCoat, t.clearCoatRoughness.value = e.clearCoatRoughness
                    }(p, n) : St(p, n)) : n.isMeshMatcapMaterial ? (Mt(p, n), At(p, n)) : n.isMeshDepthMaterial ? (Mt(p, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                    }(p, n)) : n.isMeshDistanceMaterial ? (Mt(p, n), function(t, e) {
                        e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
                    }(p, n)) : n.isMeshNormalMaterial ? (Mt(p, n), Lt(p, n)) : n.isLineBasicMaterial ? (function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
                    }(p, n), n.isLineDashedMaterial && function(t, e) {
                        t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
                    }(p, n)) : n.isPointsMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * J, t.scale.value = .5 * Y, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(p, n) : n.isSpriteMaterial ? function(t, e) {
                        t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, t.map.value = e.map, null !== e.map && (!0 === e.map.matrixAutoUpdate && e.map.updateMatrix(), t.uvTransform.value.copy(e.map.matrix))
                    }(p, n) : n.isShadowMaterial && (p.color.value.copy(n.color), p.opacity.value = n.opacity), void 0 !== p.ltc_1 && (p.ltc_1.value = Kn.LTC_1), void 0 !== p.ltc_2 && (p.ltc_2.value = Kn.LTC_2), hi.upload(f, i.uniformsList, p, w)), n.isShaderMaterial && !0 === n.uniformsNeedUpdate && (hi.upload(f, i.uniformsList, p, w), n.uniformsNeedUpdate = !1), n.isSpriteMaterial && h.setValue(f, "center", r.center), h.setValue(f, "modelViewMatrix", r.modelViewMatrix), h.setValue(f, "normalMatrix", r.normalMatrix), h.setValue(f, "modelMatrix", r.matrixWorld), l
                }

                function Mt(t, e) {
                    var n;
                    t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = b.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map ? n = e.map : e.specularMap ? n = e.specularMap : e.displacementMap ? n = e.displacementMap : e.normalMap ? n = e.normalMap : e.bumpMap ? n = e.bumpMap : e.roughnessMap ? n = e.roughnessMap : e.metalnessMap ? n = e.metalnessMap : e.alphaMap ? n = e.alphaMap : e.emissiveMap && (n = e.emissiveMap), void 0 !== n && (n.isWebGLRenderTarget && (n = n.texture), !0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
                }

                function Et(t, e) {
                    t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === g && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === g && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function St(t, e) {
                    t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === g && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === g && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
                }

                function At(t, e) {
                    e.matcap && (t.matcap.value = e.matcap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === g && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === g && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }

                function Lt(t, e) {
                    e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === g && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === g && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
                }
                gt.setAnimationLoop(function(t) {
                    ut.isPresenting() || vt && vt(t)
                }), "undefined" != typeof window && gt.setContext(window), this.setAnimationLoop = function(t) {
                    vt = t, ut.setAnimationLoop(t), gt.start()
                }, this.render = function(t, e) {
                    var n, r;
                    if (void 0 !== arguments[2] && (console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."), n = arguments[2]), void 0 !== arguments[3] && (console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."), r = arguments[3]), e && e.isCamera) {
                        if (!B) {
                            H.geometry = null, H.program = null, H.wireframe = !1, G = -1, U = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), ut.enabled && (e = ut.getCamera(e)), (d = A.get(t, e)).init(), t.onBeforeRender(I, t, e, n || N), rt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), $.setFromMatrix(rt), nt = this.localClippingEnabled, et = tt.init(this.clippingPlanes, nt, e), (p = T.get(t, e)).init(), yt(t, e, 0, I.sortObjects), !0 === I.sortObjects && p.sort(), et && tt.beginShadows();
                            var i = d.state.shadowsArray;
                            lt.render(i, t, e), d.setupLights(e), et && tt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== n && this.setRenderTarget(n), L.render(p, t, e, r);
                            var o = p.opaque,
                                a = p.transparent;
                            if (t.overrideMaterial) {
                                var s = t.overrideMaterial;
                                o.length && xt(o, t, e, s), a.length && xt(a, t, e, s)
                            } else o.length && xt(o, t, e), a.length && xt(a, t, e);
                            t.onAfterRender(I, t, e), null !== N && (w.updateRenderTargetMipmap(N), w.updateMultisampleRenderTarget(N)), y.buffers.depth.setTest(!0), y.buffers.depth.setMask(!0), y.buffers.color.setMask(!0), y.setPolygonOffset(!1), ut.enabled && ut.submitFrame(), p = null, d = null
                        }
                    } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
                }, this.setFramebuffer = function(t) {
                    D !== t && f.bindFramebuffer(36160, t), D = t
                }, this.getActiveCubeFace = function() {
                    return F
                }, this.getActiveMipMapLevel = function() {
                    return k
                }, this.getRenderTarget = function() {
                    return N
                }, this.setRenderTarget = function(t, e, n) {
                    N = t, F = e, k = n, t && void 0 === b.get(t).__webglFramebuffer && w.setupRenderTarget(t);
                    var r = D,
                        i = !1;
                    if (t) {
                        var o = b.get(t).__webglFramebuffer;
                        t.isWebGLRenderTargetCube ? (r = o[e || 0], i = !0) : r = t.isWebGLMultisampleRenderTarget ? b.get(t).__webglMultisampledFramebuffer : o, V.copy(t.viewport), W.copy(t.scissor), q = t.scissorTest
                    } else V.copy(Z).multiplyScalar(J).floor(), W.copy(Q).multiplyScalar(J).floor(), q = K;
                    if (z !== r && (f.bindFramebuffer(36160, r), z = r), y.viewport(V), y.scissor(W), y.setScissorTest(q), i) {
                        var a = b.get(t.texture);
                        f.framebufferTexture2D(36160, 36064, 34069 + (e || 0), a.__webglTexture, n || 0)
                    }
                }, this.readRenderTargetPixels = function(t, e, n, r, i, o, a) {
                    if (t && t.isWebGLRenderTarget) {
                        var s = b.get(t).__webglFramebuffer;
                        if (t.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) {
                            var c = !1;
                            s !== z && (f.bindFramebuffer(36160, s), c = !0);
                            try {
                                var u = t.texture,
                                    l = u.format,
                                    h = u.type;
                                if (l !== Gt && O.convert(l) !== f.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                                if (!(h === Tt || O.convert(h) === f.getParameter(35738) || h === Ot && (v.isWebGL2 || m.get("OES_texture_float") || m.get("WEBGL_color_buffer_float")) || h === It && (v.isWebGL2 ? m.get("EXT_color_buffer_float") : m.get("EXT_color_buffer_half_float")))) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                                36053 === f.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - i && f.readPixels(e, n, r, i, O.convert(l), O.convert(h), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
                            } finally {
                                c && f.bindFramebuffer(36160, z)
                            }
                        }
                    } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
                }, this.copyFramebufferToTexture = function(t, e, n) {
                    var r = e.image.width,
                        i = e.image.height,
                        o = O.convert(e.format);
                    w.setTexture2D(e, 0), f.copyTexImage2D(3553, n || 0, o, t.x, t.y, r, i, 0)
                }, this.copyTextureToTexture = function(t, e, n, r) {
                    var i = e.image.width,
                        o = e.image.height,
                        a = O.convert(n.format),
                        s = O.convert(n.type);
                    w.setTexture2D(n, 0), e.isDataTexture ? f.texSubImage2D(3553, r || 0, t.x, t.y, i, o, a, s, e.image.data) : f.texSubImage2D(3553, r || 0, t.x, t.y, a, s, e.image)
                }, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
                    detail: this
                }))
            }

            function Qi(t, e) {
                this.name = "", this.color = new un(t), this.density = void 0 !== e ? e : 25e-5
            }

            function Ki(t, e, n) {
                this.name = "", this.color = new un(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== n ? n : 1e3
            }

            function $i(t, e) {
                this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
                    offset: 0,
                    count: -1
                }, this.version = 0
            }

            function to(t, e, n, r) {
                this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
            }

            function eo(t) {
                mn.call(this), this.type = "SpriteMaterial", this.color = new un(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
            }

            function no(t) {
                if (en.call(this), this.type = "Sprite", void 0 === Vi) {
                    Vi = new Rn;
                    var e = new $i(new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]), 5);
                    Vi.setIndex([0, 1, 2, 0, 2, 3]), Vi.addAttribute("position", new to(e, 3, 0, !1)), Vi.addAttribute("uv", new to(e, 2, 3, !1))
                }
                this.geometry = Vi, this.material = void 0 !== t ? t : new eo, this.center = new He(.5, .5)
            }

            function ro() {
                en.call(this), this.type = "LOD", Object.defineProperties(this, {
                    levels: {
                        enumerable: !0,
                        value: []
                    }
                }), this.autoUpdate = !0
            }

            function io(t, e) {
                t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Pn.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Qe, this.bindMatrixInverse = new Qe
            }

            function oo(t, e) {
                if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses();
                else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
                else {
                    console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [];
                    for (var n = 0, r = this.bones.length; n < r; n++) this.boneInverses.push(new Qe)
                }
            }

            function ao() {
                en.call(this), this.type = "Bone"
            }

            function so(t) {
                mn.call(this), this.type = "LineBasicMaterial", this.color = new un(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.lights = !1, this.setValues(t)
            }

            function co(t, e, n) {
                1 === n && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), en.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new Rn, this.material = void 0 !== e ? e : new so({
                    color: 16777215 * Math.random()
                })
            }

            function uo(t, e) {
                co.call(this, t, e), this.type = "LineSegments"
            }

            function lo(t, e) {
                co.call(this, t, e), this.type = "LineLoop"
            }

            function ho(t) {
                mn.call(this), this.type = "PointsMaterial", this.color = new un(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.morphTargets = !1, this.lights = !1, this.setValues(t)
            }

            function po(t, e) {
                en.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new Rn, this.material = void 0 !== e ? e : new ho({
                    color: 16777215 * Math.random()
                }), this.updateMorphTargets()
            }

            function fo(t, e, n, r, i, o, a, s, c) {
                Xe.call(this, t, e, n, r, i, o, a, s, c), this.format = void 0 !== a ? a : zt, this.minFilter = void 0 !== o ? o : Mt, this.magFilter = void 0 !== i ? i : Mt, this.generateMipmaps = !1
            }

            function mo(t, e, n, r, i, o, a, s, c, u, l, h) {
                Xe.call(this, null, o, a, s, c, u, r, i, l, h), this.image = {
                    width: e,
                    height: n
                }, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
            }

            function vo(t, e, n, r, i, o, a, s, c) {
                Xe.call(this, t, e, n, r, i, o, a, s, c), this.needsUpdate = !0
            }

            function go(t, e, n, r, i, o, a, s, c, u) {
                if ((u = void 0 !== u ? u : Vt) !== Vt && u !== Wt) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
                void 0 === n && u === Vt && (n = Ct), void 0 === n && u === Wt && (n = kt), Xe.call(this, null, r, i, o, a, s, u, n, c), this.image = {
                    width: t,
                    height: e
                }, this.magFilter = void 0 !== a ? a : bt, this.minFilter = void 0 !== s ? s : bt, this.flipY = !1, this.generateMipmaps = !1
            }

            function yo(t) {
                Rn.call(this), this.type = "WireframeGeometry";
                var e, n, r, i, o, a, s, c, u, l, h = [],
                    p = [0, 0],
                    d = {},
                    f = ["a", "b", "c"];
                if (t && t.isGeometry) {
                    var m = t.faces;
                    for (e = 0, r = m.length; e < r; e++) {
                        var v = m[e];
                        for (n = 0; n < 3; n++) s = v[f[n]], c = v[f[(n + 1) % 3]], p[0] = Math.min(s, c), p[1] = Math.max(s, c), void 0 === d[u = p[0] + "," + p[1]] && (d[u] = {
                            index1: p[0],
                            index2: p[1]
                        })
                    }
                    for (u in d) a = d[u], l = t.vertices[a.index1], h.push(l.x, l.y, l.z), l = t.vertices[a.index2], h.push(l.x, l.y, l.z)
                } else if (t && t.isBufferGeometry) {
                    var g, y, x, b, w, _, M;
                    if (l = new je, null !== t.index) {
                        for (g = t.attributes.position, y = t.index, 0 === (x = t.groups).length && (x = [{
                                start: 0,
                                count: y.count,
                                materialIndex: 0
                            }]), i = 0, o = x.length; i < o; ++i)
                            for (e = w = (b = x[i]).start, r = w + b.count; e < r; e += 3)
                                for (n = 0; n < 3; n++) s = y.getX(e + n), c = y.getX(e + (n + 1) % 3), p[0] = Math.min(s, c), p[1] = Math.max(s, c), void 0 === d[u = p[0] + "," + p[1]] && (d[u] = {
                                    index1: p[0],
                                    index2: p[1]
                                });
                        for (u in d) a = d[u], l.fromBufferAttribute(g, a.index1), h.push(l.x, l.y, l.z), l.fromBufferAttribute(g, a.index2), h.push(l.x, l.y, l.z)
                    } else
                        for (e = 0, r = (g = t.attributes.position).count / 3; e < r; e++)
                            for (n = 0; n < 3; n++) _ = 3 * e + n, l.fromBufferAttribute(g, _), h.push(l.x, l.y, l.z), M = 3 * e + (n + 1) % 3, l.fromBufferAttribute(g, M), h.push(l.x, l.y, l.z)
                }
                this.addAttribute("position", new Sn(h, 3))
            }

            function xo(t, e, n) {
                In.call(this), this.type = "ParametricGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                }, this.fromBufferGeometry(new bo(t, e, n)), this.mergeVertices()
            }

            function bo(t, e, n) {
                Rn.call(this), this.type = "ParametricBufferGeometry", this.parameters = {
                    func: t,
                    slices: e,
                    stacks: n
                };
                var r, i, o = [],
                    a = [],
                    s = [],
                    c = [],
                    u = 1e-5,
                    l = new je,
                    h = new je,
                    p = new je,
                    d = new je,
                    f = new je;
                t.length < 3 && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
                var m = e + 1;
                for (r = 0; r <= n; r++) {
                    var v = r / n;
                    for (i = 0; i <= e; i++) {
                        var g = i / e;
                        t(g, v, h), a.push(h.x, h.y, h.z), g - u >= 0 ? (t(g - u, v, p), d.subVectors(h, p)) : (t(g + u, v, p), d.subVectors(p, h)), v - u >= 0 ? (t(g, v - u, p), f.subVectors(h, p)) : (t(g, v + u, p), f.subVectors(p, h)), l.crossVectors(d, f).normalize(), s.push(l.x, l.y, l.z), c.push(g, v)
                    }
                }
                for (r = 0; r < n; r++)
                    for (i = 0; i < e; i++) {
                        var y = r * m + i,
                            x = r * m + i + 1,
                            b = (r + 1) * m + i + 1,
                            w = (r + 1) * m + i;
                        o.push(y, x, w), o.push(x, b, w)
                    }
                this.setIndex(o), this.addAttribute("position", new Sn(a, 3)), this.addAttribute("normal", new Sn(s, 3)), this.addAttribute("uv", new Sn(c, 2))
            }

            function wo(t, e, n, r) {
                In.call(this), this.type = "PolyhedronGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: r
                }, this.fromBufferGeometry(new _o(t, e, n, r)), this.mergeVertices()
            }

            function _o(t, e, n, r) {
                Rn.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
                    vertices: t,
                    indices: e,
                    radius: n,
                    detail: r
                }, n = n || 1;
                var i = [],
                    o = [];

                function a(t, e, n, r) {
                    var i, o, a = Math.pow(2, r),
                        c = [];
                    for (i = 0; i <= a; i++) {
                        c[i] = [];
                        var u = t.clone().lerp(n, i / a),
                            l = e.clone().lerp(n, i / a),
                            h = a - i;
                        for (o = 0; o <= h; o++) c[i][o] = 0 === o && i === a ? u : u.clone().lerp(l, o / h)
                    }
                    for (i = 0; i < a; i++)
                        for (o = 0; o < 2 * (a - i) - 1; o++) {
                            var p = Math.floor(o / 2);
                            o % 2 == 0 ? (s(c[i][p + 1]), s(c[i + 1][p]), s(c[i][p])) : (s(c[i][p + 1]), s(c[i + 1][p + 1]), s(c[i + 1][p]))
                        }
                }

                function s(t) {
                    i.push(t.x, t.y, t.z)
                }

                function c(e, n) {
                    var r = 3 * e;
                    n.x = t[r + 0], n.y = t[r + 1], n.z = t[r + 2]
                }

                function u(t, e, n, r) {
                    r < 0 && 1 === t.x && (o[e] = t.x - 1), 0 === n.x && 0 === n.z && (o[e] = r / 2 / Math.PI + .5)
                }

                function l(t) {
                    return Math.atan2(t.z, -t.x)
                }

                function h(t) {
                    return Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z))
                }(function(t) {
                    for (var n = new je, r = new je, i = new je, o = 0; o < e.length; o += 3) c(e[o + 0], n), c(e[o + 1], r), c(e[o + 2], i), a(n, r, i, t)
                })(r = r || 0),
                function(t) {
                    for (var e = new je, n = 0; n < i.length; n += 3) e.x = i[n + 0], e.y = i[n + 1], e.z = i[n + 2], e.normalize().multiplyScalar(t), i[n + 0] = e.x, i[n + 1] = e.y, i[n + 2] = e.z
                }(n),
                function() {
                    for (var t = new je, e = 0; e < i.length; e += 3) {
                        t.x = i[e + 0], t.y = i[e + 1], t.z = i[e + 2];
                        var n = l(t) / 2 / Math.PI + .5,
                            r = h(t) / Math.PI + .5;
                        o.push(n, 1 - r)
                    }(function() {
                        for (var t = new je, e = new je, n = new je, r = new je, a = new He, s = new He, c = new He, h = 0, p = 0; h < i.length; h += 9, p += 6) {
                            t.set(i[h + 0], i[h + 1], i[h + 2]), e.set(i[h + 3], i[h + 4], i[h + 5]), n.set(i[h + 6], i[h + 7], i[h + 8]), a.set(o[p + 0], o[p + 1]), s.set(o[p + 2], o[p + 3]), c.set(o[p + 4], o[p + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                            var d = l(r);
                            u(a, p + 0, t, d), u(s, p + 2, e, d), u(c, p + 4, n, d)
                        }
                    })(),
                    function() {
                        for (var t = 0; t < o.length; t += 6) {
                            var e = o[t + 0],
                                n = o[t + 2],
                                r = o[t + 4],
                                i = Math.max(e, n, r),
                                a = Math.min(e, n, r);
                            i > .9 && a < .1 && (e < .2 && (o[t + 0] += 1), n < .2 && (o[t + 2] += 1), r < .2 && (o[t + 4] += 1))
                        }
                    }()
                }(), this.addAttribute("position", new Sn(i, 3)), this.addAttribute("normal", new Sn(i.slice(), 3)), this.addAttribute("uv", new Sn(o, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
            }

            function Mo(t, e) {
                In.call(this), this.type = "TetrahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Eo(t, e)), this.mergeVertices()
            }

            function Eo(t, e) {
                _o.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function So(t, e) {
                In.call(this), this.type = "OctahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new To(t, e)), this.mergeVertices()
            }

            function To(t, e) {
                _o.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Ao(t, e) {
                In.call(this), this.type = "IcosahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Lo(t, e)), this.mergeVertices()
            }

            function Lo(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1];
                _o.call(this, r, [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Co(t, e) {
                In.call(this), this.type = "DodecahedronGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }, this.fromBufferGeometry(new Ro(t, e)), this.mergeVertices()
            }

            function Ro(t, e) {
                var n = (1 + Math.sqrt(5)) / 2,
                    r = 1 / n,
                    i = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r];
                _o.call(this, i, [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
                    radius: t,
                    detail: e
                }
            }

            function Po(t, e, n, r, i, o) {
                In.call(this), this.type = "TubeGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: r,
                    closed: i
                }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed.");
                var a = new Oo(t, e, n, r, i);
                this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals, this.fromBufferGeometry(a), this.mergeVertices()
            }

            function Oo(t, e, n, r, i) {
                Rn.call(this), this.type = "TubeBufferGeometry", this.parameters = {
                    path: t,
                    tubularSegments: e,
                    radius: n,
                    radialSegments: r,
                    closed: i
                }, e = e || 64, n = n || 1, r = r || 8, i = i || !1;
                var o = t.computeFrenetFrames(e, i);
                this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
                var a, s, c = new je,
                    u = new je,
                    l = new He,
                    h = new je,
                    p = [],
                    d = [],
                    f = [],
                    m = [];

                function v(i) {
                    h = t.getPointAt(i / e, h);
                    var a = o.normals[i],
                        l = o.binormals[i];
                    for (s = 0; s <= r; s++) {
                        var f = s / r * Math.PI * 2,
                            m = Math.sin(f),
                            v = -Math.cos(f);
                        u.x = v * a.x + m * l.x, u.y = v * a.y + m * l.y, u.z = v * a.z + m * l.z, u.normalize(), d.push(u.x, u.y, u.z), c.x = h.x + n * u.x, c.y = h.y + n * u.y, c.z = h.z + n * u.z, p.push(c.x, c.y, c.z)
                    }
                }(function() {
                    for (a = 0; a < e; a++) v(a);
                    v(!1 === i ? e : 0),
                        function() {
                            for (a = 0; a <= e; a++)
                                for (s = 0; s <= r; s++) l.x = a / e, l.y = s / r, f.push(l.x, l.y)
                        }(),
                        function() {
                            for (s = 1; s <= e; s++)
                                for (a = 1; a <= r; a++) {
                                    var t = (r + 1) * (s - 1) + (a - 1),
                                        n = (r + 1) * s + (a - 1),
                                        i = (r + 1) * s + a,
                                        o = (r + 1) * (s - 1) + a;
                                    m.push(t, n, o), m.push(n, i, o)
                                }
                        }()
                })(), this.setIndex(m), this.addAttribute("position", new Sn(p, 3)), this.addAttribute("normal", new Sn(d, 3)), this.addAttribute("uv", new Sn(f, 2))
            }

            function Io(t, e, n, r, i, o, a) {
                In.call(this), this.type = "TorusKnotGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new Bo(t, e, n, r, i, o)), this.mergeVertices()
            }

            function Bo(t, e, n, r, i, o) {
                Rn.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    tubularSegments: n,
                    radialSegments: r,
                    p: i,
                    q: o
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 64, r = Math.floor(r) || 8, i = i || 2, o = o || 3;
                var a, s, c = [],
                    u = [],
                    l = [],
                    h = [],
                    p = new je,
                    d = new je,
                    f = new je,
                    m = new je,
                    v = new je,
                    g = new je,
                    y = new je;
                for (a = 0; a <= n; ++a) {
                    var x = a / n * i * Math.PI * 2;
                    for (A(x, i, o, t, f), A(x + .01, i, o, t, m), g.subVectors(m, f), y.addVectors(m, f), v.crossVectors(g, y), y.crossVectors(v, g), v.normalize(), y.normalize(), s = 0; s <= r; ++s) {
                        var b = s / r * Math.PI * 2,
                            w = -e * Math.cos(b),
                            _ = e * Math.sin(b);
                        p.x = f.x + (w * y.x + _ * v.x), p.y = f.y + (w * y.y + _ * v.y), p.z = f.z + (w * y.z + _ * v.z), u.push(p.x, p.y, p.z), d.subVectors(p, f).normalize(), l.push(d.x, d.y, d.z), h.push(a / n), h.push(s / r)
                    }
                }
                for (s = 1; s <= n; s++)
                    for (a = 1; a <= r; a++) {
                        var M = (r + 1) * (s - 1) + (a - 1),
                            E = (r + 1) * s + (a - 1),
                            S = (r + 1) * s + a,
                            T = (r + 1) * (s - 1) + a;
                        c.push(M, E, T), c.push(E, S, T)
                    }

                function A(t, e, n, r, i) {
                    var o = Math.cos(t),
                        a = Math.sin(t),
                        s = n / e * t,
                        c = Math.cos(s);
                    i.x = r * (2 + c) * .5 * o, i.y = r * (2 + c) * a * .5, i.z = r * Math.sin(s) * .5
                }
                this.setIndex(c), this.addAttribute("position", new Sn(u, 3)), this.addAttribute("normal", new Sn(l, 3)), this.addAttribute("uv", new Sn(h, 2))
            }

            function Do(t, e, n, r, i) {
                In.call(this), this.type = "TorusGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, this.fromBufferGeometry(new Fo(t, e, n, r, i)), this.mergeVertices()
            }

            function Fo(t, e, n, r, i) {
                Rn.call(this), this.type = "TorusBufferGeometry", this.parameters = {
                    radius: t,
                    tube: e,
                    radialSegments: n,
                    tubularSegments: r,
                    arc: i
                }, t = t || 1, e = e || .4, n = Math.floor(n) || 8, r = Math.floor(r) || 6, i = i || 2 * Math.PI;
                var o, a, s = [],
                    c = [],
                    u = [],
                    l = [],
                    h = new je,
                    p = new je,
                    d = new je;
                for (o = 0; o <= n; o++)
                    for (a = 0; a <= r; a++) {
                        var f = a / r * i,
                            m = o / n * Math.PI * 2;
                        p.x = (t + e * Math.cos(m)) * Math.cos(f), p.y = (t + e * Math.cos(m)) * Math.sin(f), p.z = e * Math.sin(m), c.push(p.x, p.y, p.z), h.x = t * Math.cos(f), h.y = t * Math.sin(f), d.subVectors(p, h).normalize(), u.push(d.x, d.y, d.z), l.push(a / r), l.push(o / n)
                    }
                for (o = 1; o <= n; o++)
                    for (a = 1; a <= r; a++) {
                        var v = (r + 1) * o + a - 1,
                            g = (r + 1) * (o - 1) + a - 1,
                            y = (r + 1) * (o - 1) + a,
                            x = (r + 1) * o + a;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                this.setIndex(s), this.addAttribute("position", new Sn(c, 3)), this.addAttribute("normal", new Sn(u, 3)), this.addAttribute("uv", new Sn(l, 2))
            }
            Object.assign(Yi.prototype, r.prototype), Object.assign(Ji.prototype, r.prototype), Object.assign(Qi.prototype, {
                isFogExp2: !0,
                clone: function() {
                    return new Qi(this.color, this.density)
                },
                toJSON: function() {
                    return {
                        type: "FogExp2",
                        color: this.color.getHex(),
                        density: this.density
                    }
                }
            }), Object.assign(Ki.prototype, {
                isFog: !0,
                clone: function() {
                    return new Ki(this.color, this.near, this.far)
                },
                toJSON: function() {
                    return {
                        type: "Fog",
                        color: this.color.getHex(),
                        near: this.near,
                        far: this.far
                    }
                }
            }), Object.defineProperty($i.prototype, "needsUpdate", {
                set: function(t) {
                    !0 === t && this.version++
                }
            }), Object.assign($i.prototype, {
                isInterleavedBuffer: !0,
                onUploadCallback: function() {},
                setArray: function(t) {
                    if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
                    return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
                },
                setDynamic: function(t) {
                    return this.dynamic = t, this
                },
                copy: function(t) {
                    return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
                },
                copyAt: function(t, e, n) {
                    t *= this.stride, n *= e.stride;
                    for (var r = 0, i = this.stride; r < i; r++) this.array[t + r] = e.array[n + r];
                    return this
                },
                set: function(t, e) {
                    return void 0 === e && (e = 0), this.array.set(t, e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                onUpload: function(t) {
                    return this.onUploadCallback = t, this
                }
            }), Object.defineProperties(to.prototype, {
                count: {
                    get: function() {
                        return this.data.count
                    }
                },
                array: {
                    get: function() {
                        return this.data.array
                    }
                }
            }), Object.assign(to.prototype, {
                isInterleavedBufferAttribute: !0,
                setX: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset] = e, this
                },
                setY: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 1] = e, this
                },
                setZ: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 2] = e, this
                },
                setW: function(t, e) {
                    return this.data.array[t * this.data.stride + this.offset + 3] = e, this
                },
                getX: function(t) {
                    return this.data.array[t * this.data.stride + this.offset]
                },
                getY: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 1]
                },
                getZ: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 2]
                },
                getW: function(t) {
                    return this.data.array[t * this.data.stride + this.offset + 3]
                },
                setXY: function(t, e, n) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
                },
                setXYZ: function(t, e, n, r) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
                },
                setXYZW: function(t, e, n, r, i) {
                    return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = i, this
                }
            }), eo.prototype = Object.create(mn.prototype), eo.prototype.constructor = eo, eo.prototype.isSpriteMaterial = !0, eo.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
            }, no.prototype = Object.assign(Object.create(en.prototype), {
                constructor: no,
                isSprite: !0,
                raycast: function() {
                    var t = new je,
                        e = new je,
                        n = new je,
                        r = new He,
                        i = new He,
                        o = new Qe,
                        a = new je,
                        s = new je,
                        c = new je,
                        u = new He,
                        l = new He,
                        h = new He;

                    function p(t, e, n, a, s, c) {
                        r.subVectors(t, n).addScalar(.5).multiply(a), void 0 !== s ? (i.x = c * r.x - s * r.y, i.y = s * r.x + c * r.y) : i.copy(r), t.copy(e), t.x += i.x, t.y += i.y, t.applyMatrix4(o)
                    }
                    return function(r, i) {
                        e.setFromMatrixScale(this.matrixWorld), o.copy(r._camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(r._camera.matrixWorldInverse, this.matrixWorld), n.setFromMatrixPosition(this.modelViewMatrix), r._camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && e.multiplyScalar(-n.z);
                        var d, f, m = this.material.rotation;
                        0 !== m && (f = Math.cos(m), d = Math.sin(m));
                        var v = this.center;
                        p(a.set(-.5, -.5, 0), n, v, e, d, f), p(s.set(.5, -.5, 0), n, v, e, d, f), p(c.set(.5, .5, 0), n, v, e, d, f), u.set(0, 0), l.set(1, 0), h.set(1, 1);
                        var g = r.ray.intersectTriangle(a, s, c, !1, t);
                        if (null !== g || (p(s.set(-.5, .5, 0), n, v, e, d, f), l.set(0, 1), null !== (g = r.ray.intersectTriangle(a, c, s, !1, t)))) {
                            var y = r.ray.origin.distanceTo(t);
                            y < r.near || y > r.far || i.push({
                                distance: y,
                                point: t.clone(),
                                uv: sn.getUV(t, a, s, c, u, l, h, new He),
                                face: null,
                                object: this
                            })
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.material).copy(this)
                },
                copy: function(t) {
                    return en.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
                }
            }), ro.prototype = Object.assign(Object.create(en.prototype), {
                constructor: ro,
                isLOD: !0,
                copy: function(t) {
                    en.prototype.copy.call(this, t, !1);
                    for (var e = t.levels, n = 0, r = e.length; n < r; n++) {
                        var i = e[n];
                        this.addLevel(i.object.clone(), i.distance)
                    }
                    return this
                },
                addLevel: function(t, e) {
                    void 0 === e && (e = 0), e = Math.abs(e);
                    for (var n = this.levels, r = 0; r < n.length && !(e < n[r].distance); r++);
                    return n.splice(r, 0, {
                        distance: e,
                        object: t
                    }), this.add(t), this
                },
                getObjectForDistance: function(t) {
                    for (var e = this.levels, n = 1, r = e.length; n < r && !(t < e[n].distance); n++);
                    return e[n - 1].object
                },
                raycast: function() {
                    var t = new je;
                    return function(e, n) {
                        t.setFromMatrixPosition(this.matrixWorld);
                        var r = e.ray.origin.distanceTo(t);
                        this.getObjectForDistance(r).raycast(e, n)
                    }
                }(),
                update: function() {
                    var t = new je,
                        e = new je;
                    return function(n) {
                        var r = this.levels;
                        if (r.length > 1) {
                            t.setFromMatrixPosition(n.matrixWorld), e.setFromMatrixPosition(this.matrixWorld);
                            var i = t.distanceTo(e);
                            r[0].object.visible = !0;
                            for (var o = 1, a = r.length; o < a && i >= r[o].distance; o++) r[o - 1].object.visible = !1, r[o].object.visible = !0;
                            for (; o < a; o++) r[o].object.visible = !1
                        }
                    }
                }(),
                toJSON: function(t) {
                    var e = en.prototype.toJSON.call(this, t);
                    e.object.levels = [];
                    for (var n = this.levels, r = 0, i = n.length; r < i; r++) {
                        var o = n[r];
                        e.object.levels.push({
                            object: o.object.uuid,
                            distance: o.distance
                        })
                    }
                    return e
                }
            }), io.prototype = Object.assign(Object.create(Pn.prototype), {
                constructor: io,
                isSkinnedMesh: !0,
                bind: function(t, e) {
                    this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
                },
                pose: function() {
                    this.skeleton.pose()
                },
                normalizeSkinWeights: function() {
                    for (var t = new Ye, e = this.geometry.attributes.skinWeight, n = 0, r = e.count; n < r; n++) {
                        t.x = e.getX(n), t.y = e.getY(n), t.z = e.getZ(n), t.w = e.getW(n);
                        var i = 1 / t.manhattanLength();
                        i !== 1 / 0 ? t.multiplyScalar(i) : t.set(1, 0, 0, 0), e.setXYZW(n, t.x, t.y, t.z, t.w)
                    }
                },
                updateMatrixWorld: function(t) {
                    Pn.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), Object.assign(oo.prototype, {
                calculateInverses: function() {
                    this.boneInverses = [];
                    for (var t = 0, e = this.bones.length; t < e; t++) {
                        var n = new Qe;
                        this.bones[t] && n.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(n)
                    }
                },
                pose: function() {
                    var t, e, n;
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
                    for (e = 0, n = this.bones.length; e < n; e++)(t = this.bones[e]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
                },
                update: function() {
                    var t = new Qe,
                        e = new Qe;
                    return function() {
                        for (var n = this.bones, r = this.boneInverses, i = this.boneMatrices, o = this.boneTexture, a = 0, s = n.length; a < s; a++) {
                            var c = n[a] ? n[a].matrixWorld : e;
                            t.multiplyMatrices(c, r[a]), t.toArray(i, 16 * a)
                        }
                        void 0 !== o && (o.needsUpdate = !0)
                    }
                }(),
                clone: function() {
                    return new oo(this.bones, this.boneInverses)
                },
                getBoneByName: function(t) {
                    for (var e = 0, n = this.bones.length; e < n; e++) {
                        var r = this.bones[e];
                        if (r.name === t) return r
                    }
                }
            }), ao.prototype = Object.assign(Object.create(en.prototype), {
                constructor: ao,
                isBone: !0
            }), so.prototype = Object.create(mn.prototype), so.prototype.constructor = so, so.prototype.isLineBasicMaterial = !0, so.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
            }, co.prototype = Object.assign(Object.create(en.prototype), {
                constructor: co,
                isLine: !0,
                computeLineDistances: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var r = n.attributes.position, i = [0], o = 1, a = r.count; o < a; o++) t.fromBufferAttribute(r, o - 1), e.fromBufferAttribute(r, o), i[o] = i[o - 1], i[o] += t.distanceTo(e);
                                n.addAttribute("lineDistance", new Sn(i, 1))
                            } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) {
                            var s = n.vertices;
                            for ((i = n.lineDistances)[0] = 0, o = 1, a = s.length; o < a; o++) i[o] = i[o - 1], i[o] += s[o - 1].distanceTo(s[o])
                        }
                        return this
                    }
                }(),
                raycast: function() {
                    var t = new Qe,
                        e = new an,
                        n = new on;
                    return function(r, i) {
                        var o = r.linePrecision,
                            a = this.geometry,
                            s = this.matrixWorld;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += o, !1 !== r.ray.intersectsSphere(n)) {
                            t.getInverse(s), e.copy(r.ray).applyMatrix4(t);
                            var c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                u = c * c,
                                l = new je,
                                h = new je,
                                p = new je,
                                d = new je,
                                f = this && this.isLineSegments ? 2 : 1;
                            if (a.isBufferGeometry) {
                                var m = a.index,
                                    v = a.attributes.position.array;
                                if (null !== m)
                                    for (var g = m.array, y = 0, x = g.length - 1; y < x; y += f) {
                                        var b = g[y],
                                            w = g[y + 1];
                                        l.fromArray(v, 3 * b), h.fromArray(v, 3 * w);
                                        var _ = e.distanceSqToSegment(l, h, d, p);
                                        if (!(_ > u)) {
                                            d.applyMatrix4(this.matrixWorld);
                                            var M = r.ray.origin.distanceTo(d);
                                            M < r.near || M > r.far || i.push({
                                                distance: M,
                                                point: p.clone().applyMatrix4(this.matrixWorld),
                                                index: y,
                                                face: null,
                                                faceIndex: null,
                                                object: this
                                            })
                                        }
                                    } else
                                        for (y = 0, x = v.length / 3 - 1; y < x; y += f) l.fromArray(v, 3 * y), h.fromArray(v, 3 * y + 3), (_ = e.distanceSqToSegment(l, h, d, p)) > u || (d.applyMatrix4(this.matrixWorld), (M = r.ray.origin.distanceTo(d)) < r.near || M > r.far || i.push({
                                            distance: M,
                                            point: p.clone().applyMatrix4(this.matrixWorld),
                                            index: y,
                                            face: null,
                                            faceIndex: null,
                                            object: this
                                        }))
                            } else if (a.isGeometry) {
                                var E = a.vertices,
                                    S = E.length;
                                for (y = 0; y < S - 1; y += f)(_ = e.distanceSqToSegment(E[y], E[y + 1], d, p)) > u || (d.applyMatrix4(this.matrixWorld), (M = r.ray.origin.distanceTo(d)) < r.near || M > r.far || i.push({
                                    distance: M,
                                    point: p.clone().applyMatrix4(this.matrixWorld),
                                    index: y,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        }
                    }
                }(),
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), uo.prototype = Object.assign(Object.create(co.prototype), {
                constructor: uo,
                isLineSegments: !0,
                computeLineDistances: function() {
                    var t = new je,
                        e = new je;
                    return function() {
                        var n = this.geometry;
                        if (n.isBufferGeometry)
                            if (null === n.index) {
                                for (var r = n.attributes.position, i = [], o = 0, a = r.count; o < a; o += 2) t.fromBufferAttribute(r, o), e.fromBufferAttribute(r, o + 1), i[o] = 0 === o ? 0 : i[o - 1], i[o + 1] = i[o] + t.distanceTo(e);
                                n.addAttribute("lineDistance", new Sn(i, 1))
                            } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
                        else if (n.isGeometry) {
                            var s = n.vertices;
                            for (i = n.lineDistances, o = 0, a = s.length; o < a; o += 2) t.copy(s[o]), e.copy(s[o + 1]), i[o] = 0 === o ? 0 : i[o - 1], i[o + 1] = i[o] + t.distanceTo(e)
                        }
                        return this
                    }
                }()
            }), lo.prototype = Object.assign(Object.create(co.prototype), {
                constructor: lo,
                isLineLoop: !0
            }), ho.prototype = Object.create(mn.prototype), ho.prototype.constructor = ho, ho.prototype.isPointsMaterial = !0, ho.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
            }, po.prototype = Object.assign(Object.create(en.prototype), {
                constructor: po,
                isPoints: !0,
                raycast: function() {
                    var t = new Qe,
                        e = new an,
                        n = new on;
                    return function(r, i) {
                        var o = this,
                            a = this.geometry,
                            s = this.matrixWorld,
                            c = r.params.Points.threshold;
                        if (null === a.boundingSphere && a.computeBoundingSphere(), n.copy(a.boundingSphere), n.applyMatrix4(s), n.radius += c, !1 !== r.ray.intersectsSphere(n)) {
                            t.getInverse(s), e.copy(r.ray).applyMatrix4(t);
                            var u = c / ((this.scale.x + this.scale.y + this.scale.z) / 3),
                                l = u * u,
                                h = new je,
                                p = new je;
                            if (a.isBufferGeometry) {
                                var d = a.index,
                                    f = a.attributes.position.array;
                                if (null !== d)
                                    for (var m = d.array, v = 0, g = m.length; v < g; v++) {
                                        var y = m[v];
                                        h.fromArray(f, 3 * y), w(h, y)
                                    } else {
                                        v = 0;
                                        for (var x = f.length / 3; v < x; v++) h.fromArray(f, 3 * v), w(h, v)
                                    }
                            } else {
                                var b = a.vertices;
                                for (v = 0, x = b.length; v < x; v++) w(b[v], v)
                            }
                        }

                        function w(t, n) {
                            var a = e.distanceSqToPoint(t);
                            if (a < l) {
                                e.closestPointToPoint(t, p), p.applyMatrix4(s);
                                var c = r.ray.origin.distanceTo(p);
                                if (c < r.near || c > r.far) return;
                                i.push({
                                    distance: c,
                                    distanceToRay: Math.sqrt(a),
                                    point: p.clone(),
                                    index: n,
                                    face: null,
                                    object: o
                                })
                            }
                        }
                    }
                }(),
                updateMorphTargets: function() {
                    var t, e, n, r = this.geometry.morphAttributes,
                        i = Object.keys(r);
                    if (i.length > 0) {
                        var o = r[i[0]];
                        if (void 0 !== o)
                            for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = o.length; t < e; t++) n = o[t].name || String(t), this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                    }
                },
                clone: function() {
                    return new this.constructor(this.geometry, this.material).copy(this)
                }
            }), fo.prototype = Object.assign(Object.create(Xe.prototype), {
                constructor: fo,
                isVideoTexture: !0,
                update: function() {
                    var t = this.image;
                    t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
                }
            }), mo.prototype = Object.create(Xe.prototype), mo.prototype.constructor = mo, mo.prototype.isCompressedTexture = !0, vo.prototype = Object.create(Xe.prototype), vo.prototype.constructor = vo, vo.prototype.isCanvasTexture = !0, go.prototype = Object.create(Xe.prototype), go.prototype.constructor = go, go.prototype.isDepthTexture = !0, yo.prototype = Object.create(Rn.prototype), yo.prototype.constructor = yo, xo.prototype = Object.create(In.prototype), xo.prototype.constructor = xo, bo.prototype = Object.create(Rn.prototype), bo.prototype.constructor = bo, wo.prototype = Object.create(In.prototype), wo.prototype.constructor = wo, _o.prototype = Object.create(Rn.prototype), _o.prototype.constructor = _o, Mo.prototype = Object.create(In.prototype), Mo.prototype.constructor = Mo, Eo.prototype = Object.create(_o.prototype), Eo.prototype.constructor = Eo, So.prototype = Object.create(In.prototype), So.prototype.constructor = So, To.prototype = Object.create(_o.prototype), To.prototype.constructor = To, Ao.prototype = Object.create(In.prototype), Ao.prototype.constructor = Ao, Lo.prototype = Object.create(_o.prototype), Lo.prototype.constructor = Lo, Co.prototype = Object.create(In.prototype), Co.prototype.constructor = Co, Ro.prototype = Object.create(_o.prototype), Ro.prototype.constructor = Ro, Po.prototype = Object.create(In.prototype), Po.prototype.constructor = Po, Oo.prototype = Object.create(Rn.prototype), Oo.prototype.constructor = Oo, Oo.prototype.toJSON = function() {
                var t = Rn.prototype.toJSON.call(this);
                return t.path = this.parameters.path.toJSON(), t
            }, Io.prototype = Object.create(In.prototype), Io.prototype.constructor = Io, Bo.prototype = Object.create(Rn.prototype), Bo.prototype.constructor = Bo, Do.prototype = Object.create(In.prototype), Do.prototype.constructor = Do, Fo.prototype = Object.create(Rn.prototype), Fo.prototype.constructor = Fo;
            var ko = function(t, e, n) {
                n = n || 2;
                var r, i, o, a, s, c, u, l = e && e.length,
                    h = l ? e[0] * n : t.length,
                    p = No(t, 0, h, n, !0),
                    d = [];
                if (!p || p.next === p.prev) return d;
                if (l && (p = function(t, e, n, r) {
                        var i, o, a, s, c, u = [];
                        for (i = 0, o = e.length; i < o; i++) a = e[i] * r, s = i < o - 1 ? e[i + 1] * r : t.length, (c = No(t, a, s, r, !1)) === c.next && (c.steiner = !0), u.push(Yo(c));
                        for (u.sort(Wo), i = 0; i < u.length; i++) qo(u[i], n), n = zo(n, n.next);
                        return n
                    }(t, e, p, n)), t.length > 80 * n) {
                    r = o = t[0], i = a = t[1];
                    for (var f = n; f < h; f += n)(s = t[f]) < r && (r = s), (c = t[f + 1]) < i && (i = c), s > o && (o = s), c > a && (a = c);
                    u = 0 !== (u = Math.max(o - r, a - i)) ? 1 / u : 0
                }
                return Go(p, d, n, r, i, u), d
            };

            function No(t, e, n, r, i) {
                var o, a;
                if (i === function(t, e, n, r) {
                        for (var i = 0, o = e, a = n - r; o < n; o += r) i += (t[a] - t[o]) * (t[o + 1] + t[a + 1]), a = o;
                        return i
                    }(t, e, n, r) > 0)
                    for (o = e; o < n; o += r) a = na(o, t[o], t[o + 1], a);
                else
                    for (o = n - r; o >= e; o -= r) a = na(o, t[o], t[o + 1], a);
                return a && Ko(a, a.next) && (ra(a), a = a.next), a
            }

            function zo(t, e) {
                if (!t) return t;
                e || (e = t);
                var n, r = t;
                do {
                    if (n = !1, r.steiner || !Ko(r, r.next) && 0 !== Qo(r.prev, r, r.next)) r = r.next;
                    else {
                        if (ra(r), (r = e = r.prev) === r.next) break;
                        n = !0
                    }
                } while (n || r !== e);
                return e
            }

            function Go(t, e, n, r, i, o, a) {
                if (t) {
                    !a && o && function(t, e, n, r) {
                        var i = t;
                        do {
                            null === i.z && (i.z = Xo(i.x, i.y, e, n, r)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next
                        } while (i !== t);
                        i.prevZ.nextZ = null, i.prevZ = null,
                            function(t) {
                                var e, n, r, i, o, a, s, c, u = 1;
                                do {
                                    for (n = t, t = null, o = null, a = 0; n;) {
                                        for (a++, r = n, s = 0, e = 0; e < u && (s++, r = r.nextZ); e++);
                                        for (c = u; s > 0 || c > 0 && r;) 0 !== s && (0 === c || !r || n.z <= r.z) ? (i = n, n = n.nextZ, s--) : (i = r, r = r.nextZ, c--), o ? o.nextZ = i : t = i, i.prevZ = o, o = i;
                                        n = r
                                    }
                                    o.nextZ = null, u *= 2
                                } while (a > 1)
                            }(i)
                    }(t, r, i, o);
                    for (var s, c, u = t; t.prev !== t.next;)
                        if (s = t.prev, c = t.next, o ? Uo(t, r, i, o) : Ho(t)) e.push(s.i / n), e.push(t.i / n), e.push(c.i / n), ra(t), t = c.next, u = c.next;
                        else if ((t = c) === u) {
                        a ? 1 === a ? Go(t = jo(t, e, n), e, n, r, i, o, 2) : 2 === a && Vo(t, e, n, r, i, o) : Go(zo(t), e, n, r, i, o, 1);
                        break
                    }
                }
            }

            function Ho(t) {
                var e = t.prev,
                    n = t,
                    r = t.next;
                if (Qo(e, n, r) >= 0) return !1;
                for (var i = t.next.next; i !== t.prev;) {
                    if (Jo(e.x, e.y, n.x, n.y, r.x, r.y, i.x, i.y) && Qo(i.prev, i, i.next) >= 0) return !1;
                    i = i.next
                }
                return !0
            }

            function Uo(t, e, n, r) {
                var i = t.prev,
                    o = t,
                    a = t.next;
                if (Qo(i, o, a) >= 0) return !1;
                for (var s = i.x < o.x ? i.x < a.x ? i.x : a.x : o.x < a.x ? o.x : a.x, c = i.y < o.y ? i.y < a.y ? i.y : a.y : o.y < a.y ? o.y : a.y, u = i.x > o.x ? i.x > a.x ? i.x : a.x : o.x > a.x ? o.x : a.x, l = i.y > o.y ? i.y > a.y ? i.y : a.y : o.y > a.y ? o.y : a.y, h = Xo(s, c, e, n, r), p = Xo(u, l, e, n, r), d = t.prevZ, f = t.nextZ; d && d.z >= h && f && f.z <= p;) {
                    if (d !== t.prev && d !== t.next && Jo(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && Qo(d.prev, d, d.next) >= 0) return !1;
                    if (d = d.prevZ, f !== t.prev && f !== t.next && Jo(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && Qo(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                for (; d && d.z >= h;) {
                    if (d !== t.prev && d !== t.next && Jo(i.x, i.y, o.x, o.y, a.x, a.y, d.x, d.y) && Qo(d.prev, d, d.next) >= 0) return !1;
                    d = d.prevZ
                }
                for (; f && f.z <= p;) {
                    if (f !== t.prev && f !== t.next && Jo(i.x, i.y, o.x, o.y, a.x, a.y, f.x, f.y) && Qo(f.prev, f, f.next) >= 0) return !1;
                    f = f.nextZ
                }
                return !0
            }

            function jo(t, e, n) {
                var r = t;
                do {
                    var i = r.prev,
                        o = r.next.next;
                    !Ko(i, o) && $o(i, r, r.next, o) && ta(i, o) && ta(o, i) && (e.push(i.i / n), e.push(r.i / n), e.push(o.i / n), ra(r), ra(r.next), r = t = o), r = r.next
                } while (r !== t);
                return r
            }

            function Vo(t, e, n, r, i, o) {
                var a = t;
                do {
                    for (var s = a.next.next; s !== a.prev;) {
                        if (a.i !== s.i && Zo(a, s)) {
                            var c = ea(a, s);
                            return a = zo(a, a.next), c = zo(c, c.next), Go(a, e, n, r, i, o), void Go(c, e, n, r, i, o)
                        }
                        s = s.next
                    }
                    a = a.next
                } while (a !== t)
            }

            function Wo(t, e) {
                return t.x - e.x
            }

            function qo(t, e) {
                if (e = function(t, e) {
                        var n, r = e,
                            i = t.x,
                            o = t.y,
                            a = -1 / 0;
                        do {
                            if (o <= r.y && o >= r.next.y && r.next.y !== r.y) {
                                var s = r.x + (o - r.y) * (r.next.x - r.x) / (r.next.y - r.y);
                                if (s <= i && s > a) {
                                    if (a = s, s === i) {
                                        if (o === r.y) return r;
                                        if (o === r.next.y) return r.next
                                    }
                                    n = r.x < r.next.x ? r : r.next
                                }
                            }
                            r = r.next
                        } while (r !== e);
                        if (!n) return null;
                        if (i === a) return n.prev;
                        var c, u = n,
                            l = n.x,
                            h = n.y,
                            p = 1 / 0;
                        r = n.next;
                        for (; r !== u;) i >= r.x && r.x >= l && i !== r.x && Jo(o < h ? i : a, o, l, h, o < h ? a : i, o, r.x, r.y) && ((c = Math.abs(o - r.y) / (i - r.x)) < p || c === p && r.x > n.x) && ta(r, t) && (n = r, p = c), r = r.next;
                        return n
                    }(t, e)) {
                    var n = ea(e, t);
                    zo(n, n.next)
                }
            }

            function Xo(t, e, n, r, i) {
                return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * i) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * i) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
            }

            function Yo(t) {
                var e = t,
                    n = t;
                do {
                    (e.x < n.x || e.x === n.x && e.y < n.y) && (n = e), e = e.next
                } while (e !== t);
                return n
            }

            function Jo(t, e, n, r, i, o, a, s) {
                return (i - a) * (e - s) - (t - a) * (o - s) >= 0 && (t - a) * (r - s) - (n - a) * (e - s) >= 0 && (n - a) * (o - s) - (i - a) * (r - s) >= 0
            }

            function Zo(t, e) {
                return t.next.i !== e.i && t.prev.i !== e.i && ! function(t, e) {
                    var n = t;
                    do {
                        if (n.i !== t.i && n.next.i !== t.i && n.i !== e.i && n.next.i !== e.i && $o(n, n.next, t, e)) return !0;
                        n = n.next
                    } while (n !== t);
                    return !1
                }(t, e) && ta(t, e) && ta(e, t) && function(t, e) {
                    var n = t,
                        r = !1,
                        i = (t.x + e.x) / 2,
                        o = (t.y + e.y) / 2;
                    do {
                        n.y > o != n.next.y > o && n.next.y !== n.y && i < (n.next.x - n.x) * (o - n.y) / (n.next.y - n.y) + n.x && (r = !r), n = n.next
                    } while (n !== t);
                    return r
                }(t, e)
            }

            function Qo(t, e, n) {
                return (e.y - t.y) * (n.x - e.x) - (e.x - t.x) * (n.y - e.y)
            }

            function Ko(t, e) {
                return t.x === e.x && t.y === e.y
            }

            function $o(t, e, n, r) {
                return !!(Ko(t, n) && Ko(e, r) || Ko(t, r) && Ko(n, e)) || Qo(t, e, n) > 0 != Qo(t, e, r) > 0 && Qo(n, r, t) > 0 != Qo(n, r, e) > 0
            }

            function ta(t, e) {
                return Qo(t.prev, t, t.next) < 0 ? Qo(t, e, t.next) >= 0 && Qo(t, t.prev, e) >= 0 : Qo(t, e, t.prev) < 0 || Qo(t, t.next, e) < 0
            }

            function ea(t, e) {
                var n = new ia(t.i, t.x, t.y),
                    r = new ia(e.i, e.x, e.y),
                    i = t.next,
                    o = e.prev;
                return t.next = e, e.prev = t, n.next = i, i.prev = n, r.next = n, n.prev = r, o.next = r, r.prev = o, r
            }

            function na(t, e, n, r) {
                var i = new ia(t, e, n);
                return r ? (i.next = r.next, i.prev = r, r.next.prev = i, r.next = i) : (i.prev = i, i.next = i), i
            }

            function ra(t) {
                t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
            }

            function ia(t, e, n) {
                this.i = t, this.x = e, this.y = n, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
            }
            var oa = {
                area: function(t) {
                    for (var e = t.length, n = 0, r = e - 1, i = 0; i < e; r = i++) n += t[r].x * t[i].y - t[i].x * t[r].y;
                    return .5 * n
                },
                isClockWise: function(t) {
                    return oa.area(t) < 0
                },
                triangulateShape: function(t, e) {
                    var n = [],
                        r = [],
                        i = [];
                    aa(t), sa(n, t);
                    var o = t.length;
                    e.forEach(aa);
                    for (var a = 0; a < e.length; a++) r.push(o), o += e[a].length, sa(n, e[a]);
                    var s = ko(n, r);
                    for (a = 0; a < s.length; a += 3) i.push(s.slice(a, a + 3));
                    return i
                }
            };

            function aa(t) {
                var e = t.length;
                e > 2 && t[e - 1].equals(t[0]) && t.pop()
            }

            function sa(t, e) {
                for (var n = 0; n < e.length; n++) t.push(e[n].x), t.push(e[n].y)
            }

            function ca(t, e) {
                In.call(this), this.type = "ExtrudeGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, this.fromBufferGeometry(new ua(t, e)), this.mergeVertices()
            }

            function ua(t, e) {
                Rn.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
                    shapes: t,
                    options: e
                }, t = Array.isArray(t) ? t : [t];
                for (var n = this, r = [], i = [], o = 0, a = t.length; o < a; o++) {
                    s(t[o])
                }

                function s(t) {
                    var o = [],
                        a = void 0 !== e.curveSegments ? e.curveSegments : 12,
                        s = void 0 !== e.steps ? e.steps : 1,
                        c = void 0 !== e.depth ? e.depth : 100,
                        u = void 0 === e.bevelEnabled || e.bevelEnabled,
                        l = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                        h = void 0 !== e.bevelSize ? e.bevelSize : l - 2,
                        p = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
                        d = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                        f = e.extrudePath,
                        m = void 0 !== e.UVGenerator ? e.UVGenerator : la;
                    void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), c = e.amount);
                    var v, g, y, x, b, w, _, M, E = !1;
                    f && (v = f.getSpacedPoints(s), E = !0, u = !1, g = f.computeFrenetFrames(s, !1), y = new je, x = new je, b = new je), u || (d = 0, l = 0, h = 0, p = 0);
                    var S = t.extractPoints(a),
                        T = S.shape,
                        A = S.holes;
                    if (!oa.isClockWise(T))
                        for (T = T.reverse(), _ = 0, M = A.length; _ < M; _++) w = A[_], oa.isClockWise(w) && (A[_] = w.reverse());
                    var L = oa.triangulateShape(T, A),
                        C = T;
                    for (_ = 0, M = A.length; _ < M; _++) w = A[_], T = T.concat(w);

                    function R(t, e, n) {
                        return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
                    }
                    var P, O, I, B, D, F, k = T.length,
                        N = L.length;

                    function z(t, e, n) {
                        var r, i, o, a = t.x - e.x,
                            s = t.y - e.y,
                            c = n.x - t.x,
                            u = n.y - t.y,
                            l = a * a + s * s,
                            h = a * u - s * c;
                        if (Math.abs(h) > Number.EPSILON) {
                            var p = Math.sqrt(l),
                                d = Math.sqrt(c * c + u * u),
                                f = e.x - s / p,
                                m = e.y + a / p,
                                v = ((n.x - u / d - f) * u - (n.y + c / d - m) * c) / (a * u - s * c),
                                g = (r = f + a * v - t.x) * r + (i = m + s * v - t.y) * i;
                            if (g <= 2) return new He(r, i);
                            o = Math.sqrt(g / 2)
                        } else {
                            var y = !1;
                            a > Number.EPSILON ? c > Number.EPSILON && (y = !0) : a < -Number.EPSILON ? c < -Number.EPSILON && (y = !0) : Math.sign(s) === Math.sign(u) && (y = !0), y ? (r = -s, i = a, o = Math.sqrt(l)) : (r = a, i = s, o = Math.sqrt(l / 2))
                        }
                        return new He(r / o, i / o)
                    }
                    for (var G = [], H = 0, U = C.length, j = U - 1, V = H + 1; H < U; H++, j++, V++) j === U && (j = 0), V === U && (V = 0), G[H] = z(C[H], C[j], C[V]);
                    var W, q, X = [],
                        Y = G.concat();
                    for (_ = 0, M = A.length; _ < M; _++) {
                        for (w = A[_], W = [], H = 0, j = (U = w.length) - 1, V = H + 1; H < U; H++, j++, V++) j === U && (j = 0), V === U && (V = 0), W[H] = z(w[H], w[j], w[V]);
                        X.push(W), Y = Y.concat(W)
                    }
                    for (P = 0; P < d; P++) {
                        for (I = P / d, B = l * Math.cos(I * Math.PI / 2), O = h * Math.sin(I * Math.PI / 2) + p, H = 0, U = C.length; H < U; H++) Z((D = R(C[H], G[H], O)).x, D.y, -B);
                        for (_ = 0, M = A.length; _ < M; _++)
                            for (w = A[_], W = X[_], H = 0, U = w.length; H < U; H++) Z((D = R(w[H], W[H], O)).x, D.y, -B)
                    }
                    for (O = h + p, H = 0; H < k; H++) D = u ? R(T[H], Y[H], O) : T[H], E ? (x.copy(g.normals[0]).multiplyScalar(D.x), y.copy(g.binormals[0]).multiplyScalar(D.y), b.copy(v[0]).add(x).add(y), Z(b.x, b.y, b.z)) : Z(D.x, D.y, 0);
                    for (q = 1; q <= s; q++)
                        for (H = 0; H < k; H++) D = u ? R(T[H], Y[H], O) : T[H], E ? (x.copy(g.normals[q]).multiplyScalar(D.x), y.copy(g.binormals[q]).multiplyScalar(D.y), b.copy(v[q]).add(x).add(y), Z(b.x, b.y, b.z)) : Z(D.x, D.y, c / s * q);
                    for (P = d - 1; P >= 0; P--) {
                        for (I = P / d, B = l * Math.cos(I * Math.PI / 2), O = h * Math.sin(I * Math.PI / 2) + p, H = 0, U = C.length; H < U; H++) Z((D = R(C[H], G[H], O)).x, D.y, c + B);
                        for (_ = 0, M = A.length; _ < M; _++)
                            for (w = A[_], W = X[_], H = 0, U = w.length; H < U; H++) D = R(w[H], W[H], O), E ? Z(D.x, D.y + v[s - 1].y, v[s - 1].x + B) : Z(D.x, D.y, c + B)
                    }

                    function J(t, e) {
                        var n, r;
                        for (H = t.length; --H >= 0;) {
                            n = H, (r = H - 1) < 0 && (r = t.length - 1);
                            var i = 0,
                                o = s + 2 * d;
                            for (i = 0; i < o; i++) {
                                var a = k * i,
                                    c = k * (i + 1);
                                K(e + n + a, e + r + a, e + r + c, e + n + c)
                            }
                        }
                    }

                    function Z(t, e, n) {
                        o.push(t), o.push(e), o.push(n)
                    }

                    function Q(t, e, i) {
                        $(t), $(e), $(i);
                        var o = r.length / 3,
                            a = m.generateTopUV(n, r, o - 3, o - 2, o - 1);
                        tt(a[0]), tt(a[1]), tt(a[2])
                    }

                    function K(t, e, i, o) {
                        $(t), $(e), $(o), $(e), $(i), $(o);
                        var a = r.length / 3,
                            s = m.generateSideWallUV(n, r, a - 6, a - 3, a - 2, a - 1);
                        tt(s[0]), tt(s[1]), tt(s[3]), tt(s[1]), tt(s[2]), tt(s[3])
                    }

                    function $(t) {
                        r.push(o[3 * t + 0]), r.push(o[3 * t + 1]), r.push(o[3 * t + 2])
                    }

                    function tt(t) {
                        i.push(t.x), i.push(t.y)
                    }(function() {
                        var t = r.length / 3;
                        if (u) {
                            var e = 0,
                                i = k * e;
                            for (H = 0; H < N; H++) Q((F = L[H])[2] + i, F[1] + i, F[0] + i);
                            for (i = k * (e = s + 2 * d), H = 0; H < N; H++) Q((F = L[H])[0] + i, F[1] + i, F[2] + i)
                        } else {
                            for (H = 0; H < N; H++) Q((F = L[H])[2], F[1], F[0]);
                            for (H = 0; H < N; H++) Q((F = L[H])[0] + k * s, F[1] + k * s, F[2] + k * s)
                        }
                        n.addGroup(t, r.length / 3 - t, 0)
                    })(),
                    function() {
                        var t = r.length / 3,
                            e = 0;
                        for (J(C, e), e += C.length, _ = 0, M = A.length; _ < M; _++) J(w = A[_], e), e += w.length;
                        n.addGroup(t, r.length / 3 - t, 1)
                    }()
                }
                this.addAttribute("position", new Sn(r, 3)), this.addAttribute("uv", new Sn(i, 2)), this.computeVertexNormals()
            }
            ca.prototype = Object.create(In.prototype), ca.prototype.constructor = ca, ca.prototype.toJSON = function() {
                var t = In.prototype.toJSON.call(this);
                return ha(this.parameters.shapes, this.parameters.options, t)
            }, ua.prototype = Object.create(Rn.prototype), ua.prototype.constructor = ua, ua.prototype.toJSON = function() {
                var t = Rn.prototype.toJSON.call(this);
                return ha(this.parameters.shapes, this.parameters.options, t)
            };
            var la = {
                generateTopUV: function(t, e, n, r, i) {
                    var o = e[3 * n],
                        a = e[3 * n + 1],
                        s = e[3 * r],
                        c = e[3 * r + 1],
                        u = e[3 * i],
                        l = e[3 * i + 1];
                    return [new He(o, a), new He(s, c), new He(u, l)]
                },
                generateSideWallUV: function(t, e, n, r, i, o) {
                    var a = e[3 * n],
                        s = e[3 * n + 1],
                        c = e[3 * n + 2],
                        u = e[3 * r],
                        l = e[3 * r + 1],
                        h = e[3 * r + 2],
                        p = e[3 * i],
                        d = e[3 * i + 1],
                        f = e[3 * i + 2],
                        m = e[3 * o],
                        v = e[3 * o + 1],
                        g = e[3 * o + 2];
                    return Math.abs(s - l) < .01 ? [new He(a, 1 - c), new He(u, 1 - h), new He(p, 1 - f), new He(m, 1 - g)] : [new He(s, 1 - c), new He(l, 1 - h), new He(d, 1 - f), new He(v, 1 - g)]
                }
            };

            function ha(t, e, n) {
                if (n.shapes = [], Array.isArray(t))
                    for (var r = 0, i = t.length; r < i; r++) {
                        var o = t[r];
                        n.shapes.push(o.uuid)
                    } else n.shapes.push(t.uuid);
                return void 0 !== e.extrudePath && (n.options.extrudePath = e.extrudePath.toJSON()), n
            }

            function pa(t, e) {
                In.call(this), this.type = "TextGeometry", this.parameters = {
                    text: t,
                    parameters: e
                }, this.fromBufferGeometry(new da(t, e)), this.mergeVertices()
            }

            function da(t, e) {
                var n = (e = e || {}).font;
                if (!n || !n.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new In;
                var r = n.generateShapes(t, e.size);
                e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), ua.call(this, r, e), this.type = "TextBufferGeometry"
            }

            function fa(t, e, n, r, i, o, a) {
                In.call(this), this.type = "SphereGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, this.fromBufferGeometry(new ma(t, e, n, r, i, o, a)), this.mergeVertices()
            }

            function ma(t, e, n, r, i, o, a) {
                Rn.call(this), this.type = "SphereBufferGeometry", this.parameters = {
                    radius: t,
                    widthSegments: e,
                    heightSegments: n,
                    phiStart: r,
                    phiLength: i,
                    thetaStart: o,
                    thetaLength: a
                }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), n = Math.max(2, Math.floor(n) || 6), r = void 0 !== r ? r : 0, i = void 0 !== i ? i : 2 * Math.PI, o = void 0 !== o ? o : 0, a = void 0 !== a ? a : Math.PI;
                var s, c, u = Math.min(o + a, Math.PI),
                    l = 0,
                    h = [],
                    p = new je,
                    d = new je,
                    f = [],
                    m = [],
                    v = [],
                    g = [];
                for (c = 0; c <= n; c++) {
                    var y = [],
                        x = c / n,
                        b = 0;
                    for (0 == c && 0 == o ? b = .5 / e : c == n && u == Math.PI && (b = -.5 / e), s = 0; s <= e; s++) {
                        var w = s / e;
                        p.x = -t * Math.cos(r + w * i) * Math.sin(o + x * a), p.y = t * Math.cos(o + x * a), p.z = t * Math.sin(r + w * i) * Math.sin(o + x * a), m.push(p.x, p.y, p.z), d.copy(p).normalize(), v.push(d.x, d.y, d.z), g.push(w + b, 1 - x), y.push(l++)
                    }
                    h.push(y)
                }
                for (c = 0; c < n; c++)
                    for (s = 0; s < e; s++) {
                        var _ = h[c][s + 1],
                            M = h[c][s],
                            E = h[c + 1][s],
                            S = h[c + 1][s + 1];
                        (0 !== c || o > 0) && f.push(_, M, S), (c !== n - 1 || u < Math.PI) && f.push(M, E, S)
                    }
                this.setIndex(f), this.addAttribute("position", new Sn(m, 3)), this.addAttribute("normal", new Sn(v, 3)), this.addAttribute("uv", new Sn(g, 2))
            }

            function va(t, e, n, r, i, o) {
                In.call(this), this.type = "RingGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, this.fromBufferGeometry(new ga(t, e, n, r, i, o)), this.mergeVertices()
            }

            function ga(t, e, n, r, i, o) {
                Rn.call(this), this.type = "RingBufferGeometry", this.parameters = {
                    innerRadius: t,
                    outerRadius: e,
                    thetaSegments: n,
                    phiSegments: r,
                    thetaStart: i,
                    thetaLength: o
                }, t = t || .5, e = e || 1, i = void 0 !== i ? i : 0, o = void 0 !== o ? o : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8;
                var a, s, c, u = [],
                    l = [],
                    h = [],
                    p = [],
                    d = t,
                    f = (e - t) / (r = void 0 !== r ? Math.max(1, r) : 1),
                    m = new je,
                    v = new He;
                for (s = 0; s <= r; s++) {
                    for (c = 0; c <= n; c++) a = i + c / n * o, m.x = d * Math.cos(a), m.y = d * Math.sin(a), l.push(m.x, m.y, m.z), h.push(0, 0, 1), v.x = (m.x / e + 1) / 2, v.y = (m.y / e + 1) / 2, p.push(v.x, v.y);
                    d += f
                }
                for (s = 0; s < r; s++) {
                    var g = s * (n + 1);
                    for (c = 0; c < n; c++) {
                        var y = a = c + g,
                            x = a + n + 1,
                            b = a + n + 2,
                            w = a + 1;
                        u.push(y, x, w), u.push(x, b, w)
                    }
                }
                this.setIndex(u), this.addAttribute("position", new Sn(l, 3)), this.addAttribute("normal", new Sn(h, 3)), this.addAttribute("uv", new Sn(p, 2))
            }

            function ya(t, e, n, r) {
                In.call(this), this.type = "LatheGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: r
                }, this.fromBufferGeometry(new xa(t, e, n, r)), this.mergeVertices()
            }

            function xa(t, e, n, r) {
                Rn.call(this), this.type = "LatheBufferGeometry", this.parameters = {
                    points: t,
                    segments: e,
                    phiStart: n,
                    phiLength: r
                }, e = Math.floor(e) || 12, n = n || 0, r = r || 2 * Math.PI, r = Ge.clamp(r, 0, 2 * Math.PI);
                var i, o, a, s = [],
                    c = [],
                    u = [],
                    l = 1 / e,
                    h = new je,
                    p = new He;
                for (o = 0; o <= e; o++) {
                    var d = n + o * l * r,
                        f = Math.sin(d),
                        m = Math.cos(d);
                    for (a = 0; a <= t.length - 1; a++) h.x = t[a].x * f, h.y = t[a].y, h.z = t[a].x * m, c.push(h.x, h.y, h.z), p.x = o / e, p.y = a / (t.length - 1), u.push(p.x, p.y)
                }
                for (o = 0; o < e; o++)
                    for (a = 0; a < t.length - 1; a++) {
                        var v = i = a + o * t.length,
                            g = i + t.length,
                            y = i + t.length + 1,
                            x = i + 1;
                        s.push(v, g, x), s.push(g, y, x)
                    }
                if (this.setIndex(s), this.addAttribute("position", new Sn(c, 3)), this.addAttribute("uv", new Sn(u, 2)), this.computeVertexNormals(), r === 2 * Math.PI) {
                    var b = this.attributes.normal.array,
                        w = new je,
                        _ = new je,
                        M = new je;
                    for (i = e * t.length * 3, o = 0, a = 0; o < t.length; o++, a += 3) w.x = b[a + 0], w.y = b[a + 1], w.z = b[a + 2], _.x = b[i + a + 0], _.y = b[i + a + 1], _.z = b[i + a + 2], M.addVectors(w, _).normalize(), b[a + 0] = b[i + a + 0] = M.x, b[a + 1] = b[i + a + 1] = M.y, b[a + 2] = b[i + a + 2] = M.z
                }
            }

            function ba(t, e) {
                In.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, this.fromBufferGeometry(new wa(t, e)), this.mergeVertices()
            }

            function wa(t, e) {
                Rn.call(this), this.type = "ShapeBufferGeometry", this.parameters = {
                    shapes: t,
                    curveSegments: e
                }, e = e || 12;
                var n = [],
                    r = [],
                    i = [],
                    o = [],
                    a = 0,
                    s = 0;
                if (!1 === Array.isArray(t)) u(t);
                else
                    for (var c = 0; c < t.length; c++) u(t[c]), this.addGroup(a, s, c), a += s, s = 0;

                function u(t) {
                    var a, c, u, l = r.length / 3,
                        h = t.extractPoints(e),
                        p = h.shape,
                        d = h.holes;
                    for (!1 === oa.isClockWise(p) && (p = p.reverse()), a = 0, c = d.length; a < c; a++) u = d[a], !0 === oa.isClockWise(u) && (d[a] = u.reverse());
                    var f = oa.triangulateShape(p, d);
                    for (a = 0, c = d.length; a < c; a++) u = d[a], p = p.concat(u);
                    for (a = 0, c = p.length; a < c; a++) {
                        var m = p[a];
                        r.push(m.x, m.y, 0), i.push(0, 0, 1), o.push(m.x, m.y)
                    }
                    for (a = 0, c = f.length; a < c; a++) {
                        var v = f[a],
                            g = v[0] + l,
                            y = v[1] + l,
                            x = v[2] + l;
                        n.push(g, y, x), s += 3
                    }
                }
                this.setIndex(n), this.addAttribute("position", new Sn(r, 3)), this.addAttribute("normal", new Sn(i, 3)), this.addAttribute("uv", new Sn(o, 2))
            }

            function _a(t, e) {
                if (e.shapes = [], Array.isArray(t))
                    for (var n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        e.shapes.push(i.uuid)
                    } else e.shapes.push(t.uuid);
                return e
            }

            function Ma(t, e) {
                Rn.call(this), this.type = "EdgesGeometry", this.parameters = {
                    thresholdAngle: e
                }, e = void 0 !== e ? e : 1;
                var n, r, i, o, a = [],
                    s = Math.cos(Ge.DEG2RAD * e),
                    c = [0, 0],
                    u = {},
                    l = ["a", "b", "c"];
                t.isBufferGeometry ? (o = new In).fromBufferGeometry(t) : o = t.clone(), o.mergeVertices(), o.computeFaceNormals();
                for (var h = o.vertices, p = o.faces, d = 0, f = p.length; d < f; d++)
                    for (var m = p[d], v = 0; v < 3; v++) n = m[l[v]], r = m[l[(v + 1) % 3]], c[0] = Math.min(n, r), c[1] = Math.max(n, r), void 0 === u[i = c[0] + "," + c[1]] ? u[i] = {
                        index1: c[0],
                        index2: c[1],
                        face1: d,
                        face2: void 0
                    } : u[i].face2 = d;
                for (i in u) {
                    var g = u[i];
                    if (void 0 === g.face2 || p[g.face1].normal.dot(p[g.face2].normal) <= s) {
                        var y = h[g.index1];
                        a.push(y.x, y.y, y.z), y = h[g.index2], a.push(y.x, y.y, y.z)
                    }
                }
                this.addAttribute("position", new Sn(a, 3))
            }

            function Ea(t, e, n, r, i, o, a, s) {
                In.call(this), this.type = "CylinderGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                }, this.fromBufferGeometry(new Sa(t, e, n, r, i, o, a, s)), this.mergeVertices()
            }

            function Sa(t, e, n, r, i, o, a, s) {
                Rn.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
                    radiusTop: t,
                    radiusBottom: e,
                    height: n,
                    radialSegments: r,
                    heightSegments: i,
                    openEnded: o,
                    thetaStart: a,
                    thetaLength: s
                };
                var c = this;
                t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, r = Math.floor(r) || 8, i = Math.floor(i) || 1, o = void 0 !== o && o, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI;
                var u = [],
                    l = [],
                    h = [],
                    p = [],
                    d = 0,
                    f = [],
                    m = n / 2,
                    v = 0;

                function g(n) {
                    var i, o, f, g = new He,
                        y = new je,
                        x = 0,
                        b = !0 === n ? t : e,
                        w = !0 === n ? 1 : -1;
                    for (o = d, i = 1; i <= r; i++) l.push(0, m * w, 0), h.push(0, w, 0), p.push(.5, .5), d++;
                    for (f = d, i = 0; i <= r; i++) {
                        var _ = i / r * s + a,
                            M = Math.cos(_),
                            E = Math.sin(_);
                        y.x = b * E, y.y = m * w, y.z = b * M, l.push(y.x, y.y, y.z), h.push(0, w, 0), g.x = .5 * M + .5, g.y = .5 * E * w + .5, p.push(g.x, g.y), d++
                    }
                    for (i = 0; i < r; i++) {
                        var S = o + i,
                            T = f + i;
                        !0 === n ? u.push(T, T + 1, S) : u.push(T + 1, T, S), x += 3
                    }
                    c.addGroup(v, x, !0 === n ? 1 : 2), v += x
                }(function() {
                    var o, g, y = new je,
                        x = new je,
                        b = 0,
                        w = (e - t) / n;
                    for (g = 0; g <= i; g++) {
                        var _ = [],
                            M = g / i,
                            E = M * (e - t) + t;
                        for (o = 0; o <= r; o++) {
                            var S = o / r,
                                T = S * s + a,
                                A = Math.sin(T),
                                L = Math.cos(T);
                            x.x = E * A, x.y = -M * n + m, x.z = E * L, l.push(x.x, x.y, x.z), y.set(A, w, L).normalize(), h.push(y.x, y.y, y.z), p.push(S, 1 - M), _.push(d++)
                        }
                        f.push(_)
                    }
                    for (o = 0; o < r; o++)
                        for (g = 0; g < i; g++) {
                            var C = f[g][o],
                                R = f[g + 1][o],
                                P = f[g + 1][o + 1],
                                O = f[g][o + 1];
                            u.push(C, R, O), u.push(R, P, O), b += 6
                        }
                    c.addGroup(v, b, 0), v += b
                })(), !1 === o && (t > 0 && g(!0), e > 0 && g(!1)), this.setIndex(u), this.addAttribute("position", new Sn(l, 3)), this.addAttribute("normal", new Sn(h, 3)), this.addAttribute("uv", new Sn(p, 2))
            }

            function Ta(t, e, n, r, i, o, a) {
                Ea.call(this, 0, t, e, n, r, i, o, a), this.type = "ConeGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function Aa(t, e, n, r, i, o, a) {
                Sa.call(this, 0, t, e, n, r, i, o, a), this.type = "ConeBufferGeometry", this.parameters = {
                    radius: t,
                    height: e,
                    radialSegments: n,
                    heightSegments: r,
                    openEnded: i,
                    thetaStart: o,
                    thetaLength: a
                }
            }

            function La(t, e, n, r) {
                In.call(this), this.type = "CircleGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: r
                }, this.fromBufferGeometry(new Ca(t, e, n, r)), this.mergeVertices()
            }

            function Ca(t, e, n, r) {
                Rn.call(this), this.type = "CircleBufferGeometry", this.parameters = {
                    radius: t,
                    segments: e,
                    thetaStart: n,
                    thetaLength: r
                }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
                var i, o, a = [],
                    s = [],
                    c = [],
                    u = [],
                    l = new je,
                    h = new He;
                for (s.push(0, 0, 0), c.push(0, 0, 1), u.push(.5, .5), o = 0, i = 3; o <= e; o++, i += 3) {
                    var p = n + o / e * r;
                    l.x = t * Math.cos(p), l.y = t * Math.sin(p), s.push(l.x, l.y, l.z), c.push(0, 0, 1), h.x = (s[i] / t + 1) / 2, h.y = (s[i + 1] / t + 1) / 2, u.push(h.x, h.y)
                }
                for (i = 1; i <= e; i++) a.push(i, i + 1, 0);
                this.setIndex(a), this.addAttribute("position", new Sn(s, 3)), this.addAttribute("normal", new Sn(c, 3)), this.addAttribute("uv", new Sn(u, 2))
            }
            pa.prototype = Object.create(In.prototype), pa.prototype.constructor = pa, da.prototype = Object.create(ua.prototype), da.prototype.constructor = da, fa.prototype = Object.create(In.prototype), fa.prototype.constructor = fa, ma.prototype = Object.create(Rn.prototype), ma.prototype.constructor = ma, va.prototype = Object.create(In.prototype), va.prototype.constructor = va, ga.prototype = Object.create(Rn.prototype), ga.prototype.constructor = ga, ya.prototype = Object.create(In.prototype), ya.prototype.constructor = ya, xa.prototype = Object.create(Rn.prototype), xa.prototype.constructor = xa, ba.prototype = Object.create(In.prototype), ba.prototype.constructor = ba, ba.prototype.toJSON = function() {
                var t = In.prototype.toJSON.call(this);
                return _a(this.parameters.shapes, t)
            }, wa.prototype = Object.create(Rn.prototype), wa.prototype.constructor = wa, wa.prototype.toJSON = function() {
                var t = Rn.prototype.toJSON.call(this);
                return _a(this.parameters.shapes, t)
            }, Ma.prototype = Object.create(Rn.prototype), Ma.prototype.constructor = Ma, Ea.prototype = Object.create(In.prototype), Ea.prototype.constructor = Ea, Sa.prototype = Object.create(Rn.prototype), Sa.prototype.constructor = Sa, Ta.prototype = Object.create(Ea.prototype), Ta.prototype.constructor = Ta, Aa.prototype = Object.create(Sa.prototype), Aa.prototype.constructor = Aa, La.prototype = Object.create(In.prototype), La.prototype.constructor = La, Ca.prototype = Object.create(Rn.prototype), Ca.prototype.constructor = Ca;
            var Ra = Object.freeze({
                WireframeGeometry: yo,
                ParametricGeometry: xo,
                ParametricBufferGeometry: bo,
                TetrahedronGeometry: Mo,
                TetrahedronBufferGeometry: Eo,
                OctahedronGeometry: So,
                OctahedronBufferGeometry: To,
                IcosahedronGeometry: Ao,
                IcosahedronBufferGeometry: Lo,
                DodecahedronGeometry: Co,
                DodecahedronBufferGeometry: Ro,
                PolyhedronGeometry: wo,
                PolyhedronBufferGeometry: _o,
                TubeGeometry: Po,
                TubeBufferGeometry: Oo,
                TorusKnotGeometry: Io,
                TorusKnotBufferGeometry: Bo,
                TorusGeometry: Do,
                TorusBufferGeometry: Fo,
                TextGeometry: pa,
                TextBufferGeometry: da,
                SphereGeometry: fa,
                SphereBufferGeometry: ma,
                RingGeometry: va,
                RingBufferGeometry: ga,
                PlaneGeometry: nr,
                PlaneBufferGeometry: rr,
                LatheGeometry: ya,
                LatheBufferGeometry: xa,
                ShapeGeometry: ba,
                ShapeBufferGeometry: wa,
                ExtrudeGeometry: ca,
                ExtrudeBufferGeometry: ua,
                EdgesGeometry: Ma,
                ConeGeometry: Ta,
                ConeBufferGeometry: Aa,
                CylinderGeometry: Ea,
                CylinderBufferGeometry: Sa,
                CircleGeometry: La,
                CircleBufferGeometry: Ca,
                BoxGeometry: Bn,
                BoxBufferGeometry: Dn
            });

            function Pa(t) {
                mn.call(this), this.type = "ShadowMaterial", this.color = new un(0), this.transparent = !0, this.setValues(t)
            }

            function Oa(t) {
                Hn.call(this, t), this.type = "RawShaderMaterial"
            }

            function Ia(t) {
                mn.call(this), this.defines = {
                    STANDARD: ""
                }, this.type = "MeshStandardMaterial", this.color = new un(16777215), this.roughness = .5, this.metalness = .5, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ne, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Ba(t) {
                Ia.call(this), this.defines = {
                    PHYSICAL: ""
                }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoat = 0, this.clearCoatRoughness = 0, this.setValues(t)
            }

            function Da(t) {
                mn.call(this), this.type = "MeshPhongMaterial", this.color = new un(16777215), this.specular = new un(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ne, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Fa(t) {
                Da.call(this), this.defines = {
                    TOON: ""
                }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
            }

            function ka(t) {
                mn.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ne, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function Na(t) {
                mn.call(this), this.type = "MeshLambertMaterial", this.color = new un(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new un(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = tt, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.setValues(t)
            }

            function za(t) {
                mn.call(this), this.defines = {
                    MATCAP: ""
                }, this.type = "MeshMatcapMaterial", this.color = new un(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Ne, this.normalScale = new He(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.skinning = !1, this.morphTargets = !1, this.morphNormals = !1, this.lights = !1, this.setValues(t)
            }

            function Ga(t) {
                so.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
            }
            Pa.prototype = Object.create(mn.prototype), Pa.prototype.constructor = Pa, Pa.prototype.isShadowMaterial = !0, Pa.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this
            }, Oa.prototype = Object.create(Hn.prototype), Oa.prototype.constructor = Oa, Oa.prototype.isRawShaderMaterial = !0, Ia.prototype = Object.create(mn.prototype), Ia.prototype.constructor = Ia, Ia.prototype.isMeshStandardMaterial = !0, Ia.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.defines = {
                    STANDARD: ""
                }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Ba.prototype = Object.create(Ia.prototype), Ba.prototype.constructor = Ba, Ba.prototype.isMeshPhysicalMaterial = !0, Ba.prototype.copy = function(t) {
                return Ia.prototype.copy.call(this, t), this.defines = {
                    PHYSICAL: ""
                }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
            }, Da.prototype = Object.create(mn.prototype), Da.prototype.constructor = Da, Da.prototype.isMeshPhongMaterial = !0, Da.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Fa.prototype = Object.create(Da.prototype), Fa.prototype.constructor = Fa, Fa.prototype.isMeshToonMaterial = !0, Fa.prototype.copy = function(t) {
                return Da.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
            }, ka.prototype = Object.create(mn.prototype), ka.prototype.constructor = ka, ka.prototype.isMeshNormalMaterial = !0, ka.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Na.prototype = Object.create(mn.prototype), Na.prototype.constructor = Na, Na.prototype.isMeshLambertMaterial = !0, Na.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, za.prototype = Object.create(mn.prototype), za.prototype.constructor = za, za.prototype.isMeshMatcapMaterial = !0, za.prototype.copy = function(t) {
                return mn.prototype.copy.call(this, t), this.defines = {
                    MATCAP: ""
                }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
            }, Ga.prototype = Object.create(so.prototype), Ga.prototype.constructor = Ga, Ga.prototype.isLineDashedMaterial = !0, Ga.prototype.copy = function(t) {
                return so.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
            };
            var Ha = Object.freeze({
                    ShadowMaterial: Pa,
                    SpriteMaterial: eo,
                    RawShaderMaterial: Oa,
                    ShaderMaterial: Hn,
                    PointsMaterial: ho,
                    MeshPhysicalMaterial: Ba,
                    MeshStandardMaterial: Ia,
                    MeshPhongMaterial: Da,
                    MeshToonMaterial: Fa,
                    MeshNormalMaterial: ka,
                    MeshLambertMaterial: Na,
                    MeshDepthMaterial: Fi,
                    MeshDistanceMaterial: ki,
                    MeshBasicMaterial: vn,
                    MeshMatcapMaterial: za,
                    LineDashedMaterial: Ga,
                    LineBasicMaterial: so,
                    Material: mn
                }),
                Ua = {
                    arraySlice: function(t, e, n) {
                        return Ua.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
                    },
                    convertArray: function(t, e, n) {
                        return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
                    },
                    isTypedArray: function(t) {
                        return ArrayBuffer.isView(t) && !(t instanceof DataView)
                    },
                    getKeyframeOrder: function(t) {
                        for (var e = t.length, n = new Array(e), r = 0; r !== e; ++r) n[r] = r;
                        return n.sort(function(e, n) {
                            return t[e] - t[n]
                        }), n
                    },
                    sortedArray: function(t, e, n) {
                        for (var r = t.length, i = new t.constructor(r), o = 0, a = 0; a !== r; ++o)
                            for (var s = n[o] * e, c = 0; c !== e; ++c) i[a++] = t[s + c];
                        return i
                    },
                    flattenJSON: function(t, e, n, r) {
                        for (var i = 1, o = t[0]; void 0 !== o && void 0 === o[r];) o = t[i++];
                        if (void 0 !== o) {
                            var a = o[r];
                            if (void 0 !== a)
                                if (Array.isArray(a))
                                    do {
                                        void 0 !== (a = o[r]) && (e.push(o.time), n.push.apply(n, a)), o = t[i++]
                                    } while (void 0 !== o);
                                else if (void 0 !== a.toArray)
                                do {
                                    void 0 !== (a = o[r]) && (e.push(o.time), a.toArray(n, n.length)), o = t[i++]
                                } while (void 0 !== o);
                            else
                                do {
                                    void 0 !== (a = o[r]) && (e.push(o.time), n.push(a)), o = t[i++]
                                } while (void 0 !== o)
                        }
                    }
                };

            function ja(t, e, n, r) {
                this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n
            }

            function Va(t, e, n, r) {
                ja.call(this, t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0
            }

            function Wa(t, e, n, r) {
                ja.call(this, t, e, n, r)
            }

            function qa(t, e, n, r) {
                ja.call(this, t, e, n, r)
            }

            function Xa(t, e, n, r) {
                if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
                if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
                this.name = t, this.times = Ua.convertArray(e, this.TimeBufferType), this.values = Ua.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
            }

            function Ya(t, e, n) {
                Xa.call(this, t, e, n)
            }

            function Ja(t, e, n, r) {
                Xa.call(this, t, e, n, r)
            }

            function Za(t, e, n, r) {
                Xa.call(this, t, e, n, r)
            }

            function Qa(t, e, n, r) {
                ja.call(this, t, e, n, r)
            }

            function Ka(t, e, n, r) {
                Xa.call(this, t, e, n, r)
            }

            function $a(t, e, n, r) {
                Xa.call(this, t, e, n, r)
            }

            function ts(t, e, n, r) {
                Xa.call(this, t, e, n, r)
            }

            function es(t, e, n) {
                this.name = t, this.tracks = n, this.duration = void 0 !== e ? e : -1, this.uuid = Ge.generateUUID(), this.duration < 0 && this.resetDuration()
            }

            function ns(t) {
                if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
                var e = function(t) {
                    switch (t.toLowerCase()) {
                        case "scalar":
                        case "double":
                        case "float":
                        case "number":
                        case "integer":
                            return Za;
                        case "vector":
                        case "vector2":
                        case "vector3":
                        case "vector4":
                            return ts;
                        case "color":
                            return Ja;
                        case "quaternion":
                            return Ka;
                        case "bool":
                        case "boolean":
                            return Ya;
                        case "string":
                            return $a
                    }
                    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
                }(t.type);
                if (void 0 === t.times) {
                    var n = [],
                        r = [];
                    Ua.flattenJSON(t.keys, n, r, "value"), t.times = n, t.values = r
                }
                return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
            }
            Object.assign(ja.prototype, {
                evaluate: function(t) {
                    var e = this.parameterPositions,
                        n = this._cachedIndex,
                        r = e[n],
                        i = e[n - 1];
                    t: {
                        e: {
                            var o;
                            n: {
                                r: if (!(t < r)) {
                                    for (var a = n + 2;;) {
                                        if (void 0 === r) {
                                            if (t < i) break r;
                                            return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, i)
                                        }
                                        if (n === a) break;
                                        if (i = r, t < (r = e[++n])) break e
                                    }
                                    o = e.length;
                                    break n
                                }if (t >= i) break t;
                                var s = e[1];
                                for (t < s && (n = 2, i = s), a = n - 2;;) {
                                    if (void 0 === i) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                                    if (n === a) break;
                                    if (r = i, t >= (i = e[--n - 1])) break e
                                }
                                o = n,
                                n = 0
                            }
                            for (; n < o;) {
                                var c = n + o >>> 1;
                                t < e[c] ? o = c : n = c + 1
                            }
                            if (r = e[n], void 0 === (i = e[n - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
                            if (void 0 === r) return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, i, t)
                        }
                        this._cachedIndex = n,
                        this.intervalChanged_(n, i, r)
                    }
                    return this.interpolate_(n, i, t, r)
                },
                settings: null,
                DefaultSettings_: {},
                getSettings_: function() {
                    return this.settings || this.DefaultSettings_
                },
                copySampleValue_: function(t) {
                    for (var e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, i = t * r, o = 0; o !== r; ++o) e[o] = n[i + o];
                    return e
                },
                interpolate_: function() {
                    throw new Error("call to abstract method")
                },
                intervalChanged_: function() {}
            }), Object.assign(ja.prototype, {
                beforeStart_: ja.prototype.copySampleValue_,
                afterEnd_: ja.prototype.copySampleValue_
            }), Va.prototype = Object.assign(Object.create(ja.prototype), {
                constructor: Va,
                DefaultSettings_: {
                    endingStart: _e,
                    endingEnd: _e
                },
                intervalChanged_: function(t, e, n) {
                    var r = this.parameterPositions,
                        i = t - 2,
                        o = t + 1,
                        a = r[i],
                        s = r[o];
                    if (void 0 === a) switch (this.getSettings_().endingStart) {
                        case Me:
                            i = t, a = 2 * e - n;
                            break;
                        case Ee:
                            a = e + r[i = r.length - 2] - r[i + 1];
                            break;
                        default:
                            i = t, a = n
                    }
                    if (void 0 === s) switch (this.getSettings_().endingEnd) {
                        case Me:
                            o = t, s = 2 * n - e;
                            break;
                        case Ee:
                            o = 1, s = n + r[1] - r[0];
                            break;
                        default:
                            o = t - 1, s = e
                    }
                    var c = .5 * (n - e),
                        u = this.valueSize;
                    this._weightPrev = c / (e - a), this._weightNext = c / (s - n), this._offsetPrev = i * u, this._offsetNext = o * u
                },
                interpolate_: function(t, e, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, u = this._offsetPrev, l = this._offsetNext, h = this._weightPrev, p = this._weightNext, d = (n - e) / (r - e), f = d * d, m = f * d, v = -h * m + 2 * h * f - h * d, g = (1 + h) * m + (-1.5 - 2 * h) * f + (-.5 + h) * d + 1, y = (-1 - p) * m + (1.5 + p) * f + .5 * d, x = p * m - p * f, b = 0; b !== a; ++b) i[b] = v * o[u + b] + g * o[c + b] + y * o[s + b] + x * o[l + b];
                    return i
                }
            }), Wa.prototype = Object.assign(Object.create(ja.prototype), {
                constructor: Wa,
                interpolate_: function(t, e, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = s - a, u = (n - e) / (r - e), l = 1 - u, h = 0; h !== a; ++h) i[h] = o[c + h] * l + o[s + h] * u;
                    return i
                }
            }), qa.prototype = Object.assign(Object.create(ja.prototype), {
                constructor: qa,
                interpolate_: function(t) {
                    return this.copySampleValue_(t - 1)
                }
            }), Object.assign(Xa, {
                toJSON: function(t) {
                    var e, n = t.constructor;
                    if (void 0 !== n.toJSON) e = n.toJSON(t);
                    else {
                        e = {
                            name: t.name,
                            times: Ua.convertArray(t.times, Array),
                            values: Ua.convertArray(t.values, Array)
                        };
                        var r = t.getInterpolation();
                        r !== t.DefaultInterpolation && (e.interpolation = r)
                    }
                    return e.type = t.ValueTypeName, e
                }
            }), Object.assign(Xa.prototype, {
                constructor: Xa,
                TimeBufferType: Float32Array,
                ValueBufferType: Float32Array,
                DefaultInterpolation: be,
                InterpolantFactoryMethodDiscrete: function(t) {
                    return new qa(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodLinear: function(t) {
                    return new Wa(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: function(t) {
                    return new Va(this.times, this.values, this.getValueSize(), t)
                },
                setInterpolation: function(t) {
                    var e;
                    switch (t) {
                        case xe:
                            e = this.InterpolantFactoryMethodDiscrete;
                            break;
                        case be:
                            e = this.InterpolantFactoryMethodLinear;
                            break;
                        case we:
                            e = this.InterpolantFactoryMethodSmooth
                    }
                    if (void 0 === e) {
                        var n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
                        if (void 0 === this.createInterpolant) {
                            if (t === this.DefaultInterpolation) throw new Error(n);
                            this.setInterpolation(this.DefaultInterpolation)
                        }
                        return console.warn("THREE.KeyframeTrack:", n), this
                    }
                    return this.createInterpolant = e, this
                },
                getInterpolation: function() {
                    switch (this.createInterpolant) {
                        case this.InterpolantFactoryMethodDiscrete:
                            return xe;
                        case this.InterpolantFactoryMethodLinear:
                            return be;
                        case this.InterpolantFactoryMethodSmooth:
                            return we
                    }
                },
                getValueSize: function() {
                    return this.values.length / this.times.length
                },
                shift: function(t) {
                    if (0 !== t)
                        for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] += t;
                    return this
                },
                scale: function(t) {
                    if (1 !== t)
                        for (var e = this.times, n = 0, r = e.length; n !== r; ++n) e[n] *= t;
                    return this
                },
                trim: function(t, e) {
                    for (var n = this.times, r = n.length, i = 0, o = r - 1; i !== r && n[i] < t;) ++i;
                    for (; - 1 !== o && n[o] > e;) --o;
                    if (++o, 0 !== i || o !== r) {
                        i >= o && (i = (o = Math.max(o, 1)) - 1);
                        var a = this.getValueSize();
                        this.times = Ua.arraySlice(n, i, o), this.values = Ua.arraySlice(this.values, i * a, o * a)
                    }
                    return this
                },
                validate: function() {
                    var t = !0,
                        e = this.getValueSize();
                    e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
                    var n = this.times,
                        r = this.values,
                        i = n.length;
                    0 === i && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
                    for (var o = null, a = 0; a !== i; a++) {
                        var s = n[a];
                        if ("number" == typeof s && isNaN(s)) {
                            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, s), t = !1;
                            break
                        }
                        if (null !== o && o > s) {
                            console.error("THREE.KeyframeTrack: Out of order keys.", this, a, s, o), t = !1;
                            break
                        }
                        o = s
                    }
                    if (void 0 !== r && Ua.isTypedArray(r)) {
                        a = 0;
                        for (var c = r.length; a !== c; ++a) {
                            var u = r[a];
                            if (isNaN(u)) {
                                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), t = !1;
                                break
                            }
                        }
                    }
                    return t
                },
                optimize: function() {
                    for (var t = this.times, e = this.values, n = this.getValueSize(), r = this.getInterpolation() === we, i = 1, o = t.length - 1, a = 1; a < o; ++a) {
                        var s = !1,
                            c = t[a];
                        if (c !== t[a + 1] && (1 !== a || c !== c[0]))
                            if (r) s = !0;
                            else
                                for (var u = a * n, l = u - n, h = u + n, p = 0; p !== n; ++p) {
                                    var d = e[u + p];
                                    if (d !== e[l + p] || d !== e[h + p]) {
                                        s = !0;
                                        break
                                    }
                                }
                            if (s) {
                                if (a !== i) {
                                    t[i] = t[a];
                                    var f = a * n,
                                        m = i * n;
                                    for (p = 0; p !== n; ++p) e[m + p] = e[f + p]
                                }++i
                            }
                    }
                    if (o > 0) {
                        for (t[i] = t[o], f = o * n, m = i * n, p = 0; p !== n; ++p) e[m + p] = e[f + p];
                        ++i
                    }
                    return i !== t.length && (this.times = Ua.arraySlice(t, 0, i), this.values = Ua.arraySlice(e, 0, i * n)), this
                },
                clone: function() {
                    var t = Ua.arraySlice(this.times, 0),
                        e = Ua.arraySlice(this.values, 0),
                        n = new(0, this.constructor)(this.name, t, e);
                    return n.createInterpolant = this.createInterpolant, n
                }
            }), Ya.prototype = Object.assign(Object.create(Xa.prototype), {
                constructor: Ya,
                ValueTypeName: "bool",
                ValueBufferType: Array,
                DefaultInterpolation: xe,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), Ja.prototype = Object.assign(Object.create(Xa.prototype), {
                constructor: Ja,
                ValueTypeName: "color"
            }), Za.prototype = Object.assign(Object.create(Xa.prototype), {
                constructor: Za,
                ValueTypeName: "number"
            }), Qa.prototype = Object.assign(Object.create(ja.prototype), {
                constructor: Qa,
                interpolate_: function(t, e, n, r) {
                    for (var i = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = t * a, c = (n - e) / (r - e), u = s + a; s !== u; s += 4) Ue.slerpFlat(i, 0, o, s - a, o, s, c);
                    return i
                }
            }), Ka.prototype = Object.assign(Object.create(Xa.prototype), {
                constructor: Ka,
                ValueTypeName: "quaternion",
                DefaultInterpolation: be,
                InterpolantFactoryMethodLinear: function(t) {
                    return new Qa(this.times, this.values, this.getValueSize(), t)
                },
                InterpolantFactoryMethodSmooth: void 0
            }), $a.prototype = Object.assign(Object.create(Xa.prototype), {
                constructor: $a,
                ValueTypeName: "string",
                ValueBufferType: Array,
                DefaultInterpolation: xe,
                InterpolantFactoryMethodLinear: void 0,
                InterpolantFactoryMethodSmooth: void 0
            }), ts.prototype = Object.assign(Object.create(Xa.prototype), {
                constructor: ts,
                ValueTypeName: "vector"
            }), Object.assign(es, {
                parse: function(t) {
                    for (var e = [], n = t.tracks, r = 1 / (t.fps || 1), i = 0, o = n.length; i !== o; ++i) e.push(ns(n[i]).scale(r));
                    return new es(t.name, t.duration, e)
                },
                toJSON: function(t) {
                    for (var e = [], n = t.tracks, r = {
                            name: t.name,
                            duration: t.duration,
                            tracks: e,
                            uuid: t.uuid
                        }, i = 0, o = n.length; i !== o; ++i) e.push(Xa.toJSON(n[i]));
                    return r
                },
                CreateFromMorphTargetSequence: function(t, e, n, r) {
                    for (var i = e.length, o = [], a = 0; a < i; a++) {
                        var s = [],
                            c = [];
                        s.push((a + i - 1) % i, a, (a + 1) % i), c.push(0, 1, 0);
                        var u = Ua.getKeyframeOrder(s);
                        s = Ua.sortedArray(s, 1, u), c = Ua.sortedArray(c, 1, u), r || 0 !== s[0] || (s.push(i), c.push(c[0])), o.push(new Za(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / n))
                    }
                    return new es(t, -1, o)
                },
                findByName: function(t, e) {
                    var n = t;
                    if (!Array.isArray(t)) {
                        var r = t;
                        n = r.geometry && r.geometry.animations || r.animations
                    }
                    for (var i = 0; i < n.length; i++)
                        if (n[i].name === e) return n[i];
                    return null
                },
                CreateClipsFromMorphTargetSequences: function(t, e, n) {
                    for (var r = {}, i = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) {
                        var s = t[o],
                            c = s.name.match(i);
                        if (c && c.length > 1) {
                            var u = r[h = c[1]];
                            u || (r[h] = u = []), u.push(s)
                        }
                    }
                    var l = [];
                    for (var h in r) l.push(es.CreateFromMorphTargetSequence(h, r[h], e, n));
                    return l
                },
                parseAnimation: function(t, e) {
                    if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
                    for (var n = function(t, e, n, r, i) {
                            if (0 !== n.length) {
                                var o = [],
                                    a = [];
                                Ua.flattenJSON(n, o, a, r), 0 !== o.length && i.push(new t(e, o, a))
                            }
                        }, r = [], i = t.name || "default", o = t.length || -1, a = t.fps || 30, s = t.hierarchy || [], c = 0; c < s.length; c++) {
                        var u = s[c].keys;
                        if (u && 0 !== u.length)
                            if (u[0].morphTargets) {
                                for (var l = {}, h = 0; h < u.length; h++)
                                    if (u[h].morphTargets)
                                        for (var p = 0; p < u[h].morphTargets.length; p++) l[u[h].morphTargets[p]] = -1;
                                for (var d in l) {
                                    var f = [],
                                        m = [];
                                    for (p = 0; p !== u[h].morphTargets.length; ++p) {
                                        var v = u[h];
                                        f.push(v.time), m.push(v.morphTarget === d ? 1 : 0)
                                    }
                                    r.push(new Za(".morphTargetInfluence[" + d + "]", f, m))
                                }
                                o = l.length * (a || 1)
                            } else {
                                var g = ".bones[" + e[c].name + "]";
                                n(ts, g + ".position", u, "pos", r), n(Ka, g + ".quaternion", u, "rot", r), n(ts, g + ".scale", u, "scl", r)
                            }
                    }
                    return 0 === r.length ? null : new es(i, o, r)
                }
            }), Object.assign(es.prototype, {
                resetDuration: function() {
                    for (var t = 0, e = 0, n = this.tracks.length; e !== n; ++e) {
                        var r = this.tracks[e];
                        t = Math.max(t, r.times[r.times.length - 1])
                    }
                    return this.duration = t, this
                },
                trim: function() {
                    for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
                    return this
                },
                validate: function() {
                    for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
                    return t
                },
                optimize: function() {
                    for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
                    return this
                },
                clone: function() {
                    for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
                    return new es(this.name, this.duration, t)
                }
            });
            var rs = {
                enabled: !1,
                files: {},
                add: function(t, e) {
                    !1 !== this.enabled && (this.files[t] = e)
                },
                get: function(t) {
                    if (!1 !== this.enabled) return this.files[t]
                },
                remove: function(t) {
                    delete this.files[t]
                },
                clear: function() {
                    this.files = {}
                }
            };

            function is(t, e, n) {
                var r = this,
                    i = !1,
                    o = 0,
                    a = 0,
                    s = void 0;
                this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
                    a++, !1 === i && void 0 !== r.onStart && r.onStart(t, o, a), i = !0
                }, this.itemEnd = function(t) {
                    o++, void 0 !== r.onProgress && r.onProgress(t, o, a), o === a && (i = !1, void 0 !== r.onLoad && r.onLoad())
                }, this.itemError = function(t) {
                    void 0 !== r.onError && r.onError(t)
                }, this.resolveURL = function(t) {
                    return s ? s(t) : t
                }, this.setURLModifier = function(t) {
                    return s = t, this
                }
            }
            var os = new is,
                as = {};

            function ss(t) {
                this.manager = void 0 !== t ? t : os
            }

            function cs(t) {
                this.manager = void 0 !== t ? t : os
            }

            function us(t) {
                this.manager = void 0 !== t ? t : os, this._parser = null
            }

            function ls(t) {
                this.manager = void 0 !== t ? t : os, this._parser = null
            }

            function hs(t) {
                this.manager = void 0 !== t ? t : os
            }

            function ps(t) {
                this.manager = void 0 !== t ? t : os
            }

            function ds(t) {
                this.manager = void 0 !== t ? t : os
            }

            function fs() {
                this.type = "Curve", this.arcLengthDivisions = 200
            }

            function ms(t, e, n, r, i, o, a, s) {
                fs.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = n || 1, this.yRadius = r || 1, this.aStartAngle = i || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0
            }

            function vs(t, e, n, r, i, o) {
                ms.call(this, t, e, n, n, r, i, o), this.type = "ArcCurve"
            }

            function gs() {
                var t = 0,
                    e = 0,
                    n = 0,
                    r = 0;

                function i(i, o, a, s) {
                    t = i, e = a, n = -3 * i + 3 * o - 2 * a - s, r = 2 * i - 2 * o + a + s
                }
                return {
                    initCatmullRom: function(t, e, n, r, o) {
                        i(e, n, o * (n - t), o * (r - e))
                    },
                    initNonuniformCatmullRom: function(t, e, n, r, o, a, s) {
                        var c = (e - t) / o - (n - t) / (o + a) + (n - e) / a,
                            u = (n - e) / a - (r - e) / (a + s) + (r - n) / s;
                        i(e, n, c *= a, u *= a)
                    },
                    calc: function(i) {
                        var o = i * i;
                        return t + e * i + n * o + r * (o * i)
                    }
                }
            }
            Object.assign(ss.prototype, {
                load: function(t, e, n, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var i = this,
                        o = rs.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                        e && e(o), i.manager.itemEnd(t)
                    }, 0), o;
                    if (void 0 === as[t]) {
                        var a = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                        if (a) {
                            var s = a[1],
                                c = !!a[2],
                                u = a[3];
                            u = decodeURIComponent(u), c && (u = atob(u));
                            try {
                                var l, h = (this.responseType || "").toLowerCase();
                                switch (h) {
                                    case "arraybuffer":
                                    case "blob":
                                        for (var p = new Uint8Array(u.length), d = 0; d < u.length; d++) p[d] = u.charCodeAt(d);
                                        l = "blob" === h ? new Blob([p.buffer], {
                                            type: s
                                        }) : p.buffer;
                                        break;
                                    case "document":
                                        var f = new DOMParser;
                                        l = f.parseFromString(u, s);
                                        break;
                                    case "json":
                                        l = JSON.parse(u);
                                        break;
                                    default:
                                        l = u
                                }
                                setTimeout(function() {
                                    e && e(l), i.manager.itemEnd(t)
                                }, 0)
                            } catch (e) {
                                setTimeout(function() {
                                    r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                                }, 0)
                            }
                        } else {
                            as[t] = [], as[t].push({
                                onLoad: e,
                                onProgress: n,
                                onError: r
                            });
                            var m = new XMLHttpRequest;
                            for (var v in m.open("GET", t, !0), m.addEventListener("load", function(e) {
                                    var n = this.response;
                                    rs.add(t, n);
                                    var r = as[t];
                                    if (delete as[t], 200 === this.status || 0 === this.status) {
                                        0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                                        for (var o = 0, a = r.length; o < a; o++) {
                                            var s = r[o];
                                            s.onLoad && s.onLoad(n)
                                        }
                                        i.manager.itemEnd(t)
                                    } else {
                                        for (o = 0, a = r.length; o < a; o++)(s = r[o]).onError && s.onError(e);
                                        i.manager.itemError(t), i.manager.itemEnd(t)
                                    }
                                }, !1), m.addEventListener("progress", function(e) {
                                    for (var n = as[t], r = 0, i = n.length; r < i; r++) {
                                        var o = n[r];
                                        o.onProgress && o.onProgress(e)
                                    }
                                }, !1), m.addEventListener("error", function(e) {
                                    var n = as[t];
                                    delete as[t];
                                    for (var r = 0, o = n.length; r < o; r++) {
                                        var a = n[r];
                                        a.onError && a.onError(e)
                                    }
                                    i.manager.itemError(t), i.manager.itemEnd(t)
                                }, !1), m.addEventListener("abort", function(e) {
                                    var n = as[t];
                                    delete as[t];
                                    for (var r = 0, o = n.length; r < o; r++) {
                                        var a = n[r];
                                        a.onError && a.onError(e)
                                    }
                                    i.manager.itemError(t), i.manager.itemEnd(t)
                                }, !1), void 0 !== this.responseType && (m.responseType = this.responseType), void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials), m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) m.setRequestHeader(v, this.requestHeader[v]);
                            m.send(null)
                        }
                        return i.manager.itemStart(t), m
                    }
                    as[t].push({
                        onLoad: e,
                        onProgress: n,
                        onError: r
                    })
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResponseType: function(t) {
                    return this.responseType = t, this
                },
                setWithCredentials: function(t) {
                    return this.withCredentials = t, this
                },
                setMimeType: function(t) {
                    return this.mimeType = t, this
                },
                setRequestHeader: function(t) {
                    return this.requestHeader = t, this
                }
            }), Object.assign(cs.prototype, {
                load: function(t, e, n, r) {
                    var i = this,
                        o = new ss(i.manager);
                    o.setPath(i.path), o.load(t, function(t) {
                        e(i.parse(JSON.parse(t)))
                    }, n, r)
                },
                parse: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var r = es.parse(t[n]);
                        e.push(r)
                    }
                    return e
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(us.prototype, {
                load: function(t, e, n, r) {
                    var i = this,
                        o = [],
                        a = new mo;
                    a.image = o;
                    var s = new ss(this.manager);

                    function c(c) {
                        s.load(t[c], function(t) {
                            var n = i._parser(t, !0);
                            o[c] = {
                                width: n.width,
                                height: n.height,
                                format: n.format,
                                mipmaps: n.mipmaps
                            }, 6 === (u += 1) && (1 === n.mipmapCount && (a.minFilter = Mt), a.format = n.format, a.needsUpdate = !0, e && e(a))
                        }, n, r)
                    }
                    if (s.setPath(this.path), s.setResponseType("arraybuffer"), Array.isArray(t))
                        for (var u = 0, l = 0, h = t.length; l < h; ++l) c(l);
                    else s.load(t, function(t) {
                        var n = i._parser(t, !0);
                        if (n.isCubemap)
                            for (var r = n.mipmaps.length / n.mipmapCount, s = 0; s < r; s++) {
                                o[s] = {
                                    mipmaps: []
                                };
                                for (var c = 0; c < n.mipmapCount; c++) o[s].mipmaps.push(n.mipmaps[s * n.mipmapCount + c]), o[s].format = n.format, o[s].width = n.width, o[s].height = n.height
                            } else a.image.width = n.width, a.image.height = n.height, a.mipmaps = n.mipmaps;
                        1 === n.mipmapCount && (a.minFilter = Mt), a.format = n.format, a.needsUpdate = !0, e && e(a)
                    }, n, r);
                    return a
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ls.prototype, {
                load: function(t, e, n, r) {
                    var i = this,
                        o = new Yn,
                        a = new ss(this.manager);
                    return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, function(t) {
                        var n = i._parser(t);
                        n && (void 0 !== n.image ? o.image = n.image : void 0 !== n.data && (o.image.width = n.width, o.image.height = n.height, o.image.data = n.data), o.wrapS = void 0 !== n.wrapS ? n.wrapS : yt, o.wrapT = void 0 !== n.wrapT ? n.wrapT : yt, o.magFilter = void 0 !== n.magFilter ? n.magFilter : Mt, o.minFilter = void 0 !== n.minFilter ? n.minFilter : St, o.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1, void 0 !== n.format && (o.format = n.format), void 0 !== n.type && (o.type = n.type), void 0 !== n.mipmaps && (o.mipmaps = n.mipmaps), 1 === n.mipmapCount && (o.minFilter = Mt), o.needsUpdate = !0, e && e(o, n))
                    }, n, r), o
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(hs.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var i = this,
                        o = rs.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                        e && e(o), i.manager.itemEnd(t)
                    }, 0), o;
                    var a = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

                    function s() {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), rs.add(t, this), e && e(this), i.manager.itemEnd(t)
                    }

                    function c(e) {
                        a.removeEventListener("load", s, !1), a.removeEventListener("error", c, !1), r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                    }
                    return a.addEventListener("load", s, !1), a.addEventListener("error", c, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (a.crossOrigin = this.crossOrigin), i.manager.itemStart(t), a.src = t, a
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ps.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, r) {
                    var i = new mr,
                        o = new hs(this.manager);
                    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
                    var a = 0;

                    function s(n) {
                        o.load(t[n], function(t) {
                            i.images[n] = t, 6 === ++a && (i.needsUpdate = !0, e && e(i))
                        }, void 0, r)
                    }
                    for (var c = 0; c < t.length; ++c) s(c);
                    return i
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(ds.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, r) {
                    var i = new Xe,
                        o = new hs(this.manager);
                    return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, function(n) {
                        i.image = n;
                        var r = t.search(/\.jpe?g($|\?)/i) > 0 || 0 === t.search(/^data\:image\/jpeg/);
                        i.format = r ? zt : Gt, i.needsUpdate = !0, void 0 !== e && e(i)
                    }, n, r), i
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(fs.prototype, {
                getPoint: function() {
                    return console.warn("THREE.Curve: .getPoint() not implemented."), null
                },
                getPointAt: function(t, e) {
                    var n = this.getUtoTmapping(t);
                    return this.getPoint(n, e)
                },
                getPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return e
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 5);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
                    return e
                },
                getLength: function() {
                    var t = this.getLengths();
                    return t[t.length - 1]
                },
                getLengths: function(t) {
                    if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
                    this.needsUpdate = !1;
                    var e, n, r = [],
                        i = this.getPoint(0),
                        o = 0;
                    for (r.push(0), n = 1; n <= t; n++) o += (e = this.getPoint(n / t)).distanceTo(i), r.push(o), i = e;
                    return this.cacheArcLengths = r, r
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.getLengths()
                },
                getUtoTmapping: function(t, e) {
                    var n, r = this.getLengths(),
                        i = 0,
                        o = r.length;
                    n = e || t * r[o - 1];
                    for (var a, s = 0, c = o - 1; s <= c;)
                        if ((a = r[i = Math.floor(s + (c - s) / 2)] - n) < 0) s = i + 1;
                        else {
                            if (!(a > 0)) {
                                c = i;
                                break
                            }
                            c = i - 1
                        }
                    if (r[i = c] === n) return i / (o - 1);
                    var u = r[i];
                    return (i + (n - u) / (r[i + 1] - u)) / (o - 1)
                },
                getTangent: function(t) {
                    var e = t - 1e-4,
                        n = t + 1e-4;
                    e < 0 && (e = 0), n > 1 && (n = 1);
                    var r = this.getPoint(e);
                    return this.getPoint(n).clone().sub(r).normalize()
                },
                getTangentAt: function(t) {
                    var e = this.getUtoTmapping(t);
                    return this.getTangent(e)
                },
                computeFrenetFrames: function(t, e) {
                    var n, r, i, o = new je,
                        a = [],
                        s = [],
                        c = [],
                        u = new je,
                        l = new Qe;
                    for (n = 0; n <= t; n++) r = n / t, a[n] = this.getTangentAt(r), a[n].normalize();
                    s[0] = new je, c[0] = new je;
                    var h = Number.MAX_VALUE,
                        p = Math.abs(a[0].x),
                        d = Math.abs(a[0].y),
                        f = Math.abs(a[0].z);
                    for (p <= h && (h = p, o.set(1, 0, 0)), d <= h && (h = d, o.set(0, 1, 0)), f <= h && o.set(0, 0, 1), u.crossVectors(a[0], o).normalize(), s[0].crossVectors(a[0], u), c[0].crossVectors(a[0], s[0]), n = 1; n <= t; n++) s[n] = s[n - 1].clone(), c[n] = c[n - 1].clone(), u.crossVectors(a[n - 1], a[n]), u.length() > Number.EPSILON && (u.normalize(), i = Math.acos(Ge.clamp(a[n - 1].dot(a[n]), -1, 1)), s[n].applyMatrix4(l.makeRotationAxis(u, i))), c[n].crossVectors(a[n], s[n]);
                    if (!0 === e)
                        for (i = Math.acos(Ge.clamp(s[0].dot(s[t]), -1, 1)), i /= t, a[0].dot(u.crossVectors(s[0], s[t])) > 0 && (i = -i), n = 1; n <= t; n++) s[n].applyMatrix4(l.makeRotationAxis(a[n], i * n)), c[n].crossVectors(a[n], s[n]);
                    return {
                        tangents: a,
                        normals: s,
                        binormals: c
                    }
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                },
                toJSON: function() {
                    var t = {
                        metadata: {
                            version: 4.5,
                            type: "Curve",
                            generator: "Curve.toJSON"
                        }
                    };
                    return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
                },
                fromJSON: function(t) {
                    return this.arcLengthDivisions = t.arcLengthDivisions, this
                }
            }), ms.prototype = Object.create(fs.prototype), ms.prototype.constructor = ms, ms.prototype.isEllipseCurve = !0, ms.prototype.getPoint = function(t, e) {
                for (var n = e || new He, r = 2 * Math.PI, i = this.aEndAngle - this.aStartAngle, o = Math.abs(i) < Number.EPSILON; i < 0;) i += r;
                for (; i > r;) i -= r;
                i < Number.EPSILON && (i = o ? 0 : r), !0 !== this.aClockwise || o || (i === r ? i = -r : i -= r);
                var a = this.aStartAngle + t * i,
                    s = this.aX + this.xRadius * Math.cos(a),
                    c = this.aY + this.yRadius * Math.sin(a);
                if (0 !== this.aRotation) {
                    var u = Math.cos(this.aRotation),
                        l = Math.sin(this.aRotation),
                        h = s - this.aX,
                        p = c - this.aY;
                    s = h * u - p * l + this.aX, c = h * l + p * u + this.aY
                }
                return n.set(s, c)
            }, ms.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, ms.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
            }, ms.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
            }, vs.prototype = Object.create(ms.prototype), vs.prototype.constructor = vs, vs.prototype.isArcCurve = !0;
            var ys = new je,
                xs = new gs,
                bs = new gs,
                ws = new gs;

            function _s(t, e, n, r) {
                fs.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = n || "centripetal", this.tension = r || .5
            }

            function Ms(t, e, n, r, i) {
                var o = .5 * (r - e),
                    a = .5 * (i - n),
                    s = t * t;
                return (2 * n - 2 * r + o + a) * (t * s) + (-3 * n + 3 * r - 2 * o - a) * s + o * t + n
            }

            function Es(t, e, n, r) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * e
                }(t, e) + function(t, e) {
                    return 2 * (1 - t) * t * e
                }(t, n) + function(t, e) {
                    return t * t * e
                }(t, r)
            }

            function Ss(t, e, n, r, i) {
                return function(t, e) {
                    var n = 1 - t;
                    return n * n * n * e
                }(t, e) + function(t, e) {
                    var n = 1 - t;
                    return 3 * n * n * t * e
                }(t, n) + function(t, e) {
                    return 3 * (1 - t) * t * t * e
                }(t, r) + function(t, e) {
                    return t * t * t * e
                }(t, i)
            }

            function Ts(t, e, n, r) {
                fs.call(this), this.type = "CubicBezierCurve", this.v0 = t || new He, this.v1 = e || new He, this.v2 = n || new He, this.v3 = r || new He
            }

            function As(t, e, n, r) {
                fs.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new je, this.v1 = e || new je, this.v2 = n || new je, this.v3 = r || new je
            }

            function Ls(t, e) {
                fs.call(this), this.type = "LineCurve", this.v1 = t || new He, this.v2 = e || new He
            }

            function Cs(t, e) {
                fs.call(this), this.type = "LineCurve3", this.v1 = t || new je, this.v2 = e || new je
            }

            function Rs(t, e, n) {
                fs.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new He, this.v1 = e || new He, this.v2 = n || new He
            }

            function Ps(t, e, n) {
                fs.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new je, this.v1 = e || new je, this.v2 = n || new je
            }

            function Os(t) {
                fs.call(this), this.type = "SplineCurve", this.points = t || []
            }
            _s.prototype = Object.create(fs.prototype), _s.prototype.constructor = _s, _s.prototype.isCatmullRomCurve3 = !0, _s.prototype.getPoint = function(t, e) {
                var n, r, i, o, a = e || new je,
                    s = this.points,
                    c = s.length,
                    u = (c - (this.closed ? 0 : 1)) * t,
                    l = Math.floor(u),
                    h = u - l;
                if (this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c : 0 === h && l === c - 1 && (l = c - 2, h = 1), this.closed || l > 0 ? n = s[(l - 1) % c] : (ys.subVectors(s[0], s[1]).add(s[0]), n = ys), r = s[l % c], i = s[(l + 1) % c], this.closed || l + 2 < c ? o = s[(l + 2) % c] : (ys.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), o = ys), "centripetal" === this.curveType || "chordal" === this.curveType) {
                    var p = "chordal" === this.curveType ? .5 : .25,
                        d = Math.pow(n.distanceToSquared(r), p),
                        f = Math.pow(r.distanceToSquared(i), p),
                        m = Math.pow(i.distanceToSquared(o), p);
                    f < 1e-4 && (f = 1), d < 1e-4 && (d = f), m < 1e-4 && (m = f), xs.initNonuniformCatmullRom(n.x, r.x, i.x, o.x, d, f, m), bs.initNonuniformCatmullRom(n.y, r.y, i.y, o.y, d, f, m), ws.initNonuniformCatmullRom(n.z, r.z, i.z, o.z, d, f, m)
                } else "catmullrom" === this.curveType && (xs.initCatmullRom(n.x, r.x, i.x, o.x, this.tension), bs.initCatmullRom(n.y, r.y, i.y, o.y, this.tension), ws.initCatmullRom(n.z, r.z, i.z, o.z, this.tension));
                return a.set(xs.calc(h), bs.calc(h), ws.calc(h)), a
            }, _s.prototype.copy = function(t) {
                fs.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e];
                    this.points.push(r.clone())
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, _s.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var r = this.points[e];
                    t.points.push(r.toArray())
                }
                return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
            }, _s.prototype.fromJSON = function(t) {
                fs.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e];
                    this.points.push((new je).fromArray(r))
                }
                return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
            }, Ts.prototype = Object.create(fs.prototype), Ts.prototype.constructor = Ts, Ts.prototype.isCubicBezierCurve = !0, Ts.prototype.getPoint = function(t, e) {
                var n = e || new He,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Ss(t, r.x, i.x, o.x, a.x), Ss(t, r.y, i.y, o.y, a.y)), n
            }, Ts.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, Ts.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, Ts.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, As.prototype = Object.create(fs.prototype), As.prototype.constructor = As, As.prototype.isCubicBezierCurve3 = !0, As.prototype.getPoint = function(t, e) {
                var n = e || new je,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2,
                    a = this.v3;
                return n.set(Ss(t, r.x, i.x, o.x, a.x), Ss(t, r.y, i.y, o.y, a.y), Ss(t, r.z, i.z, o.z, a.z)), n
            }, As.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
            }, As.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
            }, As.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
            }, Ls.prototype = Object.create(fs.prototype), Ls.prototype.constructor = Ls, Ls.prototype.isLineCurve = !0, Ls.prototype.getPoint = function(t, e) {
                var n = e || new He;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, Ls.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Ls.prototype.getTangent = function() {
                return this.v2.clone().sub(this.v1).normalize()
            }, Ls.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ls.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ls.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Cs.prototype = Object.create(fs.prototype), Cs.prototype.constructor = Cs, Cs.prototype.isLineCurve3 = !0, Cs.prototype.getPoint = function(t, e) {
                var n = e || new je;
                return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
            }, Cs.prototype.getPointAt = function(t, e) {
                return this.getPoint(t, e)
            }, Cs.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Cs.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Cs.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Rs.prototype = Object.create(fs.prototype), Rs.prototype.constructor = Rs, Rs.prototype.isQuadraticBezierCurve = !0, Rs.prototype.getPoint = function(t, e) {
                var n = e || new He,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Es(t, r.x, i.x, o.x), Es(t, r.y, i.y, o.y)), n
            }, Rs.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Rs.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Rs.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Ps.prototype = Object.create(fs.prototype), Ps.prototype.constructor = Ps, Ps.prototype.isQuadraticBezierCurve3 = !0, Ps.prototype.getPoint = function(t, e) {
                var n = e || new je,
                    r = this.v0,
                    i = this.v1,
                    o = this.v2;
                return n.set(Es(t, r.x, i.x, o.x), Es(t, r.y, i.y, o.y), Es(t, r.z, i.z, o.z)), n
            }, Ps.prototype.copy = function(t) {
                return fs.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
            }, Ps.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
            }, Ps.prototype.fromJSON = function(t) {
                return fs.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
            }, Os.prototype = Object.create(fs.prototype), Os.prototype.constructor = Os, Os.prototype.isSplineCurve = !0, Os.prototype.getPoint = function(t, e) {
                var n = e || new He,
                    r = this.points,
                    i = (r.length - 1) * t,
                    o = Math.floor(i),
                    a = i - o,
                    s = r[0 === o ? o : o - 1],
                    c = r[o],
                    u = r[o > r.length - 2 ? r.length - 1 : o + 1],
                    l = r[o > r.length - 3 ? r.length - 1 : o + 2];
                return n.set(Ms(a, s.x, c.x, u.x, l.x), Ms(a, s.y, c.y, u.y, l.y)), n
            }, Os.prototype.copy = function(t) {
                fs.prototype.copy.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e];
                    this.points.push(r.clone())
                }
                return this
            }, Os.prototype.toJSON = function() {
                var t = fs.prototype.toJSON.call(this);
                t.points = [];
                for (var e = 0, n = this.points.length; e < n; e++) {
                    var r = this.points[e];
                    t.points.push(r.toArray())
                }
                return t
            }, Os.prototype.fromJSON = function(t) {
                fs.prototype.fromJSON.call(this, t), this.points = [];
                for (var e = 0, n = t.points.length; e < n; e++) {
                    var r = t.points[e];
                    this.points.push((new He).fromArray(r))
                }
                return this
            };
            var Is = Object.freeze({
                ArcCurve: vs,
                CatmullRomCurve3: _s,
                CubicBezierCurve: Ts,
                CubicBezierCurve3: As,
                EllipseCurve: ms,
                LineCurve: Ls,
                LineCurve3: Cs,
                QuadraticBezierCurve: Rs,
                QuadraticBezierCurve3: Ps,
                SplineCurve: Os
            });

            function Bs() {
                fs.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
            }

            function Ds(t) {
                Bs.call(this), this.type = "Path", this.currentPoint = new He, t && this.setFromPoints(t)
            }

            function Fs(t) {
                Ds.call(this, t), this.uuid = Ge.generateUUID(), this.type = "Shape", this.holes = []
            }

            function ks(t, e) {
                en.call(this), this.type = "Light", this.color = new un(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
            }

            function Ns(t, e, n) {
                ks.call(this, t, n), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(en.DefaultUp), this.updateMatrix(), this.groundColor = new un(e)
            }

            function zs(t) {
                this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new He(512, 512), this.map = null, this.matrix = new Qe
            }

            function Gs() {
                zs.call(this, new jn(50, 1, .5, 500))
            }

            function Hs(t, e, n, r, i, o) {
                ks.call(this, t, e), this.type = "SpotLight", this.position.copy(en.DefaultUp), this.updateMatrix(), this.target = new en, Object.defineProperty(this, "power", {
                    get: function() {
                        return this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / Math.PI
                    }
                }), this.distance = void 0 !== n ? n : 0, this.angle = void 0 !== r ? r : Math.PI / 3, this.penumbra = void 0 !== i ? i : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Gs
            }

            function Us(t, e, n, r) {
                ks.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
                    get: function() {
                        return 4 * this.intensity * Math.PI
                    },
                    set: function(t) {
                        this.intensity = t / (4 * Math.PI)
                    }
                }), this.distance = void 0 !== n ? n : 0, this.decay = void 0 !== r ? r : 1, this.shadow = new zs(new jn(90, 1, .5, 500))
            }

            function js(t, e, n, r, i, o) {
                Un.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== n ? n : 1, this.bottom = void 0 !== r ? r : -1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix()
            }

            function Vs() {
                zs.call(this, new js(-5, 5, 5, -5, .5, 500))
            }

            function Ws(t, e) {
                ks.call(this, t, e), this.type = "DirectionalLight", this.position.copy(en.DefaultUp), this.updateMatrix(), this.target = new en, this.shadow = new Vs
            }

            function qs(t, e) {
                ks.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
            }

            function Xs(t, e, n, r) {
                ks.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== n ? n : 10, this.height = void 0 !== r ? r : 10
            }

            function Ys(t) {
                this.manager = void 0 !== t ? t : os, this.textures = {}
            }
            Bs.prototype = Object.assign(Object.create(fs.prototype), {
                constructor: Bs,
                add: function(t) {
                    this.curves.push(t)
                },
                closePath: function() {
                    var t = this.curves[0].getPoint(0),
                        e = this.curves[this.curves.length - 1].getPoint(1);
                    t.equals(e) || this.curves.push(new Ls(e, t))
                },
                getPoint: function(t) {
                    for (var e = t * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
                        if (n[r] >= e) {
                            var i = n[r] - e,
                                o = this.curves[r],
                                a = o.getLength(),
                                s = 0 === a ? 0 : 1 - i / a;
                            return o.getPointAt(s)
                        }
                        r++
                    }
                    return null
                },
                getLength: function() {
                    var t = this.getCurveLengths();
                    return t[t.length - 1]
                },
                updateArcLengths: function() {
                    this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
                },
                getCurveLengths: function() {
                    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
                    for (var t = [], e = 0, n = 0, r = this.curves.length; n < r; n++) e += this.curves[n].getLength(), t.push(e);
                    return this.cacheLengths = t, t
                },
                getSpacedPoints: function(t) {
                    void 0 === t && (t = 40);
                    for (var e = [], n = 0; n <= t; n++) e.push(this.getPoint(n / t));
                    return this.autoClose && e.push(e[0]), e
                },
                getPoints: function(t) {
                    t = t || 12;
                    for (var e, n = [], r = 0, i = this.curves; r < i.length; r++)
                        for (var o = i[r], a = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t, s = o.getPoints(a), c = 0; c < s.length; c++) {
                            var u = s[c];
                            e && e.equals(u) || (n.push(u), e = u)
                        }
                    return this.autoClose && n.length > 1 && !n[n.length - 1].equals(n[0]) && n.push(n[0]), n
                },
                copy: function(t) {
                    fs.prototype.copy.call(this, t), this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var r = t.curves[e];
                        this.curves.push(r.clone())
                    }
                    return this.autoClose = t.autoClose, this
                },
                toJSON: function() {
                    var t = fs.prototype.toJSON.call(this);
                    t.autoClose = this.autoClose, t.curves = [];
                    for (var e = 0, n = this.curves.length; e < n; e++) {
                        var r = this.curves[e];
                        t.curves.push(r.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    fs.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
                    for (var e = 0, n = t.curves.length; e < n; e++) {
                        var r = t.curves[e];
                        this.curves.push((new Is[r.type]).fromJSON(r))
                    }
                    return this
                }
            }), Ds.prototype = Object.assign(Object.create(Bs.prototype), {
                constructor: Ds,
                setFromPoints: function(t) {
                    this.moveTo(t[0].x, t[0].y);
                    for (var e = 1, n = t.length; e < n; e++) this.lineTo(t[e].x, t[e].y)
                },
                moveTo: function(t, e) {
                    this.currentPoint.set(t, e)
                },
                lineTo: function(t, e) {
                    var n = new Ls(this.currentPoint.clone(), new He(t, e));
                    this.curves.push(n), this.currentPoint.set(t, e)
                },
                quadraticCurveTo: function(t, e, n, r) {
                    var i = new Rs(this.currentPoint.clone(), new He(t, e), new He(n, r));
                    this.curves.push(i), this.currentPoint.set(n, r)
                },
                bezierCurveTo: function(t, e, n, r, i, o) {
                    var a = new Ts(this.currentPoint.clone(), new He(t, e), new He(n, r), new He(i, o));
                    this.curves.push(a), this.currentPoint.set(i, o)
                },
                splineThru: function(t) {
                    var e = new Os([this.currentPoint.clone()].concat(t));
                    this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
                },
                arc: function(t, e, n, r, i, o) {
                    var a = this.currentPoint.x,
                        s = this.currentPoint.y;
                    this.absarc(t + a, e + s, n, r, i, o)
                },
                absarc: function(t, e, n, r, i, o) {
                    this.absellipse(t, e, n, n, r, i, o)
                },
                ellipse: function(t, e, n, r, i, o, a, s) {
                    var c = this.currentPoint.x,
                        u = this.currentPoint.y;
                    this.absellipse(t + c, e + u, n, r, i, o, a, s)
                },
                absellipse: function(t, e, n, r, i, o, a, s) {
                    var c = new ms(t, e, n, r, i, o, a, s);
                    if (this.curves.length > 0) {
                        var u = c.getPoint(0);
                        u.equals(this.currentPoint) || this.lineTo(u.x, u.y)
                    }
                    this.curves.push(c);
                    var l = c.getPoint(1);
                    this.currentPoint.copy(l)
                },
                copy: function(t) {
                    return Bs.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
                },
                toJSON: function() {
                    var t = Bs.prototype.toJSON.call(this);
                    return t.currentPoint = this.currentPoint.toArray(), t
                },
                fromJSON: function(t) {
                    return Bs.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
                }
            }), Fs.prototype = Object.assign(Object.create(Ds.prototype), {
                constructor: Fs,
                getPointsHoles: function(t) {
                    for (var e = [], n = 0, r = this.holes.length; n < r; n++) e[n] = this.holes[n].getPoints(t);
                    return e
                },
                extractPoints: function(t) {
                    return {
                        shape: this.getPoints(t),
                        holes: this.getPointsHoles(t)
                    }
                },
                copy: function(t) {
                    Ds.prototype.copy.call(this, t), this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var r = t.holes[e];
                        this.holes.push(r.clone())
                    }
                    return this
                },
                toJSON: function() {
                    var t = Ds.prototype.toJSON.call(this);
                    t.uuid = this.uuid, t.holes = [];
                    for (var e = 0, n = this.holes.length; e < n; e++) {
                        var r = this.holes[e];
                        t.holes.push(r.toJSON())
                    }
                    return t
                },
                fromJSON: function(t) {
                    Ds.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
                    for (var e = 0, n = t.holes.length; e < n; e++) {
                        var r = t.holes[e];
                        this.holes.push((new Ds).fromJSON(r))
                    }
                    return this
                }
            }), ks.prototype = Object.assign(Object.create(en.prototype), {
                constructor: ks,
                isLight: !0,
                copy: function(t) {
                    return en.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    var e = en.prototype.toJSON.call(this, t);
                    return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (e.object.distance = this.distance), void 0 !== this.angle && (e.object.angle = this.angle), void 0 !== this.decay && (e.object.decay = this.decay), void 0 !== this.penumbra && (e.object.penumbra = this.penumbra), void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()), e
                }
            }), Ns.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: Ns,
                isHemisphereLight: !0,
                copy: function(t) {
                    return ks.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
                }
            }), Object.assign(zs.prototype, {
                copy: function(t) {
                    return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = {};
                    return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
                }
            }), Gs.prototype = Object.assign(Object.create(zs.prototype), {
                constructor: Gs,
                isSpotLightShadow: !0,
                update: function(t) {
                    var e = this.camera,
                        n = 2 * Ge.RAD2DEG * t.angle,
                        r = this.mapSize.width / this.mapSize.height,
                        i = t.distance || e.far;
                    n === e.fov && r === e.aspect && i === e.far || (e.fov = n, e.aspect = r, e.far = i, e.updateProjectionMatrix())
                }
            }), Hs.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: Hs,
                isSpotLight: !0,
                copy: function(t) {
                    return ks.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), Us.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: Us,
                isPointLight: !0,
                copy: function(t) {
                    return ks.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
                }
            }), js.prototype = Object.assign(Object.create(Un.prototype), {
                constructor: js,
                isOrthographicCamera: !0,
                copy: function(t, e) {
                    return Un.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
                },
                setViewOffset: function(t, e, n, r, i, o) {
                    null === this.view && (this.view = {
                        enabled: !0,
                        fullWidth: 1,
                        fullHeight: 1,
                        offsetX: 0,
                        offsetY: 0,
                        width: 1,
                        height: 1
                    }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = i, this.view.height = o, this.updateProjectionMatrix()
                },
                clearViewOffset: function() {
                    null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
                },
                updateProjectionMatrix: function() {
                    var t = (this.right - this.left) / (2 * this.zoom),
                        e = (this.top - this.bottom) / (2 * this.zoom),
                        n = (this.right + this.left) / 2,
                        r = (this.top + this.bottom) / 2,
                        i = n - t,
                        o = n + t,
                        a = r + e,
                        s = r - e;
                    if (null !== this.view && this.view.enabled) {
                        var c = this.zoom / (this.view.width / this.view.fullWidth),
                            u = this.zoom / (this.view.height / this.view.fullHeight),
                            l = (this.right - this.left) / this.view.width,
                            h = (this.top - this.bottom) / this.view.height;
                        o = (i += l * (this.view.offsetX / c)) + l * (this.view.width / c), s = (a -= h * (this.view.offsetY / u)) - h * (this.view.height / u)
                    }
                    this.projectionMatrix.makeOrthographic(i, o, a, s, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
                },
                toJSON: function(t) {
                    var e = en.prototype.toJSON.call(this, t);
                    return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, null !== this.view && (e.object.view = Object.assign({}, this.view)), e
                }
            }), Vs.prototype = Object.assign(Object.create(zs.prototype), {
                constructor: Vs
            }), Ws.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: Ws,
                isDirectionalLight: !0,
                copy: function(t) {
                    return ks.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
                }
            }), qs.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: qs,
                isAmbientLight: !0
            }), Xs.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: Xs,
                isRectAreaLight: !0,
                copy: function(t) {
                    return ks.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
                },
                toJSON: function(t) {
                    var e = ks.prototype.toJSON.call(this, t);
                    return e.object.width = this.width, e.object.height = this.height, e
                }
            }), Object.assign(Ys.prototype, {
                load: function(t, e, n, r) {
                    var i = this,
                        o = new ss(i.manager);
                    o.setPath(i.path), o.load(t, function(t) {
                        e(i.parse(JSON.parse(t)))
                    }, n, r)
                },
                parse: function(t) {
                    var e = this.textures;

                    function n(t) {
                        return void 0 === e[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), e[t]
                    }
                    var r = new Ha[t.type];
                    if (void 0 !== t.uuid && (r.uuid = t.uuid), void 0 !== t.name && (r.name = t.name), void 0 !== t.color && r.color.setHex(t.color), void 0 !== t.roughness && (r.roughness = t.roughness), void 0 !== t.metalness && (r.metalness = t.metalness), void 0 !== t.emissive && r.emissive.setHex(t.emissive), void 0 !== t.specular && r.specular.setHex(t.specular), void 0 !== t.shininess && (r.shininess = t.shininess), void 0 !== t.clearCoat && (r.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (r.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (r.vertexColors = t.vertexColors), void 0 !== t.fog && (r.fog = t.fog), void 0 !== t.flatShading && (r.flatShading = t.flatShading), void 0 !== t.blending && (r.blending = t.blending), void 0 !== t.combine && (r.combine = t.combine), void 0 !== t.side && (r.side = t.side), void 0 !== t.opacity && (r.opacity = t.opacity), void 0 !== t.transparent && (r.transparent = t.transparent), void 0 !== t.alphaTest && (r.alphaTest = t.alphaTest), void 0 !== t.depthTest && (r.depthTest = t.depthTest), void 0 !== t.depthWrite && (r.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (r.colorWrite = t.colorWrite), void 0 !== t.wireframe && (r.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (r.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (r.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (r.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (r.rotation = t.rotation), 1 !== t.linewidth && (r.linewidth = t.linewidth), void 0 !== t.dashSize && (r.dashSize = t.dashSize), void 0 !== t.gapSize && (r.gapSize = t.gapSize), void 0 !== t.scale && (r.scale = t.scale), void 0 !== t.polygonOffset && (r.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (r.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (r.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (r.skinning = t.skinning), void 0 !== t.morphTargets && (r.morphTargets = t.morphTargets), void 0 !== t.morphNormals && (r.morphNormals = t.morphNormals), void 0 !== t.dithering && (r.dithering = t.dithering), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.uniforms)
                        for (var i in t.uniforms) {
                            var o = t.uniforms[i];
                            switch (r.uniforms[i] = {}, o.type) {
                                case "t":
                                    r.uniforms[i].value = n(o.value);
                                    break;
                                case "c":
                                    r.uniforms[i].value = (new un).setHex(o.value);
                                    break;
                                case "v2":
                                    r.uniforms[i].value = (new He).fromArray(o.value);
                                    break;
                                case "v3":
                                    r.uniforms[i].value = (new je).fromArray(o.value);
                                    break;
                                case "v4":
                                    r.uniforms[i].value = (new Ye).fromArray(o.value);
                                    break;
                                case "m3":
                                    r.uniforms[i].value = (new Ve).fromArray(o.value);
                                case "m4":
                                    r.uniforms[i].value = (new Qe).fromArray(o.value);
                                    break;
                                default:
                                    r.uniforms[i].value = o.value
                            }
                        }
                    if (void 0 !== t.defines && (r.defines = t.defines), void 0 !== t.vertexShader && (r.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (r.fragmentShader = t.fragmentShader), void 0 !== t.extensions)
                        for (var a in t.extensions) r.extensions[a] = t.extensions[a];
                    if (void 0 !== t.shading && (r.flatShading = 1 === t.shading), void 0 !== t.size && (r.size = t.size), void 0 !== t.sizeAttenuation && (r.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (r.map = n(t.map)), void 0 !== t.matcap && (r.matcap = n(t.matcap)), void 0 !== t.alphaMap && (r.alphaMap = n(t.alphaMap), r.transparent = !0), void 0 !== t.bumpMap && (r.bumpMap = n(t.bumpMap)), void 0 !== t.bumpScale && (r.bumpScale = t.bumpScale), void 0 !== t.normalMap && (r.normalMap = n(t.normalMap)), void 0 !== t.normalMapType && (r.normalMapType = t.normalMapType), void 0 !== t.normalScale) {
                        var s = t.normalScale;
                        !1 === Array.isArray(s) && (s = [s, s]), r.normalScale = (new He).fromArray(s)
                    }
                    return void 0 !== t.displacementMap && (r.displacementMap = n(t.displacementMap)), void 0 !== t.displacementScale && (r.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (r.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (r.roughnessMap = n(t.roughnessMap)), void 0 !== t.metalnessMap && (r.metalnessMap = n(t.metalnessMap)), void 0 !== t.emissiveMap && (r.emissiveMap = n(t.emissiveMap)), void 0 !== t.emissiveIntensity && (r.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (r.specularMap = n(t.specularMap)), void 0 !== t.envMap && (r.envMap = n(t.envMap)), void 0 !== t.envMapIntensity && (r.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (r.reflectivity = t.reflectivity), void 0 !== t.refractionRatio && (r.refractionRatio = t.refractionRatio), void 0 !== t.lightMap && (r.lightMap = n(t.lightMap)), void 0 !== t.lightMapIntensity && (r.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (r.aoMap = n(t.aoMap)), void 0 !== t.aoMapIntensity && (r.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (r.gradientMap = n(t.gradientMap)), r
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setTextures: function(t) {
                    return this.textures = t, this
                }
            });
            var Js = {
                decodeText: function(t) {
                    if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
                    for (var e = "", n = 0, r = t.length; n < r; n++) e += String.fromCharCode(t[n]);
                    try {
                        return decodeURIComponent(escape(e))
                    } catch (t) {
                        return e
                    }
                },
                extractUrlBase: function(t) {
                    var e = t.lastIndexOf("/");
                    return -1 === e ? "./" : t.substr(0, e + 1)
                }
            };

            function Zs() {
                Rn.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
            }

            function Qs(t, e, n, r) {
                "number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), gn.call(this, t, e, n), this.meshPerAttribute = r || 1
            }

            function Ks(t) {
                this.manager = void 0 !== t ? t : os
            }
            Zs.prototype = Object.assign(Object.create(Rn.prototype), {
                constructor: Zs,
                isInstancedBufferGeometry: !0,
                copy: function(t) {
                    return Rn.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                toJSON: function() {
                    var t = Rn.prototype.toJSON.call(this);
                    return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t
                }
            }), Qs.prototype = Object.assign(Object.create(gn.prototype), {
                constructor: Qs,
                isInstancedBufferAttribute: !0,
                copy: function(t) {
                    return gn.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                },
                toJSON: function() {
                    var t = gn.prototype.toJSON.call(this);
                    return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t
                }
            }), Object.assign(Ks.prototype, {
                load: function(t, e, n, r) {
                    var i = this,
                        o = new ss(i.manager);
                    o.setPath(i.path), o.load(t, function(t) {
                        e(i.parse(JSON.parse(t)))
                    }, n, r)
                },
                parse: function(t) {
                    var e = t.isInstancedBufferGeometry ? new Zs : new Rn,
                        n = t.data.index;
                    if (void 0 !== n) {
                        var r = new $s[n.type](n.array);
                        e.setIndex(new gn(r, 1))
                    }
                    var i = t.data.attributes;
                    for (var o in i) {
                        var a = i[o],
                            s = new(r = new $s[a.type](a.array), a.isInstancedBufferAttribute ? Qs : gn)(r, a.itemSize, a.normalized);
                        void 0 !== a.name && (s.name = a.name), e.addAttribute(o, s)
                    }
                    var c = t.data.morphAttributes;
                    if (c)
                        for (var o in c) {
                            for (var u = c[o], l = [], h = 0, p = u.length; h < p; h++) a = u[h], s = new gn(r = new $s[a.type](a.array), a.itemSize, a.normalized), void 0 !== a.name && (s.name = a.name), l.push(s);
                            e.morphAttributes[o] = l
                        }
                    var d = t.data.groups || t.data.drawcalls || t.data.offsets;
                    if (void 0 !== d) {
                        h = 0;
                        for (var f = d.length; h !== f; ++h) {
                            var m = d[h];
                            e.addGroup(m.start, m.count, m.materialIndex)
                        }
                    }
                    var v = t.data.boundingSphere;
                    if (void 0 !== v) {
                        var g = new je;
                        void 0 !== v.center && g.fromArray(v.center), e.boundingSphere = new on(g, v.radius)
                    }
                    return t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            });
            var $s = {
                Int8Array: Int8Array,
                Uint8Array: Uint8Array,
                Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
                Int16Array: Int16Array,
                Uint16Array: Uint16Array,
                Int32Array: Int32Array,
                Uint32Array: Uint32Array,
                Float32Array: Float32Array,
                Float64Array: Float64Array
            };

            function tc(t) {
                this.manager = void 0 !== t ? t : os, this.resourcePath = ""
            }
            Object.assign(tc.prototype, {
                crossOrigin: "anonymous",
                load: function(t, e, n, r) {
                    var i = this,
                        o = void 0 === this.path ? Js.extractUrlBase(t) : this.path;
                    this.resourcePath = this.resourcePath || o;
                    var a = new ss(i.manager);
                    a.setPath(this.path), a.load(t, function(n) {
                        var o = null;
                        try {
                            o = JSON.parse(n)
                        } catch (e) {
                            return void 0 !== r && r(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                        }
                        var a = o.metadata;
                        void 0 !== a && void 0 !== a.type && "geometry" !== a.type.toLowerCase() ? i.parse(o, e) : console.error("THREE.ObjectLoader: Can't load " + t)
                    }, n, r)
                },
                setPath: function(t) {
                    return this.path = t, this
                },
                setResourcePath: function(t) {
                    return this.resourcePath = t, this
                },
                setCrossOrigin: function(t) {
                    return this.crossOrigin = t, this
                },
                parse: function(t, e) {
                    var n = this.parseShape(t.shapes),
                        r = this.parseGeometries(t.geometries, n),
                        i = this.parseImages(t.images, function() {
                            void 0 !== e && e(s)
                        }),
                        o = this.parseTextures(t.textures, i),
                        a = this.parseMaterials(t.materials, o),
                        s = this.parseObject(t.object, r, a);
                    return t.animations && (s.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 !== e && e(s), s
                },
                parseShape: function(t) {
                    var e = {};
                    if (void 0 !== t)
                        for (var n = 0, r = t.length; n < r; n++) {
                            var i = (new Fs).fromJSON(t[n]);
                            e[i.uuid] = i
                        }
                    return e
                },
                parseGeometries: function(t, e) {
                    var n = {};
                    if (void 0 !== t)
                        for (var r = new Ks, i = 0, o = t.length; i < o; i++) {
                            var a, s = t[i];
                            switch (s.type) {
                                case "PlaneGeometry":
                                case "PlaneBufferGeometry":
                                    a = new Ra[s.type](s.width, s.height, s.widthSegments, s.heightSegments);
                                    break;
                                case "BoxGeometry":
                                case "BoxBufferGeometry":
                                case "CubeGeometry":
                                    a = new Ra[s.type](s.width, s.height, s.depth, s.widthSegments, s.heightSegments, s.depthSegments);
                                    break;
                                case "CircleGeometry":
                                case "CircleBufferGeometry":
                                    a = new Ra[s.type](s.radius, s.segments, s.thetaStart, s.thetaLength);
                                    break;
                                case "CylinderGeometry":
                                case "CylinderBufferGeometry":
                                    a = new Ra[s.type](s.radiusTop, s.radiusBottom, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "ConeGeometry":
                                case "ConeBufferGeometry":
                                    a = new Ra[s.type](s.radius, s.height, s.radialSegments, s.heightSegments, s.openEnded, s.thetaStart, s.thetaLength);
                                    break;
                                case "SphereGeometry":
                                case "SphereBufferGeometry":
                                    a = new Ra[s.type](s.radius, s.widthSegments, s.heightSegments, s.phiStart, s.phiLength, s.thetaStart, s.thetaLength);
                                    break;
                                case "DodecahedronGeometry":
                                case "DodecahedronBufferGeometry":
                                case "IcosahedronGeometry":
                                case "IcosahedronBufferGeometry":
                                case "OctahedronGeometry":
                                case "OctahedronBufferGeometry":
                                case "TetrahedronGeometry":
                                case "TetrahedronBufferGeometry":
                                    a = new Ra[s.type](s.radius, s.detail);
                                    break;
                                case "RingGeometry":
                                case "RingBufferGeometry":
                                    a = new Ra[s.type](s.innerRadius, s.outerRadius, s.thetaSegments, s.phiSegments, s.thetaStart, s.thetaLength);
                                    break;
                                case "TorusGeometry":
                                case "TorusBufferGeometry":
                                    a = new Ra[s.type](s.radius, s.tube, s.radialSegments, s.tubularSegments, s.arc);
                                    break;
                                case "TorusKnotGeometry":
                                case "TorusKnotBufferGeometry":
                                    a = new Ra[s.type](s.radius, s.tube, s.tubularSegments, s.radialSegments, s.p, s.q);
                                    break;
                                case "TubeGeometry":
                                case "TubeBufferGeometry":
                                    a = new Ra[s.type]((new Is[s.path.type]).fromJSON(s.path), s.tubularSegments, s.radius, s.radialSegments, s.closed);
                                    break;
                                case "LatheGeometry":
                                case "LatheBufferGeometry":
                                    a = new Ra[s.type](s.points, s.segments, s.phiStart, s.phiLength);
                                    break;
                                case "PolyhedronGeometry":
                                case "PolyhedronBufferGeometry":
                                    a = new Ra[s.type](s.vertices, s.indices, s.radius, s.details);
                                    break;
                                case "ShapeGeometry":
                                case "ShapeBufferGeometry":
                                    for (var c = [], u = 0, l = s.shapes.length; u < l; u++) {
                                        var h = e[s.shapes[u]];
                                        c.push(h)
                                    }
                                    a = new Ra[s.type](c, s.curveSegments);
                                    break;
                                case "ExtrudeGeometry":
                                case "ExtrudeBufferGeometry":
                                    for (c = [], u = 0, l = s.shapes.length; u < l; u++) h = e[s.shapes[u]], c.push(h);
                                    var p = s.options.extrudePath;
                                    void 0 !== p && (s.options.extrudePath = (new Is[p.type]).fromJSON(p)), a = new Ra[s.type](c, s.options);
                                    break;
                                case "BufferGeometry":
                                case "InstancedBufferGeometry":
                                    a = r.parse(s);
                                    break;
                                case "Geometry":
                                    if ("THREE" in window && "LegacyJSONLoader" in THREE) a = (new THREE.LegacyJSONLoader).parse(s, this.resourcePath).geometry;
                                    else console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                                    break;
                                default:
                                    console.warn('THREE.ObjectLoader: Unsupported geometry type "' + s.type + '"');
                                    continue
                            }
                            a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), !0 === a.isBufferGeometry && void 0 !== s.userData && (a.userData = s.userData), n[s.uuid] = a
                        }
                    return n
                },
                parseMaterials: function(t, e) {
                    var n = {},
                        r = {};
                    if (void 0 !== t) {
                        var i = new Ys;
                        i.setTextures(e);
                        for (var o = 0, a = t.length; o < a; o++) {
                            var s = t[o];
                            if ("MultiMaterial" === s.type) {
                                for (var c = [], u = 0; u < s.materials.length; u++) {
                                    var l = s.materials[u];
                                    void 0 === n[l.uuid] && (n[l.uuid] = i.parse(l)), c.push(n[l.uuid])
                                }
                                r[s.uuid] = c
                            } else void 0 === n[s.uuid] && (n[s.uuid] = i.parse(s)), r[s.uuid] = n[s.uuid]
                        }
                    }
                    return r
                },
                parseAnimations: function(t) {
                    for (var e = [], n = 0; n < t.length; n++) {
                        var r = t[n],
                            i = es.parse(r);
                        void 0 !== r.uuid && (i.uuid = r.uuid), e.push(i)
                    }
                    return e
                },
                parseImages: function(t, e) {
                    var n = this,
                        r = {};

                    function i(t) {
                        return n.manager.itemStart(t), o.load(t, function() {
                            n.manager.itemEnd(t)
                        }, void 0, function() {
                            n.manager.itemError(t), n.manager.itemEnd(t)
                        })
                    }
                    if (void 0 !== t && t.length > 0) {
                        var o = new hs(new is(e));
                        o.setCrossOrigin(this.crossOrigin);
                        for (var a = 0, s = t.length; a < s; a++) {
                            var c = t[a],
                                u = c.url;
                            if (Array.isArray(u)) {
                                r[c.uuid] = [];
                                for (var l = 0, h = u.length; l < h; l++) {
                                    var p = u[l],
                                        d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : n.resourcePath + p;
                                    r[c.uuid].push(i(d))
                                }
                            } else d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : n.resourcePath + c.url, r[c.uuid] = i(d)
                        }
                    }
                    return r
                },
                parseTextures: function(t, e) {
                    function n(t, e) {
                        return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
                    }
                    var r = {};
                    if (void 0 !== t)
                        for (var i = 0, o = t.length; i < o; i++) {
                            var a, s = t[i];
                            void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image), (a = Array.isArray(e[s.image]) ? new mr(e[s.image]) : new Xe(e[s.image])).needsUpdate = !0, a.uuid = s.uuid, void 0 !== s.name && (a.name = s.name), void 0 !== s.mapping && (a.mapping = n(s.mapping, nc)), void 0 !== s.offset && a.offset.fromArray(s.offset), void 0 !== s.repeat && a.repeat.fromArray(s.repeat), void 0 !== s.center && a.center.fromArray(s.center), void 0 !== s.rotation && (a.rotation = s.rotation), void 0 !== s.wrap && (a.wrapS = n(s.wrap[0], rc), a.wrapT = n(s.wrap[1], rc)), void 0 !== s.format && (a.format = s.format), void 0 !== s.type && (a.type = s.type), void 0 !== s.encoding && (a.encoding = s.encoding), void 0 !== s.minFilter && (a.minFilter = n(s.minFilter, ic)), void 0 !== s.magFilter && (a.magFilter = n(s.magFilter, ic)), void 0 !== s.anisotropy && (a.anisotropy = s.anisotropy), void 0 !== s.flipY && (a.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (a.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (a.unpackAlignment = s.unpackAlignment), r[s.uuid] = a
                        }
                    return r
                },
                parseObject: function(t, e, n) {
                    var r;

                    function i(t) {
                        return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
                    }

                    function o(t) {
                        if (void 0 !== t) {
                            if (Array.isArray(t)) {
                                for (var e = [], r = 0, i = t.length; r < i; r++) {
                                    var o = t[r];
                                    void 0 === n[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(n[o])
                                }
                                return e
                            }
                            return void 0 === n[t] && console.warn("THREE.ObjectLoader: Undefined material", t), n[t]
                        }
                    }
                    switch (t.type) {
                        case "Scene":
                            r = new nn, void 0 !== t.background && Number.isInteger(t.background) && (r.background = new un(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? r.fog = new Ki(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (r.fog = new Qi(t.fog.color, t.fog.density)));
                            break;
                        case "PerspectiveCamera":
                            r = new jn(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (r.focus = t.focus), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.filmGauge && (r.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (r.filmOffset = t.filmOffset), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                            break;
                        case "OrthographicCamera":
                            r = new js(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (r.zoom = t.zoom), void 0 !== t.view && (r.view = Object.assign({}, t.view));
                            break;
                        case "AmbientLight":
                            r = new qs(t.color, t.intensity);
                            break;
                        case "DirectionalLight":
                            r = new Ws(t.color, t.intensity);
                            break;
                        case "PointLight":
                            r = new Us(t.color, t.intensity, t.distance, t.decay);
                            break;
                        case "RectAreaLight":
                            r = new Xs(t.color, t.intensity, t.width, t.height);
                            break;
                        case "SpotLight":
                            r = new Hs(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                            break;
                        case "HemisphereLight":
                            r = new Ns(t.color, t.groundColor, t.intensity);
                            break;
                        case "SkinnedMesh":
                            console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                        case "Mesh":
                            var a = i(t.geometry),
                                s = o(t.material);
                            r = a.bones && a.bones.length > 0 ? new io(a, s) : new Pn(a, s), void 0 !== t.drawMode && r.setDrawMode(t.drawMode);
                            break;
                        case "LOD":
                            r = new ro;
                            break;
                        case "Line":
                            r = new co(i(t.geometry), o(t.material), t.mode);
                            break;
                        case "LineLoop":
                            r = new lo(i(t.geometry), o(t.material));
                            break;
                        case "LineSegments":
                            r = new uo(i(t.geometry), o(t.material));
                            break;
                        case "PointCloud":
                        case "Points":
                            r = new po(i(t.geometry), o(t.material));
                            break;
                        case "Sprite":
                            r = new no(o(t.material));
                            break;
                        case "Group":
                            r = new Ui;
                            break;
                        default:
                            r = new en
                    }
                    if (r.uuid = t.uuid, void 0 !== t.name && (r.name = t.name), void 0 !== t.matrix ? (r.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (r.matrixAutoUpdate = t.matrixAutoUpdate), r.matrixAutoUpdate && r.matrix.decompose(r.position, r.quaternion, r.scale)) : (void 0 !== t.position && r.position.fromArray(t.position), void 0 !== t.rotation && r.rotation.fromArray(t.rotation), void 0 !== t.quaternion && r.quaternion.fromArray(t.quaternion), void 0 !== t.scale && r.scale.fromArray(t.scale)), void 0 !== t.castShadow && (r.castShadow = t.castShadow), void 0 !== t.receiveShadow && (r.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (r.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (r.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && r.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (r.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (r.visible = t.visible), void 0 !== t.frustumCulled && (r.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (r.renderOrder = t.renderOrder), void 0 !== t.userData && (r.userData = t.userData), void 0 !== t.layers && (r.layers.mask = t.layers), void 0 !== t.children)
                        for (var c = t.children, u = 0; u < c.length; u++) r.add(this.parseObject(c[u], e, n));
                    if ("LOD" === t.type)
                        for (var l = t.levels, h = 0; h < l.length; h++) {
                            var p = l[h],
                                d = r.getObjectByProperty("uuid", p.object);
                            void 0 !== d && r.addLevel(d, p.distance)
                        }
                    return r
                }
            });
            var ec, nc = {
                    UVMapping: ut,
                    CubeReflectionMapping: lt,
                    CubeRefractionMapping: ht,
                    EquirectangularReflectionMapping: pt,
                    EquirectangularRefractionMapping: dt,
                    SphericalReflectionMapping: ft,
                    CubeUVReflectionMapping: mt,
                    CubeUVRefractionMapping: vt
                },
                rc = {
                    RepeatWrapping: gt,
                    ClampToEdgeWrapping: yt,
                    MirroredRepeatWrapping: xt
                },
                ic = {
                    NearestFilter: bt,
                    NearestMipMapNearestFilter: wt,
                    NearestMipMapLinearFilter: _t,
                    LinearFilter: Mt,
                    LinearMipMapNearestFilter: Et,
                    LinearMipMapLinearFilter: St
                };

            function oc(t) {
                "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : os, this.options = void 0
            }

            function ac() {
                this.type = "ShapePath", this.color = new un, this.subPaths = [], this.currentPath = null
            }

            function sc(t) {
                this.type = "Font", this.data = t
            }

            function cc(t, e, n, r, i) {
                var o = i.glyphs[t] || i.glyphs["?"];
                if (o) {
                    var a, s, c, u, l, h, p, d, f = new ac;
                    if (o.o)
                        for (var m = o._cachedOutline || (o._cachedOutline = o.o.split(" ")), v = 0, g = m.length; v < g;) {
                            switch (m[v++]) {
                                case "m":
                                    a = m[v++] * e + n, s = m[v++] * e + r, f.moveTo(a, s);
                                    break;
                                case "l":
                                    a = m[v++] * e + n, s = m[v++] * e + r, f.lineTo(a, s);
                                    break;
                                case "q":
                                    c = m[v++] * e + n, u = m[v++] * e + r, l = m[v++] * e + n, h = m[v++] * e + r, f.quadraticCurveTo(l, h, c, u);
                                    break;
                                case "b":
                                    c = m[v++] * e + n, u = m[v++] * e + r, l = m[v++] * e + n, h = m[v++] * e + r, p = m[v++] * e + n, d = m[v++] * e + r, f.bezierCurveTo(l, h, p, d, c, u)
                            }
                        }
                    return {
                        offsetX: o.ha * e,
                        path: f
                    }
                }
            }

            function uc(t) {
                this.manager = void 0 !== t ? t : os
            }

            function lc() {}
            oc.prototype = {
                constructor: oc,
                setOptions: function(t) {
                    return this.options = t, this
                },
                load: function(t, e, n, r) {
                    void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
                    var i = this,
                        o = rs.get(t);
                    if (void 0 !== o) return i.manager.itemStart(t), setTimeout(function() {
                        e && e(o), i.manager.itemEnd(t)
                    }, 0), o;
                    fetch(t).then(function(t) {
                        return t.blob()
                    }).then(function(t) {
                        return void 0 === i.options ? createImageBitmap(t) : createImageBitmap(t, i.options)
                    }).then(function(n) {
                        rs.add(t, n), e && e(n), i.manager.itemEnd(t)
                    }).catch(function(e) {
                        r && r(e), i.manager.itemError(t), i.manager.itemEnd(t)
                    }), i.manager.itemStart(t)
                },
                setCrossOrigin: function() {
                    return this
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }, Object.assign(ac.prototype, {
                moveTo: function(t, e) {
                    this.currentPath = new Ds, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
                },
                lineTo: function(t, e) {
                    this.currentPath.lineTo(t, e)
                },
                quadraticCurveTo: function(t, e, n, r) {
                    this.currentPath.quadraticCurveTo(t, e, n, r)
                },
                bezierCurveTo: function(t, e, n, r, i, o) {
                    this.currentPath.bezierCurveTo(t, e, n, r, i, o)
                },
                splineThru: function(t) {
                    this.currentPath.splineThru(t)
                },
                toShapes: function(t, e) {
                    function n(t) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var i = t[n],
                                o = new Fs;
                            o.curves = i.curves, e.push(o)
                        }
                        return e
                    }

                    function r(t, e) {
                        for (var n = e.length, r = !1, i = n - 1, o = 0; o < n; i = o++) {
                            var a = e[i],
                                s = e[o],
                                c = s.x - a.x,
                                u = s.y - a.y;
                            if (Math.abs(u) > Number.EPSILON) {
                                if (u < 0 && (a = e[o], c = -c, s = e[i], u = -u), t.y < a.y || t.y > s.y) continue;
                                if (t.y === a.y) {
                                    if (t.x === a.x) return !0
                                } else {
                                    var l = u * (t.x - a.x) - c * (t.y - a.y);
                                    if (0 === l) return !0;
                                    if (l < 0) continue;
                                    r = !r
                                }
                            } else {
                                if (t.y !== a.y) continue;
                                if (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x) return !0
                            }
                        }
                        return r
                    }
                    var i = oa.isClockWise,
                        o = this.subPaths;
                    if (0 === o.length) return [];
                    if (!0 === e) return n(o);
                    var a, s, c, u = [];
                    if (1 === o.length) return s = o[0], (c = new Fs).curves = s.curves, u.push(c), u;
                    var l = !i(o[0].getPoints());
                    l = t ? !l : l;
                    var h, p, d = [],
                        f = [],
                        m = [],
                        v = 0;
                    f[v] = void 0, m[v] = [];
                    for (var g = 0, y = o.length; g < y; g++) a = i(h = (s = o[g]).getPoints()), (a = t ? !a : a) ? (!l && f[v] && v++, f[v] = {
                        s: new Fs,
                        p: h
                    }, f[v].s.curves = s.curves, l && v++, m[v] = []) : m[v].push({
                        h: s,
                        p: h[0]
                    });
                    if (!f[0]) return n(o);
                    if (f.length > 1) {
                        for (var x = !1, b = [], w = 0, _ = f.length; w < _; w++) d[w] = [];
                        for (w = 0, _ = f.length; w < _; w++)
                            for (var M = m[w], E = 0; E < M.length; E++) {
                                for (var S = M[E], T = !0, A = 0; A < f.length; A++) r(S.p, f[A].p) && (w !== A && b.push({
                                    froms: w,
                                    tos: A,
                                    hole: E
                                }), T ? (T = !1, d[A].push(S)) : x = !0);
                                T && d[w].push(S)
                            }
                        b.length > 0 && (x || (m = d))
                    }
                    g = 0;
                    for (var L = f.length; g < L; g++) {
                        c = f[g].s, u.push(c);
                        for (var C = 0, R = (p = m[g]).length; C < R; C++) c.holes.push(p[C].h)
                    }
                    return u
                }
            }), Object.assign(sc.prototype, {
                isFont: !0,
                generateShapes: function(t, e) {
                    void 0 === e && (e = 100);
                    for (var n = [], r = function(t, e, n) {
                            for (var r = Array.from ? Array.from(t) : String(t).split(""), i = e / n.resolution, o = (n.boundingBox.yMax - n.boundingBox.yMin + n.underlineThickness) * i, a = [], s = 0, c = 0, u = 0; u < r.length; u++) {
                                var l = r[u];
                                if ("\n" === l) s = 0, c -= o;
                                else {
                                    var h = cc(l, i, s, c, n);
                                    s += h.offsetX, a.push(h.path)
                                }
                            }
                            return a
                        }(t, e, this.data), i = 0, o = r.length; i < o; i++) Array.prototype.push.apply(n, r[i].toShapes());
                    return n
                }
            }), Object.assign(uc.prototype, {
                load: function(t, e, n, r) {
                    var i = this,
                        o = new ss(this.manager);
                    o.setPath(this.path), o.load(t, function(t) {
                        var n;
                        try {
                            n = JSON.parse(t)
                        } catch (e) {
                            console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), n = JSON.parse(t.substring(65, t.length - 2))
                        }
                        var r = i.parse(n);
                        e && e(r)
                    }, n, r)
                },
                parse: function(t) {
                    return new sc(t)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), lc.Handlers = {
                handlers: [],
                add: function(t, e) {
                    this.handlers.push(t, e)
                },
                get: function(t) {
                    for (var e = this.handlers, n = 0, r = e.length; n < r; n += 2) {
                        var i = e[n],
                            o = e[n + 1];
                        if (i.test(t)) return o
                    }
                    return null
                }
            }, Object.assign(lc.prototype, {
                crossOrigin: "anonymous",
                onLoadStart: function() {},
                onLoadProgress: function() {},
                onLoadComplete: function() {},
                initMaterials: function(t, e, n) {
                    for (var r = [], i = 0; i < t.length; ++i) r[i] = this.createMaterial(t[i], e, n);
                    return r
                },
                createMaterial: function() {
                    var t = {
                            NoBlending: E,
                            NormalBlending: S,
                            AdditiveBlending: T,
                            SubtractiveBlending: A,
                            MultiplyBlending: L,
                            CustomBlending: C
                        },
                        e = new un,
                        n = new ds,
                        r = new Ys;
                    return function(i, o, a) {
                        var s = {};

                        function c(t, e, r, i, c) {
                            var u, l = o + t,
                                h = lc.Handlers.get(l);
                            null !== h ? u = h.load(l) : (n.setCrossOrigin(a), u = n.load(l)), void 0 !== e && (u.repeat.fromArray(e), 1 !== e[0] && (u.wrapS = gt), 1 !== e[1] && (u.wrapT = gt)), void 0 !== r && u.offset.fromArray(r), void 0 !== i && ("repeat" === i[0] && (u.wrapS = gt), "mirror" === i[0] && (u.wrapS = xt), "repeat" === i[1] && (u.wrapT = gt), "mirror" === i[1] && (u.wrapT = xt)), void 0 !== c && (u.anisotropy = c);
                            var p = Ge.generateUUID();
                            return s[p] = u, p
                        }
                        var u = {
                            uuid: Ge.generateUUID(),
                            type: "MeshLambertMaterial"
                        };
                        for (var l in i) {
                            var h = i[l];
                            switch (l) {
                                case "DbgColor":
                                case "DbgIndex":
                                case "opticalDensity":
                                case "illumination":
                                    break;
                                case "DbgName":
                                    u.name = h;
                                    break;
                                case "blending":
                                    u.blending = t[h];
                                    break;
                                case "colorAmbient":
                                case "mapAmbient":
                                    console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                                    break;
                                case "colorDiffuse":
                                    u.color = e.fromArray(h).getHex();
                                    break;
                                case "colorSpecular":
                                    u.specular = e.fromArray(h).getHex();
                                    break;
                                case "colorEmissive":
                                    u.emissive = e.fromArray(h).getHex();
                                    break;
                                case "specularCoef":
                                    u.shininess = h;
                                    break;
                                case "shading":
                                    "basic" === h.toLowerCase() && (u.type = "MeshBasicMaterial"), "phong" === h.toLowerCase() && (u.type = "MeshPhongMaterial"), "standard" === h.toLowerCase() && (u.type = "MeshStandardMaterial");
                                    break;
                                case "mapDiffuse":
                                    u.map = c(h, i.mapDiffuseRepeat, i.mapDiffuseOffset, i.mapDiffuseWrap, i.mapDiffuseAnisotropy);
                                    break;
                                case "mapDiffuseRepeat":
                                case "mapDiffuseOffset":
                                case "mapDiffuseWrap":
                                case "mapDiffuseAnisotropy":
                                    break;
                                case "mapEmissive":
                                    u.emissiveMap = c(h, i.mapEmissiveRepeat, i.mapEmissiveOffset, i.mapEmissiveWrap, i.mapEmissiveAnisotropy);
                                    break;
                                case "mapEmissiveRepeat":
                                case "mapEmissiveOffset":
                                case "mapEmissiveWrap":
                                case "mapEmissiveAnisotropy":
                                    break;
                                case "mapLight":
                                    u.lightMap = c(h, i.mapLightRepeat, i.mapLightOffset, i.mapLightWrap, i.mapLightAnisotropy);
                                    break;
                                case "mapLightRepeat":
                                case "mapLightOffset":
                                case "mapLightWrap":
                                case "mapLightAnisotropy":
                                    break;
                                case "mapAO":
                                    u.aoMap = c(h, i.mapAORepeat, i.mapAOOffset, i.mapAOWrap, i.mapAOAnisotropy);
                                    break;
                                case "mapAORepeat":
                                case "mapAOOffset":
                                case "mapAOWrap":
                                case "mapAOAnisotropy":
                                    break;
                                case "mapBump":
                                    u.bumpMap = c(h, i.mapBumpRepeat, i.mapBumpOffset, i.mapBumpWrap, i.mapBumpAnisotropy);
                                    break;
                                case "mapBumpScale":
                                    u.bumpScale = h;
                                    break;
                                case "mapBumpRepeat":
                                case "mapBumpOffset":
                                case "mapBumpWrap":
                                case "mapBumpAnisotropy":
                                    break;
                                case "mapNormal":
                                    u.normalMap = c(h, i.mapNormalRepeat, i.mapNormalOffset, i.mapNormalWrap, i.mapNormalAnisotropy);
                                    break;
                                case "mapNormalFactor":
                                    u.normalScale = h;
                                    break;
                                case "mapNormalRepeat":
                                case "mapNormalOffset":
                                case "mapNormalWrap":
                                case "mapNormalAnisotropy":
                                    break;
                                case "mapSpecular":
                                    u.specularMap = c(h, i.mapSpecularRepeat, i.mapSpecularOffset, i.mapSpecularWrap, i.mapSpecularAnisotropy);
                                    break;
                                case "mapSpecularRepeat":
                                case "mapSpecularOffset":
                                case "mapSpecularWrap":
                                case "mapSpecularAnisotropy":
                                    break;
                                case "mapMetalness":
                                    u.metalnessMap = c(h, i.mapMetalnessRepeat, i.mapMetalnessOffset, i.mapMetalnessWrap, i.mapMetalnessAnisotropy);
                                    break;
                                case "mapMetalnessRepeat":
                                case "mapMetalnessOffset":
                                case "mapMetalnessWrap":
                                case "mapMetalnessAnisotropy":
                                    break;
                                case "mapRoughness":
                                    u.roughnessMap = c(h, i.mapRoughnessRepeat, i.mapRoughnessOffset, i.mapRoughnessWrap, i.mapRoughnessAnisotropy);
                                    break;
                                case "mapRoughnessRepeat":
                                case "mapRoughnessOffset":
                                case "mapRoughnessWrap":
                                case "mapRoughnessAnisotropy":
                                    break;
                                case "mapAlpha":
                                    u.alphaMap = c(h, i.mapAlphaRepeat, i.mapAlphaOffset, i.mapAlphaWrap, i.mapAlphaAnisotropy);
                                    break;
                                case "mapAlphaRepeat":
                                case "mapAlphaOffset":
                                case "mapAlphaWrap":
                                case "mapAlphaAnisotropy":
                                    break;
                                case "flipSided":
                                    u.side = g;
                                    break;
                                case "doubleSided":
                                    u.side = y;
                                    break;
                                case "transparency":
                                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), u.opacity = h;
                                    break;
                                case "depthTest":
                                case "depthWrite":
                                case "colorWrite":
                                case "opacity":
                                case "reflectivity":
                                case "transparent":
                                case "visible":
                                case "wireframe":
                                    u[l] = h;
                                    break;
                                case "vertexColors":
                                    !0 === h && (u.vertexColors = M), "face" === h && (u.vertexColors = _);
                                    break;
                                default:
                                    console.error("THREE.Loader.createMaterial: Unsupported", l, h)
                            }
                        }
                        return "MeshBasicMaterial" === u.type && delete u.emissive, "MeshPhongMaterial" !== u.type && delete u.specular, u.opacity < 1 && (u.transparent = !0), r.setTextures(s), r.parse(u)
                    }
                }()
            });
            var hc = {
                getContext: function() {
                    return void 0 === ec && (ec = new(window.AudioContext || window.webkitAudioContext)), ec
                },
                setContext: function(t) {
                    ec = t
                }
            };

            function pc(t) {
                this.manager = void 0 !== t ? t : os
            }

            function dc() {
                this.coefficients = [];
                for (var t = 0; t < 9; t++) this.coefficients.push(new je)
            }

            function fc(t, e) {
                ks.call(this, void 0, e), this.sh = void 0 !== t ? t : new dc
            }

            function mc(t, e, n) {
                fc.call(this, void 0, n);
                var r = (new un).set(t),
                    i = (new un).set(e),
                    o = new je(r.r, r.g, r.b),
                    a = new je(i.r, i.g, i.b),
                    s = Math.sqrt(Math.PI),
                    c = s * Math.sqrt(.75);
                this.sh.coefficients[0].copy(o).add(a).multiplyScalar(s), this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)
            }

            function vc(t, e) {
                fc.call(this, void 0, e);
                var n = (new un).set(t);
                this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
            }

            function gc() {
                this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new jn, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new jn, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
            }

            function yc(t) {
                this.autoStart = void 0 === t || t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
            }

            function xc() {
                en.call(this), this.type = "AudioListener", this.context = hc.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
            }

            function bc(t) {
                en.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.startTime = 0, this.offset = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
            }

            function wc(t) {
                bc.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
            }

            function _c(t, e) {
                this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
            }

            function Mc(t, e, n) {
                this.binding = t, this.valueSize = n;
                var r, i = Float64Array;
                switch (e) {
                    case "quaternion":
                        r = this._slerp;
                        break;
                    case "string":
                    case "bool":
                        i = Array, r = this._select;
                        break;
                    default:
                        r = this._lerp
                }
                this.buffer = new i(4 * n), this._mixBufferRegion = r, this.cumulativeWeight = 0, this.useCount = 0, this.referenceCount = 0
            }
            Object.assign(pc.prototype, {
                load: function(t, e, n, r) {
                    var i = new ss(this.manager);
                    i.setResponseType("arraybuffer"), i.setPath(this.path), i.load(t, function(t) {
                        var n = t.slice(0);
                        hc.getContext().decodeAudioData(n, function(t) {
                            e(t)
                        })
                    }, n, r)
                },
                setPath: function(t) {
                    return this.path = t, this
                }
            }), Object.assign(dc.prototype, {
                isSphericalHarmonics3: !0,
                set: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].copy(t[e]);
                    return this
                },
                zero: function() {
                    for (var t = 0; t < 9; t++) this.coefficients[t].set(0, 0, 0);
                    return this
                },
                getAt: function(t, e) {
                    var n = t.x,
                        r = t.y,
                        i = t.z,
                        o = this.coefficients;
                    return e.copy(o[0]).multiplyScalar(.282095), e.addScale(o[1], .488603 * r), e.addScale(o[2], .488603 * i), e.addScale(o[3], .488603 * n), e.addScale(o[4], n * r * 1.092548), e.addScale(o[5], r * i * 1.092548), e.addScale(o[6], .315392 * (3 * i * i - 1)), e.addScale(o[7], n * i * 1.092548), e.addScale(o[8], .546274 * (n * n - r * r)), e
                },
                getIrradianceAt: function(t, e) {
                    var n = t.x,
                        r = t.y,
                        i = t.z,
                        o = this.coefficients;
                    return e.copy(o[0]).multiplyScalar(.886227), e.addScale(o[1], 1.023328 * r), e.addScale(o[2], 1.023328 * i), e.addScale(o[3], 1.023328 * n), e.addScale(o[4], .858086 * n * r), e.addScale(o[5], .858086 * r * i), e.addScale(o[6], .743125 * i * i - .247708), e.addScale(o[7], .858086 * n * i), e.addScale(o[8], .429043 * (n * n - r * r)), e
                },
                add: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].add(t.coefficients[e]);
                    return this
                },
                scale: function(t) {
                    for (var e = 0; e < 9; e++) this.coefficients[e].multiplyScalar(t);
                    return this
                },
                lerp: function(t, e) {
                    for (var n = 0; n < 9; n++) this.coefficients[n].lerp(t.coefficients[n], e);
                    return this
                },
                equals: function(t) {
                    for (var e = 0; e < 9; e++)
                        if (!this.coefficients[e].equals(t.coefficients[e])) return !1;
                    return !0
                },
                copy: function(t) {
                    return this.set(t.coefficients)
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                fromArray: function(t) {
                    for (var e = this.coefficients, n = 0; n < 9; n++) e[n].fromArray(t, 3 * n);
                    return this
                },
                toArray: function() {
                    for (var t = [], e = this.coefficients, n = 0; n < 9; n++) e[n].toArray(t, 3 * n);
                    return t
                }
            }), Object.assign(dc, {
                getBasisAt: function(t, e) {
                    var n = t.x,
                        r = t.y,
                        i = t.z;
                    e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * i, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * i, e[6] = .315392 * (3 * i * i - 1), e[7] = 1.092548 * n * i, e[8] = .546274 * (n * n - r * r)
                }
            }), fc.prototype = Object.assign(Object.create(ks.prototype), {
                constructor: fc,
                isLightProbe: !0,
                copy: function(t) {
                    return ks.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this
                },
                toJSON: function(t) {
                    return ks.prototype.toJSON.call(this, t)
                }
            }), mc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: mc,
                isHemisphereLightProbe: !0,
                copy: function(t) {
                    return fc.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    return fc.prototype.toJSON.call(this, t)
                }
            }), vc.prototype = Object.assign(Object.create(fc.prototype), {
                constructor: vc,
                isAmbientLightProbe: !0,
                copy: function(t) {
                    return fc.prototype.copy.call(this, t), this
                },
                toJSON: function(t) {
                    return fc.prototype.toJSON.call(this, t)
                }
            }), Object.assign(gc.prototype, {
                update: function() {
                    var t, e, n, r, i, o, a, s, c = new Qe,
                        u = new Qe;
                    return function(l) {
                        if (t !== this || e !== l.focus || n !== l.fov || r !== l.aspect * this.aspect || i !== l.near || o !== l.far || a !== l.zoom || s !== this.eyeSep) {
                            t = this, e = l.focus, n = l.fov, r = l.aspect * this.aspect, i = l.near, o = l.far, a = l.zoom;
                            var h, p, d = l.projectionMatrix.clone(),
                                f = (s = this.eyeSep / 2) * i / e,
                                m = i * Math.tan(Ge.DEG2RAD * n * .5) / a;
                            u.elements[12] = -s, c.elements[12] = s, h = -m * r + f, p = m * r + f, d.elements[0] = 2 * i / (p - h), d.elements[8] = (p + h) / (p - h), this.cameraL.projectionMatrix.copy(d), h = -m * r - f, p = m * r - f, d.elements[0] = 2 * i / (p - h), d.elements[8] = (p + h) / (p - h), this.cameraR.projectionMatrix.copy(d)
                        }
                        this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(u), this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(c)
                    }
                }()
            }), Object.assign(yc.prototype, {
                start: function() {
                    this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
                },
                stop: function() {
                    this.getElapsedTime(), this.running = !1, this.autoStart = !1
                },
                getElapsedTime: function() {
                    return this.getDelta(), this.elapsedTime
                },
                getDelta: function() {
                    var t = 0;
                    if (this.autoStart && !this.running) return this.start(), 0;
                    if (this.running) {
                        var e = ("undefined" == typeof performance ? Date : performance).now();
                        t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
                    }
                    return t
                }
            }), xc.prototype = Object.assign(Object.create(en.prototype), {
                constructor: xc,
                getInput: function() {
                    return this.gain
                },
                removeFilter: function() {
                    return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
                },
                getFilter: function() {
                    return this.filter
                },
                setFilter: function(t) {
                    return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
                },
                getMasterVolume: function() {
                    return this.gain.gain.value
                },
                setMasterVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                },
                updateMatrixWorld: function() {
                    var t = new je,
                        e = new Ue,
                        n = new je,
                        r = new je,
                        i = new yc;
                    return function(o) {
                        en.prototype.updateMatrixWorld.call(this, o);
                        var a = this.context.listener,
                            s = this.up;
                        if (this.timeDelta = i.getDelta(), this.matrixWorld.decompose(t, e, n), r.set(0, 0, -1).applyQuaternion(e), a.positionX) {
                            var c = this.context.currentTime + this.timeDelta;
                            a.positionX.linearRampToValueAtTime(t.x, c), a.positionY.linearRampToValueAtTime(t.y, c), a.positionZ.linearRampToValueAtTime(t.z, c), a.forwardX.linearRampToValueAtTime(r.x, c), a.forwardY.linearRampToValueAtTime(r.y, c), a.forwardZ.linearRampToValueAtTime(r.z, c), a.upX.linearRampToValueAtTime(s.x, c), a.upY.linearRampToValueAtTime(s.y, c), a.upZ.linearRampToValueAtTime(s.z, c)
                        } else a.setPosition(t.x, t.y, t.z), a.setOrientation(r.x, r.y, r.z, s.x, s.y, s.z)
                    }
                }()
            }), bc.prototype = Object.assign(Object.create(en.prototype), {
                constructor: bc,
                getOutput: function() {
                    return this.gain
                },
                setNodeSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
                },
                setMediaElementSource: function(t) {
                    return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
                },
                setBuffer: function(t) {
                    return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
                },
                play: function() {
                    if (!0 !== this.isPlaying) {
                        if (!1 !== this.hasPlaybackControl) {
                            var t = this.context.createBufferSource();
                            return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                        }
                        console.warn("THREE.Audio: this Audio has no playback control.")
                    } else console.warn("THREE.Audio: Audio is already playing.")
                },
                pause: function() {
                    if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                stop: function() {
                    if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                connect: function() {
                    if (this.filters.length > 0) {
                        this.source.connect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                        this.filters[this.filters.length - 1].connect(this.getOutput())
                    } else this.source.connect(this.getOutput());
                    return this
                },
                disconnect: function() {
                    if (this.filters.length > 0) {
                        this.source.disconnect(this.filters[0]);
                        for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                        this.filters[this.filters.length - 1].disconnect(this.getOutput())
                    } else this.source.disconnect(this.getOutput());
                    return this
                },
                getFilters: function() {
                    return this.filters
                },
                setFilters: function(t) {
                    return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
                },
                setDetune: function(t) {
                    if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
                },
                getDetune: function() {
                    return this.detune
                },
                getFilter: function() {
                    return this.getFilters()[0]
                },
                setFilter: function(t) {
                    return this.setFilters(t ? [t] : [])
                },
                setPlaybackRate: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getPlaybackRate: function() {
                    return this.playbackRate
                },
                onEnded: function() {
                    this.isPlaying = !1
                },
                getLoop: function() {
                    return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
                },
                setLoop: function(t) {
                    if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
                    console.warn("THREE.Audio: this Audio has no playback control.")
                },
                getVolume: function() {
                    return this.gain.gain.value
                },
                setVolume: function(t) {
                    return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
                }
            }), wc.prototype = Object.assign(Object.create(bc.prototype), {
                constructor: wc,
                getOutput: function() {
                    return this.panner
                },
                getRefDistance: function() {
                    return this.panner.refDistance
                },
                setRefDistance: function(t) {
                    return this.panner.refDistance = t, this
                },
                getRolloffFactor: function() {
                    return this.panner.rolloffFactor
                },
                setRolloffFactor: function(t) {
                    return this.panner.rolloffFactor = t, this
                },
                getDistanceModel: function() {
                    return this.panner.distanceModel
                },
                setDistanceModel: function(t) {
                    return this.panner.distanceModel = t, this
                },
                getMaxDistance: function() {
                    return this.panner.maxDistance
                },
                setMaxDistance: function(t) {
                    return this.panner.maxDistance = t, this
                },
                setDirectionalCone: function(t, e, n) {
                    return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
                },
                updateMatrixWorld: function() {
                    var t = new je,
                        e = new Ue,
                        n = new je,
                        r = new je;
                    return function(i) {
                        if (en.prototype.updateMatrixWorld.call(this, i), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) {
                            this.matrixWorld.decompose(t, e, n), r.set(0, 0, 1).applyQuaternion(e);
                            var o = this.panner;
                            if (o.positionX) {
                                var a = this.context.currentTime + this.listener.timeDelta;
                                o.positionX.linearRampToValueAtTime(t.x, a), o.positionY.linearRampToValueAtTime(t.y, a), o.positionZ.linearRampToValueAtTime(t.z, a), o.orientationX.linearRampToValueAtTime(r.x, a), o.orientationY.linearRampToValueAtTime(r.y, a), o.orientationZ.linearRampToValueAtTime(r.z, a)
                            } else o.setPosition(t.x, t.y, t.z), o.setOrientation(r.x, r.y, r.z)
                        }
                    }
                }()
            }), Object.assign(_c.prototype, {
                getFrequencyData: function() {
                    return this.analyser.getByteFrequencyData(this.data), this.data
                },
                getAverageFrequency: function() {
                    for (var t = 0, e = this.getFrequencyData(), n = 0; n < e.length; n++) t += e[n];
                    return t / e.length
                }
            }), Object.assign(Mc.prototype, {
                accumulate: function(t, e) {
                    var n = this.buffer,
                        r = this.valueSize,
                        i = t * r + r,
                        o = this.cumulativeWeight;
                    if (0 === o) {
                        for (var a = 0; a !== r; ++a) n[i + a] = n[a];
                        o = e
                    } else {
                        var s = e / (o += e);
                        this._mixBufferRegion(n, i, 0, s, r)
                    }
                    this.cumulativeWeight = o
                },
                apply: function(t) {
                    var e = this.valueSize,
                        n = this.buffer,
                        r = t * e + e,
                        i = this.cumulativeWeight,
                        o = this.binding;
                    if (this.cumulativeWeight = 0, i < 1) {
                        var a = 3 * e;
                        this._mixBufferRegion(n, r, a, 1 - i, e)
                    }
                    for (var s = e, c = e + e; s !== c; ++s)
                        if (n[s] !== n[s + e]) {
                            o.setValue(n, r);
                            break
                        }
                },
                saveOriginalState: function() {
                    var t = this.binding,
                        e = this.buffer,
                        n = this.valueSize,
                        r = 3 * n;
                    t.getValue(e, r);
                    for (var i = n, o = r; i !== o; ++i) e[i] = e[r + i % n];
                    this.cumulativeWeight = 0
                },
                restoreOriginalState: function() {
                    var t = 3 * this.valueSize;
                    this.binding.setValue(this.buffer, t)
                },
                _select: function(t, e, n, r, i) {
                    if (r >= .5)
                        for (var o = 0; o !== i; ++o) t[e + o] = t[n + o]
                },
                _slerp: function(t, e, n, r) {
                    Ue.slerpFlat(t, e, t, e, t, n, r)
                },
                _lerp: function(t, e, n, r, i) {
                    for (var o = 1 - r, a = 0; a !== i; ++a) {
                        var s = e + a;
                        t[s] = t[s] * o + t[n + a] * r
                    }
                }
            });
            var Ec, Sc, Tc = "\\[\\]\\.:\\/";

            function Ac(t, e, n) {
                var r = n || Lc.parseTrackName(e);
                this._targetGroup = t, this._bindings = t.subscribe_(e, r)
            }

            function Lc(t, e, n) {
                this.path = e, this.parsedPath = n || Lc.parseTrackName(e), this.node = Lc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
            }

            function Cc() {
                this.uuid = Ge.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
                var t = {};
                this._indicesByUUID = t;
                for (var e = 0, n = arguments.length; e !== n; ++e) t[arguments[e].uuid] = e;
                this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
                var r = this;
                this.stats = {
                    objects: {get total() {
                            return r._objects.length
                        },
                        get inUse() {
                            return this.total - r.nCachedObjects_
                        }
                    },
                    get bindingsPerObject() {
                        return r._bindings.length
                    }
                }
            }

            function Rc(t, e, n) {
                this._mixer = t, this._clip = e, this._localRoot = n || null;
                for (var r = e.tracks, i = r.length, o = new Array(i), a = {
                        endingStart: _e,
                        endingEnd: _e
                    }, s = 0; s !== i; ++s) {
                    var c = r[s].createInterpolant(null);
                    o[s] = c, c.settings = a
                }
                this._interpolantSettings = a, this._interpolants = o, this._propertyBindings = new Array(i), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = ge, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
            }

            function Pc(t) {
                this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
            }

            function Oc(t) {
                "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
            }

            function Ic(t, e, n) {
                $i.call(this, t, e), this.meshPerAttribute = n || 1
            }

            function Bc(t, e, n, r) {
                this.ray = new an(t, e), this.near = n || 0, this.far = r || 1 / 0, this.params = {
                    Mesh: {},
                    Line: {},
                    LOD: {},
                    Points: {
                        threshold: 1
                    },
                    Sprite: {}
                }, Object.defineProperties(this.params, {
                    PointCloud: {
                        get: function() {
                            return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                        }
                    }
                })
            }

            function Dc(t, e) {
                return t.distance - e.distance
            }

            function Fc(t, e, n, r) {
                if (!1 !== t.visible && (t.raycast(e, n), !0 === r))
                    for (var i = t.children, o = 0, a = i.length; o < a; o++) Fc(i[o], e, n, !0)
            }

            function kc(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== n ? n : 0, this
            }

            function Nc(t, e, n) {
                return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== n ? n : 0, this
            }

            function zc(t, e) {
                this.min = void 0 !== t ? t : new He(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new He(-1 / 0, -1 / 0)
            }

            function Gc(t, e) {
                this.start = void 0 !== t ? t : new je, this.end = void 0 !== e ? e : new je
            }

            function Hc(t) {
                en.call(this), this.material = t, this.render = function() {}
            }

            function Uc(t, e, n, r) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var i = void 0 !== n ? n : 16711680,
                    o = void 0 !== r ? r : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = 3 * s.faces.length : s && s.isBufferGeometry && (a = s.attributes.normal.count);
                var c = new Rn,
                    u = new Sn(2 * a * 3, 3);
                c.addAttribute("position", u), uo.call(this, c, new so({
                    color: i,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function jc(t, e) {
                en.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e;
                for (var n = new Rn, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1], i = 0, o = 1; i < 32; i++, o++) {
                    var a = i / 32 * Math.PI * 2,
                        s = o / 32 * Math.PI * 2;
                    r.push(Math.cos(a), Math.sin(a), 1, Math.cos(s), Math.sin(s), 1)
                }
                n.addAttribute("position", new Sn(r, 3));
                var c = new so({
                    fog: !1
                });
                this.cone = new uo(n, c), this.add(this.cone), this.update()
            }

            function Vc(t) {
                for (var e = function t(e) {
                        var n = [];
                        e && e.isBone && n.push(e);
                        for (var r = 0; r < e.children.length; r++) n.push.apply(n, t(e.children[r]));
                        return n
                    }(t), n = new Rn, r = [], i = [], o = new un(0, 0, 1), a = new un(0, 1, 0), s = 0; s < e.length; s++) {
                    var c = e[s];
                    c.parent && c.parent.isBone && (r.push(0, 0, 0), r.push(0, 0, 0), i.push(o.r, o.g, o.b), i.push(a.r, a.g, a.b))
                }
                n.addAttribute("position", new Sn(r, 3)), n.addAttribute("color", new Sn(i, 3));
                var u = new so({
                    vertexColors: M,
                    depthTest: !1,
                    depthWrite: !1,
                    transparent: !0
                });
                uo.call(this, n, u), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
            }

            function Wc(t, e, n) {
                this.light = t, this.light.updateMatrixWorld(), this.color = n;
                var r = new ma(e, 4, 2),
                    i = new vn({
                        wireframe: !0,
                        fog: !1
                    });
                Pn.call(this, r, i), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
            }

            function qc(t, e) {
                this.type = "RectAreaLightHelper", this.light = t, this.color = e;
                var n = new Rn;
                n.addAttribute("position", new Sn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), n.computeBoundingSphere();
                var r = new so({
                    fog: !1
                });
                co.call(this, n, r);
                var i = new Rn;
                i.addAttribute("position", new Sn([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), i.computeBoundingSphere(), this.add(new Pn(i, new vn({
                    side: g,
                    fog: !1
                }))), this.update()
            }

            function Xc(t, e, n) {
                en.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n;
                var r = new To(e);
                r.rotateY(.5 * Math.PI), this.material = new vn({
                    wireframe: !0,
                    fog: !1
                }), void 0 === this.color && (this.material.vertexColors = M);
                var i = r.getAttribute("position"),
                    o = new Float32Array(3 * i.count);
                r.addAttribute("color", new gn(o, 3)), this.add(new Pn(r, this.material)), this.update()
            }

            function Yc(t, e) {
                this.lightProbe = t, this.size = e;
                var n = new Hn({
                        defines: {
                            GAMMA_OUTPUT: ""
                        },
                        uniforms: {
                            sh: {
                                value: this.lightProbe.sh.coefficients
                            },
                            intensity: {
                                value: this.lightProbe.intensity
                            }
                        },
                        vertexShader: ["varying vec3 vNormal;", "void main() {", "\tvNormal = normalize( normalMatrix * normal );", "\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
                        fragmentShader: ["#define RECIPROCAL_PI 0.318309886", "vec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {", "\t// matrix is assumed to be orthogonal", "\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );", "}", "vec3 linearToOutput( in vec3 a ) {", "\t#ifdef GAMMA_OUTPUT", "\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );", "\t#else", "\t\treturn a;", "\t#endif", "}", "// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf", "vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {", "\t// normal is assumed to have unit length", "\tfloat x = normal.x, y = normal.y, z = normal.z;", "\t// band 0", "\tvec3 result = shCoefficients[ 0 ] * 0.886227;", "\t// band 1", "\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;", "\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;", "\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;", "\t// band 2", "\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;", "\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;", "\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );", "\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;", "\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );", "\treturn result;", "}", "uniform vec3 sh[ 9 ]; // sh coefficients", "uniform float intensity; // light probe intensity", "varying vec3 vNormal;", "void main() {", "\tvec3 normal = normalize( vNormal );", "\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );", "\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );", "\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;", "\toutgoingLight = linearToOutput( outgoingLight );", "\tgl_FragColor = vec4( outgoingLight, 1.0 );", "}"].join("\n")
                    }),
                    r = new ma(1, 32, 16);
                Pn.call(this, r, n), this.onBeforeRender()
            }

            function Jc(t, e, n, r) {
                t = t || 10, e = e || 10, n = new un(void 0 !== n ? n : 4473924), r = new un(void 0 !== r ? r : 8947848);
                for (var i = e / 2, o = t / e, a = t / 2, s = [], c = [], u = 0, l = 0, h = -a; u <= e; u++, h += o) {
                    s.push(-a, 0, h, a, 0, h), s.push(h, 0, -a, h, 0, a);
                    var p = u === i ? n : r;
                    p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3, p.toArray(c, l), l += 3
                }
                var d = new Rn;
                d.addAttribute("position", new Sn(s, 3)), d.addAttribute("color", new Sn(c, 3));
                var f = new so({
                    vertexColors: M
                });
                uo.call(this, d, f)
            }

            function Zc(t, e, n, r, i, o) {
                t = t || 10, e = e || 16, n = n || 8, r = r || 64, i = new un(void 0 !== i ? i : 4473924), o = new un(void 0 !== o ? o : 8947848);
                var a, s, c, u, l, h, p, d = [],
                    f = [];
                for (u = 0; u <= e; u++) c = u / e * (2 * Math.PI), a = Math.sin(c) * t, s = Math.cos(c) * t, d.push(0, 0, 0), d.push(a, 0, s), p = 1 & u ? i : o, f.push(p.r, p.g, p.b), f.push(p.r, p.g, p.b);
                for (u = 0; u <= n; u++)
                    for (p = 1 & u ? i : o, h = t - t / n * u, l = 0; l < r; l++) c = l / r * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, d.push(a, 0, s), f.push(p.r, p.g, p.b), c = (l + 1) / r * (2 * Math.PI), a = Math.sin(c) * h, s = Math.cos(c) * h, d.push(a, 0, s), f.push(p.r, p.g, p.b);
                var m = new Rn;
                m.addAttribute("position", new Sn(d, 3)), m.addAttribute("color", new Sn(f, 3));
                var v = new so({
                    vertexColors: M
                });
                uo.call(this, m, v)
            }

            function Qc(t, e, n, r) {
                this.audio = t, this.range = e || 1, this.divisionsInnerAngle = n || 16, this.divisionsOuterAngle = r || 2;
                var i = new Rn,
                    o = this.divisionsInnerAngle + 2 * this.divisionsOuterAngle,
                    a = new Float32Array(3 * (3 * o + 3));
                i.addAttribute("position", new gn(a, 3));
                var s = new so({
                        color: 65280
                    }),
                    c = new so({
                        color: 16776960
                    });
                co.call(this, i, [c, s]), this.update()
            }

            function Kc(t, e, n, r) {
                this.object = t, this.size = void 0 !== e ? e : 1;
                var i = void 0 !== n ? n : 16776960,
                    o = void 0 !== r ? r : 1,
                    a = 0,
                    s = this.object.geometry;
                s && s.isGeometry ? a = s.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
                var c = new Rn,
                    u = new Sn(2 * a * 3, 3);
                c.addAttribute("position", u), uo.call(this, c, new so({
                    color: i,
                    linewidth: o
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function $c(t, e, n) {
                en.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, void 0 === e && (e = 1);
                var r = new Rn;
                r.addAttribute("position", new Sn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3));
                var i = new so({
                    fog: !1
                });
                this.lightPlane = new co(r, i), this.add(this.lightPlane), (r = new Rn).addAttribute("position", new Sn([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new co(r, i), this.add(this.targetLine), this.update()
            }

            function tu(t) {
                var e = new Rn,
                    n = new so({
                        color: 16777215,
                        vertexColors: _
                    }),
                    r = [],
                    i = [],
                    o = {},
                    a = new un(16755200),
                    s = new un(16711680),
                    c = new un(43775),
                    u = new un(16777215),
                    l = new un(3355443);

                function h(t, e, n) {
                    p(t, n), p(e, n)
                }

                function p(t, e) {
                    r.push(0, 0, 0), i.push(e.r, e.g, e.b), void 0 === o[t] && (o[t] = []), o[t].push(r.length / 3 - 1)
                }
                h("n1", "n2", a), h("n2", "n4", a), h("n4", "n3", a), h("n3", "n1", a), h("f1", "f2", a), h("f2", "f4", a), h("f4", "f3", a), h("f3", "f1", a), h("n1", "f1", a), h("n2", "f2", a), h("n3", "f3", a), h("n4", "f4", a), h("p", "n1", s), h("p", "n2", s), h("p", "n3", s), h("p", "n4", s), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c), h("c", "t", u), h("p", "c", l), h("cn1", "cn2", l), h("cn3", "cn4", l), h("cf1", "cf2", l), h("cf3", "cf4", l), e.addAttribute("position", new Sn(r, 3)), e.addAttribute("color", new Sn(i, 3)), uo.call(this, e, n), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update()
            }

            function eu(t, e) {
                this.object = t, void 0 === e && (e = 16776960);
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Float32Array(24),
                    i = new Rn;
                i.setIndex(new gn(n, 1)), i.addAttribute("position", new gn(r, 3)), uo.call(this, i, new so({
                    color: e
                })), this.matrixAutoUpdate = !1, this.update()
            }

            function nu(t, e) {
                this.type = "Box3Helper", this.box = t, e = e || 16776960;
                var n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
                    r = new Rn;
                r.setIndex(new gn(n, 1)), r.addAttribute("position", new Sn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), uo.call(this, r, new so({
                    color: e
                })), this.geometry.computeBoundingSphere()
            }

            function ru(t, e, n) {
                this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e;
                var r = void 0 !== n ? n : 16776960,
                    i = new Rn;
                i.addAttribute("position", new Sn([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), i.computeBoundingSphere(), co.call(this, i, new so({
                    color: r
                }));
                var o = new Rn;
                o.addAttribute("position", new Sn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), o.computeBoundingSphere(), this.add(new Pn(o, new vn({
                    color: r,
                    opacity: .2,
                    transparent: !0,
                    depthWrite: !1
                })))
            }

            function iu(t, e, n, r, i, o) {
                en.call(this), void 0 === t && (t = new je(0, 0, 1)), void 0 === e && (e = new je(0, 0, 0)), void 0 === n && (n = 1), void 0 === r && (r = 16776960), void 0 === i && (i = .2 * n), void 0 === o && (o = .2 * i), void 0 === Ec && ((Ec = new Rn).addAttribute("position", new Sn([0, 0, 0, 0, 1, 0], 3)), (Sc = new Sa(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new co(Ec, new so({
                    color: r
                })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Pn(Sc, new vn({
                    color: r
                })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(n, i, o)
            }

            function ou(t) {
                var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
                    n = new Rn;
                n.addAttribute("position", new Sn(e, 3)), n.addAttribute("color", new Sn([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
                var r = new so({
                    vertexColors: M
                });
                uo.call(this, n, r)
            }

            function au(t, e, n, r, i, o, a) {
                return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new dn(t, e, n, i, o, a)
            }
            Object.assign(Ac.prototype, {
                getValue: function(t, e) {
                    this.bind();
                    var n = this._targetGroup.nCachedObjects_,
                        r = this._bindings[n];
                    void 0 !== r && r.getValue(t, e)
                },
                setValue: function(t, e) {
                    for (var n = this._bindings, r = this._targetGroup.nCachedObjects_, i = n.length; r !== i; ++r) n[r].setValue(t, e)
                },
                bind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].bind()
                },
                unbind: function() {
                    for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e) t[e].unbind()
                }
            }), Object.assign(Lc, {
                Composite: Ac,
                create: function(t, e, n) {
                    return t && t.isAnimationObjectGroup ? new Lc.Composite(t, e, n) : new Lc(t, e, n)
                },
                sanitizeNodeName: function() {
                    var t = new RegExp("[" + Tc + "]", "g");
                    return function(e) {
                        return e.replace(/\s/g, "_").replace(t, "")
                    }
                }(),
                parseTrackName: function() {
                    var t = "[^" + Tc + "]",
                        e = "[^" + Tc.replace("\\.", "") + "]",
                        n = /((?:WC+[\/:])*)/.source.replace("WC", t),
                        r = /(WCOD+)?/.source.replace("WCOD", e),
                        i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t),
                        o = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t),
                        a = new RegExp("^" + n + r + i + o + "$"),
                        s = ["material", "materials", "bones"];
                    return function(t) {
                        var e = a.exec(t);
                        if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
                        var n = {
                                nodeName: e[2],
                                objectName: e[3],
                                objectIndex: e[4],
                                propertyName: e[5],
                                propertyIndex: e[6]
                            },
                            r = n.nodeName && n.nodeName.lastIndexOf(".");
                        if (void 0 !== r && -1 !== r) {
                            var i = n.nodeName.substring(r + 1); - 1 !== s.indexOf(i) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = i)
                        }
                        if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                        return n
                    }
                }(),
                findNode: function(t, e) {
                    if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
                    if (t.skeleton) {
                        var n = t.skeleton.getBoneByName(e);
                        if (void 0 !== n) return n
                    }
                    if (t.children) {
                        var r = function(t) {
                                for (var n = 0; n < t.length; n++) {
                                    var i = t[n];
                                    if (i.name === e || i.uuid === e) return i;
                                    var o = r(i.children);
                                    if (o) return o
                                }
                                return null
                            },
                            i = r(t.children);
                        if (i) return i
                    }
                    return null
                }
            }), Object.assign(Lc.prototype, {
                _getValue_unavailable: function() {},
                _setValue_unavailable: function() {},
                BindingType: {
                    Direct: 0,
                    EntireArray: 1,
                    ArrayElement: 2,
                    HasFromToArray: 3
                },
                Versioning: {
                    None: 0,
                    NeedsUpdate: 1,
                    MatrixWorldNeedsUpdate: 2
                },
                GetterByBindingType: [function(t, e) {
                    t[e] = this.node[this.propertyName]
                }, function(t, e) {
                    for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) t[e++] = n[r]
                }, function(t, e) {
                    t[e] = this.resolvedProperty[this.propertyIndex]
                }, function(t, e) {
                    this.resolvedProperty.toArray(t, e)
                }],
                SetterByBindingTypeAndVersioning: [
                    [function(t, e) {
                        this.targetObject[this.propertyName] = t[e]
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++]
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        for (var n = this.resolvedProperty, r = 0, i = n.length; r !== i; ++r) n[r] = t[e++];
                        this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e]
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
                    }],
                    [function(t, e) {
                        this.resolvedProperty.fromArray(t, e)
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
                    }, function(t, e) {
                        this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
                    }]
                ],
                getValue: function(t, e) {
                    this.bind(), this.getValue(t, e)
                },
                setValue: function(t, e) {
                    this.bind(), this.setValue(t, e)
                },
                bind: function() {
                    var t = this.node,
                        e = this.parsedPath,
                        n = e.objectName,
                        r = e.propertyName,
                        i = e.propertyIndex;
                    if (t || (t = Lc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                        if (n) {
                            var o = e.objectIndex;
                            switch (n) {
                                case "materials":
                                    if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                                    if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                                    t = t.material.materials;
                                    break;
                                case "bones":
                                    if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                                    t = t.skeleton.bones;
                                    for (var a = 0; a < t.length; a++)
                                        if (t[a].name === o) {
                                            o = a;
                                            break
                                        }
                                    break;
                                default:
                                    if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                                    t = t[n]
                            }
                            if (void 0 !== o) {
                                if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                                t = t[o]
                            }
                        }
                        var s = t[r];
                        if (void 0 !== s) {
                            var c = this.Versioning.None;
                            this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
                            var u = this.BindingType.Direct;
                            if (void 0 !== i) {
                                if ("morphTargetInfluences" === r) {
                                    if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                                    if (t.geometry.isBufferGeometry) {
                                        if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                        for (a = 0; a < this.node.geometry.morphAttributes.position.length; a++)
                                            if (t.geometry.morphAttributes.position[a].name === i) {
                                                i = a;
                                                break
                                            }
                                    } else {
                                        if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                        for (a = 0; a < this.node.geometry.morphTargets.length; a++)
                                            if (t.geometry.morphTargets[a].name === i) {
                                                i = a;
                                                break
                                            }
                                    }
                                }
                                u = this.BindingType.ArrayElement, this.resolvedProperty = s, this.propertyIndex = i
                            } else void 0 !== s.fromArray && void 0 !== s.toArray ? (u = this.BindingType.HasFromToArray, this.resolvedProperty = s) : Array.isArray(s) ? (u = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                            this.getValue = this.GetterByBindingType[u], this.setValue = this.SetterByBindingTypeAndVersioning[u][c]
                        } else {
                            var l = e.nodeName;
                            console.error("THREE.PropertyBinding: Trying to update property for track: " + l + "." + r + " but it wasn't found.", t)
                        }
                    } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
                },
                unbind: function() {
                    this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
                }
            }), Object.assign(Lc.prototype, {
                _getValue_unbound: Lc.prototype.getValue,
                _setValue_unbound: Lc.prototype.setValue
            }), Object.assign(Cc.prototype, {
                isAnimationObjectGroup: !0,
                add: function() {
                    for (var t = this._objects, e = t.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, u = 0, l = arguments.length; u !== l; ++u) {
                        var h = arguments[u],
                            p = h.uuid,
                            d = r[p];
                        if (void 0 === d) {
                            d = e++, r[p] = d, t.push(h);
                            for (var f = 0, m = s; f !== m; ++f) a[f].push(new Lc(h, i[f], o[f]))
                        } else if (d < n) {
                            c = t[d];
                            var v = --n,
                                g = t[v];
                            for (r[g.uuid] = d, t[d] = g, r[p] = v, t[v] = h, f = 0, m = s; f !== m; ++f) {
                                var y = a[f],
                                    x = y[v],
                                    b = y[d];
                                y[d] = x, void 0 === b && (b = new Lc(h, i[f], o[f])), y[v] = b
                            }
                        } else t[d] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
                    }
                    this.nCachedObjects_ = n
                },
                remove: function() {
                    for (var t = this._objects, e = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, i = r.length, o = 0, a = arguments.length; o !== a; ++o) {
                        var s = arguments[o],
                            c = s.uuid,
                            u = n[c];
                        if (void 0 !== u && u >= e) {
                            var l = e++,
                                h = t[l];
                            n[h.uuid] = u, t[u] = h, n[c] = l, t[l] = s;
                            for (var p = 0, d = i; p !== d; ++p) {
                                var f = r[p],
                                    m = f[l],
                                    v = f[u];
                                f[u] = m, f[l] = v
                            }
                        }
                    }
                    this.nCachedObjects_ = e
                },
                uncache: function() {
                    for (var t = this._objects, e = t.length, n = this.nCachedObjects_, r = this._indicesByUUID, i = this._bindings, o = i.length, a = 0, s = arguments.length; a !== s; ++a) {
                        var c = arguments[a],
                            u = c.uuid,
                            l = r[u];
                        if (void 0 !== l)
                            if (delete r[u], l < n) {
                                var h = --n,
                                    p = t[h],
                                    d = --e,
                                    f = t[d];
                                r[p.uuid] = l, t[l] = p, r[f.uuid] = h, t[h] = f, t.pop();
                                for (var m = 0, v = o; m !== v; ++m) {
                                    var g = i[m],
                                        y = g[h],
                                        x = g[d];
                                    g[l] = y, g[h] = x, g.pop()
                                }
                            } else
                                for (r[(f = t[d = --e]).uuid] = l, t[l] = f, t.pop(), m = 0, v = o; m !== v; ++m)(g = i[m])[l] = g[d], g.pop()
                    }
                    this.nCachedObjects_ = n
                },
                subscribe_: function(t, e) {
                    var n = this._bindingsIndicesByPath,
                        r = n[t],
                        i = this._bindings;
                    if (void 0 !== r) return i[r];
                    var o = this._paths,
                        a = this._parsedPaths,
                        s = this._objects,
                        c = s.length,
                        u = this.nCachedObjects_,
                        l = new Array(c);
                    r = i.length, n[t] = r, o.push(t), a.push(e), i.push(l);
                    for (var h = u, p = s.length; h !== p; ++h) {
                        var d = s[h];
                        l[h] = new Lc(d, t, e)
                    }
                    return l
                },
                unsubscribe_: function(t) {
                    var e = this._bindingsIndicesByPath,
                        n = e[t];
                    if (void 0 !== n) {
                        var r = this._paths,
                            i = this._parsedPaths,
                            o = this._bindings,
                            a = o.length - 1,
                            s = o[a];
                        e[t[a]] = n, o[n] = s, o.pop(), i[n] = i[a], i.pop(), r[n] = r[a], r.pop()
                    }
                }
            }), Object.assign(Rc.prototype, {
                play: function() {
                    return this._mixer._activateAction(this), this
                },
                stop: function() {
                    return this._mixer._deactivateAction(this), this.reset()
                },
                reset: function() {
                    return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
                },
                isRunning: function() {
                    return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
                },
                isScheduled: function() {
                    return this._mixer._isActiveAction(this)
                },
                startAt: function(t) {
                    return this._startTime = t, this
                },
                setLoop: function(t, e) {
                    return this.loop = t, this.repetitions = e, this
                },
                setEffectiveWeight: function(t) {
                    return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
                },
                getEffectiveWeight: function() {
                    return this._effectiveWeight
                },
                fadeIn: function(t) {
                    return this._scheduleFading(t, 0, 1)
                },
                fadeOut: function(t) {
                    return this._scheduleFading(t, 1, 0)
                },
                crossFadeFrom: function(t, e, n) {
                    if (t.fadeOut(e), this.fadeIn(e), n) {
                        var r = this._clip.duration,
                            i = t._clip.duration,
                            o = i / r,
                            a = r / i;
                        t.warp(1, o, e), this.warp(a, 1, e)
                    }
                    return this
                },
                crossFadeTo: function(t, e, n) {
                    return t.crossFadeFrom(this, e, n)
                },
                stopFading: function() {
                    var t = this._weightInterpolant;
                    return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                },
                setEffectiveTimeScale: function(t) {
                    return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
                },
                getEffectiveTimeScale: function() {
                    return this._effectiveTimeScale
                },
                setDuration: function(t) {
                    return this.timeScale = this._clip.duration / t, this.stopWarping()
                },
                syncWith: function(t) {
                    return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
                },
                halt: function(t) {
                    return this.warp(this._effectiveTimeScale, 0, t)
                },
                warp: function(t, e, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._timeScaleInterpolant,
                        a = this.timeScale;
                    null === o && (o = r._lendControlInterpolant(), this._timeScaleInterpolant = o);
                    var s = o.parameterPositions,
                        c = o.sampleValues;
                    return s[0] = i, s[1] = i + n, c[0] = t / a, c[1] = e / a, this
                },
                stopWarping: function() {
                    var t = this._timeScaleInterpolant;
                    return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
                },
                getMixer: function() {
                    return this._mixer
                },
                getClip: function() {
                    return this._clip
                },
                getRoot: function() {
                    return this._localRoot || this._mixer._root
                },
                _update: function(t, e, n, r) {
                    if (this.enabled) {
                        var i = this._startTime;
                        if (null !== i) {
                            var o = (t - i) * n;
                            if (o < 0 || 0 === n) return;
                            this._startTime = null, e = n * o
                        }
                        e *= this._updateTimeScale(t);
                        var a = this._updateTime(e),
                            s = this._updateWeight(t);
                        if (s > 0)
                            for (var c = this._interpolants, u = this._propertyBindings, l = 0, h = c.length; l !== h; ++l) c[l].evaluate(a), u[l].accumulate(r, s)
                    } else this._updateWeight(t)
                },
                _updateWeight: function(t) {
                    var e = 0;
                    if (this.enabled) {
                        e = this.weight;
                        var n = this._weightInterpolant;
                        if (null !== n) {
                            var r = n.evaluate(t)[0];
                            e *= r, t > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
                        }
                    }
                    return this._effectiveWeight = e, e
                },
                _updateTimeScale: function(t) {
                    var e = 0;
                    if (!this.paused) {
                        e = this.timeScale;
                        var n = this._timeScaleInterpolant;
                        if (null !== n) e *= n.evaluate(t)[0], t > n.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                    }
                    return this._effectiveTimeScale = e, e
                },
                _updateTime: function(t) {
                    var e = this.time + t,
                        n = this._clip.duration,
                        r = this.loop,
                        i = this._loopCount,
                        o = r === ye;
                    if (0 === t) return -1 === i ? e : o && 1 == (1 & i) ? n - e : e;
                    if (r === ve) {
                        -1 === i && (this._loopCount = 0, this._setEndings(!0, !0, !1));
                        t: {
                            if (e >= n) e = n;
                            else {
                                if (!(e < 0)) {
                                    this.time = e;
                                    break t
                                }
                                e = 0
                            }
                            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = e, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t < 0 ? -1 : 1
                            })
                        }
                    } else {
                        if (-1 === i && (t >= 0 ? (i = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= n || e < 0) {
                            var a = Math.floor(e / n);
                            e -= n * a, i += Math.abs(a);
                            var s = this.repetitions - i;
                            if (s <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = t > 0 ? n : 0, this.time = e, this._mixer.dispatchEvent({
                                type: "finished",
                                action: this,
                                direction: t > 0 ? 1 : -1
                            });
                            else {
                                if (1 === s) {
                                    var c = t < 0;
                                    this._setEndings(c, !c, o)
                                } else this._setEndings(!1, !1, o);
                                this._loopCount = i, this.time = e, this._mixer.dispatchEvent({
                                    type: "loop",
                                    action: this,
                                    loopDelta: a
                                })
                            }
                        } else this.time = e;
                        if (o && 1 == (1 & i)) return n - e
                    }
                    return e
                },
                _setEndings: function(t, e, n) {
                    var r = this._interpolantSettings;
                    n ? (r.endingStart = Me, r.endingEnd = Me) : (r.endingStart = t ? this.zeroSlopeAtStart ? Me : _e : Ee, r.endingEnd = e ? this.zeroSlopeAtEnd ? Me : _e : Ee)
                },
                _scheduleFading: function(t, e, n) {
                    var r = this._mixer,
                        i = r.time,
                        o = this._weightInterpolant;
                    null === o && (o = r._lendControlInterpolant(), this._weightInterpolant = o);
                    var a = o.parameterPositions,
                        s = o.sampleValues;
                    return a[0] = i, s[0] = e, a[1] = i + t, s[1] = n, this
                }
            }), Pc.prototype = Object.assign(Object.create(r.prototype), {
                constructor: Pc,
                _bindAction: function(t, e) {
                    var n = t._localRoot || this._root,
                        r = t._clip.tracks,
                        i = r.length,
                        o = t._propertyBindings,
                        a = t._interpolants,
                        s = n.uuid,
                        c = this._bindingsByRootAndName,
                        u = c[s];
                    void 0 === u && (u = {}, c[s] = u);
                    for (var l = 0; l !== i; ++l) {
                        var h = r[l],
                            p = h.name,
                            d = u[p];
                        if (void 0 !== d) o[l] = d;
                        else {
                            if (void 0 !== (d = o[l])) {
                                null === d._cacheIndex && (++d.referenceCount, this._addInactiveBinding(d, s, p));
                                continue
                            }
                            var f = e && e._propertyBindings[l].binding.parsedPath;
                            ++(d = new Mc(Lc.create(n, p, f), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(d, s, p), o[l] = d
                        }
                        a[l].resultBuffer = d.buffer
                    }
                },
                _activateAction: function(t) {
                    if (!this._isActiveAction(t)) {
                        if (null === t._cacheIndex) {
                            var e = (t._localRoot || this._root).uuid,
                                n = t._clip.uuid,
                                r = this._actionsByClip[n];
                            this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
                        }
                        for (var i = t._propertyBindings, o = 0, a = i.length; o !== a; ++o) {
                            var s = i[o];
                            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState())
                        }
                        this._lendAction(t)
                    }
                },
                _deactivateAction: function(t) {
                    if (this._isActiveAction(t)) {
                        for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                            var i = e[n];
                            0 == --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
                        }
                        this._takeBackAction(t)
                    }
                },
                _initMemoryManager: function() {
                    this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
                    var t = this;
                    this.stats = {
                        actions: {get total() {
                                return t._actions.length
                            },
                            get inUse() {
                                return t._nActiveActions
                            }
                        },
                        bindings: {get total() {
                                return t._bindings.length
                            },
                            get inUse() {
                                return t._nActiveBindings
                            }
                        },
                        controlInterpolants: {get total() {
                                return t._controlInterpolants.length
                            },
                            get inUse() {
                                return t._nActiveControlInterpolants
                            }
                        }
                    }
                },
                _isActiveAction: function(t) {
                    var e = t._cacheIndex;
                    return null !== e && e < this._nActiveActions
                },
                _addInactiveAction: function(t, e, n) {
                    var r = this._actions,
                        i = this._actionsByClip,
                        o = i[e];
                    if (void 0 === o) o = {
                        knownActions: [t],
                        actionByRoot: {}
                    }, t._byClipCacheIndex = 0, i[e] = o;
                    else {
                        var a = o.knownActions;
                        t._byClipCacheIndex = a.length, a.push(t)
                    }
                    t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t
                },
                _removeInactiveAction: function(t) {
                    var e = this._actions,
                        n = e[e.length - 1],
                        r = t._cacheIndex;
                    n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
                    var i = t._clip.uuid,
                        o = this._actionsByClip,
                        a = o[i],
                        s = a.knownActions,
                        c = s[s.length - 1],
                        u = t._byClipCacheIndex;
                    c._byClipCacheIndex = u, s[u] = c, s.pop(), t._byClipCacheIndex = null, delete a.actionByRoot[(t._localRoot || this._root).uuid], 0 === s.length && delete o[i], this._removeInactiveBindingsForAction(t)
                },
                _removeInactiveBindingsForAction: function(t) {
                    for (var e = t._propertyBindings, n = 0, r = e.length; n !== r; ++n) {
                        var i = e[n];
                        0 == --i.referenceCount && this._removeInactiveBinding(i)
                    }
                },
                _lendAction: function(t) {
                    var e = this._actions,
                        n = t._cacheIndex,
                        r = this._nActiveActions++,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _takeBackAction: function(t) {
                    var e = this._actions,
                        n = t._cacheIndex,
                        r = --this._nActiveActions,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _addInactiveBinding: function(t, e, n) {
                    var r = this._bindingsByRootAndName,
                        i = r[e],
                        o = this._bindings;
                    void 0 === i && (i = {}, r[e] = i), i[n] = t, t._cacheIndex = o.length, o.push(t)
                },
                _removeInactiveBinding: function(t) {
                    var e = this._bindings,
                        n = t.binding,
                        r = n.rootNode.uuid,
                        i = n.path,
                        o = this._bindingsByRootAndName,
                        a = o[r],
                        s = e[e.length - 1],
                        c = t._cacheIndex;
                    s._cacheIndex = c, e[c] = s, e.pop(), delete a[i], 0 === Object.keys(a).length && delete o[r]
                },
                _lendBinding: function(t) {
                    var e = this._bindings,
                        n = t._cacheIndex,
                        r = this._nActiveBindings++,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _takeBackBinding: function(t) {
                    var e = this._bindings,
                        n = t._cacheIndex,
                        r = --this._nActiveBindings,
                        i = e[r];
                    t._cacheIndex = r, e[r] = t, i._cacheIndex = n, e[n] = i
                },
                _lendControlInterpolant: function() {
                    var t = this._controlInterpolants,
                        e = this._nActiveControlInterpolants++,
                        n = t[e];
                    return void 0 === n && ((n = new Wa(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = n), n
                },
                _takeBackControlInterpolant: function(t) {
                    var e = this._controlInterpolants,
                        n = t.__cacheIndex,
                        r = --this._nActiveControlInterpolants,
                        i = e[r];
                    t.__cacheIndex = r, e[r] = t, i.__cacheIndex = n, e[n] = i
                },
                _controlInterpolantsResultBuffer: new Float32Array(1),
                clipAction: function(t, e) {
                    var n = e || this._root,
                        r = n.uuid,
                        i = "string" == typeof t ? es.findByName(n, t) : t,
                        o = null !== i ? i.uuid : t,
                        a = this._actionsByClip[o],
                        s = null;
                    if (void 0 !== a) {
                        var c = a.actionByRoot[r];
                        if (void 0 !== c) return c;
                        s = a.knownActions[0], null === i && (i = s._clip)
                    }
                    if (null === i) return null;
                    var u = new Rc(this, i, e);
                    return this._bindAction(u, s), this._addInactiveAction(u, o, r), u
                },
                existingAction: function(t, e) {
                    var n = e || this._root,
                        r = n.uuid,
                        i = "string" == typeof t ? es.findByName(n, t) : t,
                        o = i ? i.uuid : t,
                        a = this._actionsByClip[o];
                    return void 0 !== a && a.actionByRoot[r] || null
                },
                stopAllAction: function() {
                    var t = this._actions,
                        e = this._nActiveActions,
                        n = this._bindings,
                        r = this._nActiveBindings;
                    this._nActiveActions = 0, this._nActiveBindings = 0;
                    for (var i = 0; i !== e; ++i) t[i].reset();
                    for (i = 0; i !== r; ++i) n[i].useCount = 0;
                    return this
                },
                update: function(t) {
                    t *= this.timeScale;
                    for (var e = this._actions, n = this._nActiveActions, r = this.time += t, i = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== n; ++a) {
                        e[a]._update(r, t, i, o)
                    }
                    var s = this._bindings,
                        c = this._nActiveBindings;
                    for (a = 0; a !== c; ++a) s[a].apply(o);
                    return this
                },
                getRoot: function() {
                    return this._root
                },
                uncacheClip: function(t) {
                    var e = this._actions,
                        n = t.uuid,
                        r = this._actionsByClip,
                        i = r[n];
                    if (void 0 !== i) {
                        for (var o = i.knownActions, a = 0, s = o.length; a !== s; ++a) {
                            var c = o[a];
                            this._deactivateAction(c);
                            var u = c._cacheIndex,
                                l = e[e.length - 1];
                            c._cacheIndex = null, c._byClipCacheIndex = null, l._cacheIndex = u, e[u] = l, e.pop(), this._removeInactiveBindingsForAction(c)
                        }
                        delete r[n]
                    }
                },
                uncacheRoot: function(t) {
                    var e = t.uuid,
                        n = this._actionsByClip;
                    for (var r in n) {
                        var i = n[r].actionByRoot[e];
                        void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
                    }
                    var o = this._bindingsByRootAndName[e];
                    if (void 0 !== o)
                        for (var a in o) {
                            var s = o[a];
                            s.restoreOriginalState(), this._removeInactiveBinding(s)
                        }
                },
                uncacheAction: function(t, e) {
                    var n = this.existingAction(t, e);
                    null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
                }
            }), Oc.prototype.clone = function() {
                return new Oc(void 0 === this.value.clone ? this.value : this.value.clone())
            }, Ic.prototype = Object.assign(Object.create($i.prototype), {
                constructor: Ic,
                isInstancedInterleavedBuffer: !0,
                copy: function(t) {
                    return $i.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
                }
            }), Object.assign(Bc.prototype, {
                linePrecision: 1,
                set: function(t, e) {
                    this.ray.set(t, e)
                },
                setFromCamera: function(t, e) {
                    e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this._camera = e) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this._camera = e) : console.error("THREE.Raycaster: Unsupported camera type.")
                },
                intersectObject: function(t, e, n) {
                    var r = n || [];
                    return Fc(t, this, r, e), r.sort(Dc), r
                },
                intersectObjects: function(t, e, n) {
                    var r = n || [];
                    if (!1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), r;
                    for (var i = 0, o = t.length; i < o; i++) Fc(t[i], this, r, e);
                    return r.sort(Dc), r
                }
            }), Object.assign(kc.prototype, {
                set: function(t, e, n) {
                    return this.radius = t, this.phi = e, this.theta = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
                },
                makeSafe: function() {
                    return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
                },
                setFromVector3: function(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                },
                setFromCartesianCoords: function(t, e, n) {
                    return this.radius = Math.sqrt(t * t + e * e + n * n), 0 === this.radius ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(Ge.clamp(e / this.radius, -1, 1))), this
                }
            }), Object.assign(Nc.prototype, {
                set: function(t, e, n) {
                    return this.radius = t, this.theta = e, this.y = n, this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
                },
                setFromVector3: function(t) {
                    return this.setFromCartesianCoords(t.x, t.y, t.z)
                },
                setFromCartesianCoords: function(t, e, n) {
                    return this.radius = Math.sqrt(t * t + n * n), this.theta = Math.atan2(t, n), this.y = e, this
                }
            }), Object.assign(zc.prototype, {
                set: function(t, e) {
                    return this.min.copy(t), this.max.copy(e), this
                },
                setFromPoints: function(t) {
                    this.makeEmpty();
                    for (var e = 0, n = t.length; e < n; e++) this.expandByPoint(t[e]);
                    return this
                },
                setFromCenterAndSize: function() {
                    var t = new He;
                    return function(e, n) {
                        var r = t.copy(n).multiplyScalar(.5);
                        return this.min.copy(e).sub(r), this.max.copy(e).add(r), this
                    }
                }(),
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.min.copy(t.min), this.max.copy(t.max), this
                },
                makeEmpty: function() {
                    return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
                },
                isEmpty: function() {
                    return this.max.x < this.min.x || this.max.y < this.min.y
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new He), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
                },
                getSize: function(t) {
                    return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new He), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
                },
                expandByPoint: function(t) {
                    return this.min.min(t), this.max.max(t), this
                },
                expandByVector: function(t) {
                    return this.min.sub(t), this.max.add(t), this
                },
                expandByScalar: function(t) {
                    return this.min.addScalar(-t), this.max.addScalar(t), this
                },
                containsPoint: function(t) {
                    return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
                },
                containsBox: function(t) {
                    return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
                },
                getParameter: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new He), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
                },
                intersectsBox: function(t) {
                    return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
                },
                clampPoint: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new He), e.copy(t).clamp(this.min, this.max)
                },
                distanceToPoint: function() {
                    var t = new He;
                    return function(e) {
                        return t.copy(e).clamp(this.min, this.max).sub(e).length()
                    }
                }(),
                intersect: function(t) {
                    return this.min.max(t.min), this.max.min(t.max), this
                },
                union: function(t) {
                    return this.min.min(t.min), this.max.max(t.max), this
                },
                translate: function(t) {
                    return this.min.add(t), this.max.add(t), this
                },
                equals: function(t) {
                    return t.min.equals(this.min) && t.max.equals(this.max)
                }
            }), Object.assign(Gc.prototype, {
                set: function(t, e) {
                    return this.start.copy(t), this.end.copy(e), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                },
                copy: function(t) {
                    return this.start.copy(t.start), this.end.copy(t.end), this
                },
                getCenter: function(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new je), t.addVectors(this.start, this.end).multiplyScalar(.5)
                },
                delta: function(t) {
                    return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new je), t.subVectors(this.end, this.start)
                },
                distanceSq: function() {
                    return this.start.distanceToSquared(this.end)
                },
                distance: function() {
                    return this.start.distanceTo(this.end)
                },
                at: function(t, e) {
                    return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new je), this.delta(e).multiplyScalar(t).add(this.start)
                },
                closestPointToPointParameter: function() {
                    var t = new je,
                        e = new je;
                    return function(n, r) {
                        t.subVectors(n, this.start), e.subVectors(this.end, this.start);
                        var i = e.dot(e),
                            o = e.dot(t) / i;
                        return r && (o = Ge.clamp(o, 0, 1)), o
                    }
                }(),
                closestPointToPoint: function(t, e, n) {
                    var r = this.closestPointToPointParameter(t, e);
                    return void 0 === n && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), n = new je), this.delta(n).multiplyScalar(r).add(this.start)
                },
                applyMatrix4: function(t) {
                    return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
                },
                equals: function(t) {
                    return t.start.equals(this.start) && t.end.equals(this.end)
                }
            }), Hc.prototype = Object.create(en.prototype), Hc.prototype.constructor = Hc, Hc.prototype.isImmediateRenderObject = !0, Uc.prototype = Object.create(uo.prototype), Uc.prototype.constructor = Uc, Uc.prototype.update = function() {
                var t = new je,
                    e = new je,
                    n = new Ve;
                return function() {
                    var r = ["a", "b", "c"];
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    var i = this.object.matrixWorld,
                        o = this.geometry.attributes.position,
                        a = this.object.geometry;
                    if (a && a.isGeometry)
                        for (var s = a.vertices, c = a.faces, u = 0, l = 0, h = c.length; l < h; l++)
                            for (var p = c[l], d = 0, f = p.vertexNormals.length; d < f; d++) {
                                var m = s[p[r[d]]],
                                    v = p.vertexNormals[d];
                                t.copy(m).applyMatrix4(i), e.copy(v).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(u, t.x, t.y, t.z), u += 1, o.setXYZ(u, e.x, e.y, e.z), u += 1
                            } else if (a && a.isBufferGeometry) {
                                var g = a.attributes.position,
                                    y = a.attributes.normal;
                                for (u = 0, d = 0, f = g.count; d < f; d++) t.set(g.getX(d), g.getY(d), g.getZ(d)).applyMatrix4(i), e.set(y.getX(d), y.getY(d), y.getZ(d)), e.applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), o.setXYZ(u, t.x, t.y, t.z), u += 1, o.setXYZ(u, e.x, e.y, e.z), u += 1
                            }
                    o.needsUpdate = !0
                }
            }(), jc.prototype = Object.create(en.prototype), jc.prototype.constructor = jc, jc.prototype.dispose = function() {
                this.cone.geometry.dispose(), this.cone.material.dispose()
            }, jc.prototype.update = function() {
                var t = new je;
                return function() {
                    this.light.updateMatrixWorld();
                    var e = this.light.distance ? this.light.distance : 1e3,
                        n = e * Math.tan(this.light.angle);
                    this.cone.scale.set(n, n, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
                }
            }(), Vc.prototype = Object.create(uo.prototype), Vc.prototype.constructor = Vc, Vc.prototype.updateMatrixWorld = function() {
                var t = new je,
                    e = new Qe,
                    n = new Qe;
                return function(r) {
                    var i = this.bones,
                        o = this.geometry,
                        a = o.getAttribute("position");
                    n.getInverse(this.root.matrixWorld);
                    for (var s = 0, c = 0; s < i.length; s++) {
                        var u = i[s];
                        u.parent && u.parent.isBone && (e.multiplyMatrices(n, u.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(n, u.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c + 1, t.x, t.y, t.z), c += 2)
                    }
                    o.getAttribute("position").needsUpdate = !0, en.prototype.updateMatrixWorld.call(this, r)
                }
            }(), Wc.prototype = Object.create(Pn.prototype), Wc.prototype.constructor = Wc, Wc.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, Wc.prototype.update = function() {
                void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
            }, qc.prototype = Object.create(co.prototype), qc.prototype.constructor = qc, qc.prototype.update = function() {
                if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
                else {
                    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
                    var t = this.material.color,
                        e = Math.max(t.r, t.g, t.b);
                    e > 1 && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
                }
            }, qc.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, Xc.prototype = Object.create(en.prototype), Xc.prototype.constructor = Xc, Xc.prototype.dispose = function() {
                this.children[0].geometry.dispose(), this.children[0].material.dispose()
            }, Xc.prototype.update = function() {
                var t = new je,
                    e = new un,
                    n = new un;
                return function() {
                    var r = this.children[0];
                    if (void 0 !== this.color) this.material.color.set(this.color);
                    else {
                        var i = r.geometry.getAttribute("color");
                        e.copy(this.light.color), n.copy(this.light.groundColor);
                        for (var o = 0, a = i.count; o < a; o++) {
                            var s = o < a / 2 ? e : n;
                            i.setXYZ(o, s.r, s.g, s.b)
                        }
                        i.needsUpdate = !0
                    }
                    r.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
                }
            }(), Yc.prototype = Object.create(Pn.prototype), Yc.prototype.constructor = Yc, Yc.prototype.dispose = function() {
                this.geometry.dispose(), this.material.dispose()
            }, Yc.prototype.onBeforeRender = function() {
                this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity
            }, Jc.prototype = Object.assign(Object.create(uo.prototype), {
                constructor: Jc,
                copy: function(t) {
                    return uo.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
                },
                clone: function() {
                    return (new this.constructor).copy(this)
                }
            }), Zc.prototype = Object.create(uo.prototype), Zc.prototype.constructor = Zc, Qc.prototype = Object.create(co.prototype), Qc.prototype.constructor = Qc, Qc.prototype.update = function() {
                var t, e, n = this.audio,
                    r = this.range,
                    i = this.divisionsInnerAngle,
                    o = this.divisionsOuterAngle,
                    a = Ge.degToRad(n.panner.coneInnerAngle),
                    s = Ge.degToRad(n.panner.coneOuterAngle),
                    c = a / 2,
                    u = s / 2,
                    l = 0,
                    h = 0,
                    p = this.geometry,
                    d = p.attributes.position;

                function f(n, i, o, a) {
                    var s = (i - n) / o;
                    for (d.setXYZ(l, 0, 0, 0), h++, t = n; t < i; t += s) e = l + h, d.setXYZ(e, Math.sin(t) * r, 0, Math.cos(t) * r), d.setXYZ(e + 1, Math.sin(Math.min(t + s, i)) * r, 0, Math.cos(Math.min(t + s, i)) * r), d.setXYZ(e + 2, 0, 0, 0), h += 3;
                    p.addGroup(l, h, a), l += h, h = 0
                }
                p.clearGroups(), f(-u, -c, o, 0), f(-c, c, i, 1), f(c, u, o, 0), d.needsUpdate = !0, a === s && (this.material[0].visible = !1)
            }, Qc.prototype.dispose = function() {
                this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose()
            }, Kc.prototype = Object.create(uo.prototype), Kc.prototype.constructor = Kc, Kc.prototype.update = function() {
                var t = new je,
                    e = new je,
                    n = new Ve;
                return function() {
                    this.object.updateMatrixWorld(!0), n.getNormalMatrix(this.object.matrixWorld);
                    for (var r = this.object.matrixWorld, i = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = o.faces, c = 0, u = 0, l = s.length; u < l; u++) {
                        var h = s[u],
                            p = h.normal;
                        t.copy(a[h.a]).add(a[h.b]).add(a[h.c]).divideScalar(3).applyMatrix4(r), e.copy(p).applyMatrix3(n).normalize().multiplyScalar(this.size).add(t), i.setXYZ(c, t.x, t.y, t.z), c += 1, i.setXYZ(c, e.x, e.y, e.z), c += 1
                    }
                    i.needsUpdate = !0
                }
            }(), $c.prototype = Object.create(en.prototype), $c.prototype.constructor = $c, $c.prototype.dispose = function() {
                this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
            }, $c.prototype.update = function() {
                var t = new je,
                    e = new je,
                    n = new je;
                return function() {
                    t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), n.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = n.length()
                }
            }(), tu.prototype = Object.create(uo.prototype), tu.prototype.constructor = tu, tu.prototype.update = function() {
                var t, e, n = new je,
                    r = new Un;

                function i(i, o, a, s) {
                    n.set(o, a, s).unproject(r);
                    var c = e[i];
                    if (void 0 !== c)
                        for (var u = t.getAttribute("position"), l = 0, h = c.length; l < h; l++) u.setXYZ(c[l], n.x, n.y, n.z)
                }
                return function() {
                    t = this.geometry, e = this.pointMap;
                    r.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), i("c", 0, 0, -1), i("t", 0, 0, 1), i("n1", -1, -1, -1), i("n2", 1, -1, -1), i("n3", -1, 1, -1), i("n4", 1, 1, -1), i("f1", -1, -1, 1), i("f2", 1, -1, 1), i("f3", -1, 1, 1), i("f4", 1, 1, 1), i("u1", .7, 1.1, -1), i("u2", -.7, 1.1, -1), i("u3", 0, 2, -1), i("cf1", -1, 0, 1), i("cf2", 1, 0, 1), i("cf3", 0, -1, 1), i("cf4", 0, 1, 1), i("cn1", -1, 0, -1), i("cn2", 1, 0, -1), i("cn3", 0, -1, -1), i("cn4", 0, 1, -1), t.getAttribute("position").needsUpdate = !0
                }
            }(), eu.prototype = Object.create(uo.prototype), eu.prototype.constructor = eu, eu.prototype.update = function() {
                var t = new rn;
                return function(e) {
                    if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                        var n = t.min,
                            r = t.max,
                            i = this.geometry.attributes.position,
                            o = i.array;
                        o[0] = r.x, o[1] = r.y, o[2] = r.z, o[3] = n.x, o[4] = r.y, o[5] = r.z, o[6] = n.x, o[7] = n.y, o[8] = r.z, o[9] = r.x, o[10] = n.y, o[11] = r.z, o[12] = r.x, o[13] = r.y, o[14] = n.z, o[15] = n.x, o[16] = r.y, o[17] = n.z, o[18] = n.x, o[19] = n.y, o[20] = n.z, o[21] = r.x, o[22] = n.y, o[23] = n.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
                    }
                }
            }(), eu.prototype.setFromObject = function(t) {
                return this.object = t, this.update(), this
            }, eu.prototype.copy = function(t) {
                return uo.prototype.copy.call(this, t), this.object = t.object, this
            }, eu.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, nu.prototype = Object.create(uo.prototype), nu.prototype.constructor = nu, nu.prototype.updateMatrixWorld = function(t) {
                var e = this.box;
                e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), en.prototype.updateMatrixWorld.call(this, t))
            }, ru.prototype = Object.create(co.prototype), ru.prototype.constructor = ru, ru.prototype.updateMatrixWorld = function(t) {
                var e = -this.plane.constant;
                Math.abs(e) < 1e-8 && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = e < 0 ? g : v, this.lookAt(this.plane.normal), en.prototype.updateMatrixWorld.call(this, t)
            }, iu.prototype = Object.create(en.prototype), iu.prototype.constructor = iu, iu.prototype.setDirection = function() {
                var t, e = new je;
                return function(n) {
                    n.y > .99999 ? this.quaternion.set(0, 0, 0, 1) : n.y < -.99999 ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
                }
            }(), iu.prototype.setLength = function(t, e, n) {
                void 0 === e && (e = .2 * t), void 0 === n && (n = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(n, e, n), this.cone.position.y = t, this.cone.updateMatrix()
            }, iu.prototype.setColor = function(t) {
                this.line.material.color.set(t), this.cone.material.color.set(t)
            }, iu.prototype.copy = function(t) {
                return en.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
            }, iu.prototype.clone = function() {
                return (new this.constructor).copy(this)
            }, ou.prototype = Object.create(uo.prototype), ou.prototype.constructor = ou;
            var su = 0,
                cu = 1;

            function uu(t) {
                return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
            }

            function lu(t) {
                return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function() {
                    return t.slice()
                }, t
            }

            function hu(t, e) {
                return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new po(t, e)
            }

            function pu(t) {
                return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new no(t)
            }

            function du(t, e) {
                return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new po(t, e)
            }

            function fu(t) {
                return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ho(t)
            }

            function mu(t) {
                return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ho(t)
            }

            function vu(t) {
                return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ho(t)
            }

            function gu(t, e, n) {
                return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new je(t, e, n)
            }

            function yu(t, e) {
                return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new gn(t, e).setDynamic(!0)
            }

            function xu(t, e) {
                return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new yn(t, e)
            }

            function bu(t, e) {
                return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new xn(t, e)
            }

            function wu(t, e) {
                return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new bn(t, e)
            }

            function _u(t, e) {
                return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new wn(t, e)
            }

            function Mu(t, e) {
                return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new _n(t, e)
            }

            function Eu(t, e) {
                return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new Mn(t, e)
            }

            function Su(t, e) {
                return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new En(t, e)
            }

            function Tu(t, e) {
                return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new Sn(t, e)
            }

            function Au(t, e) {
                return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new Tn(t, e)
            }

            function Lu(t) {
                console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), _s.call(this, t), this.type = "catmullrom", this.closed = !0
            }

            function Cu(t) {
                console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), _s.call(this, t), this.type = "catmullrom"
            }

            function Ru(t) {
                console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), _s.call(this, t), this.type = "catmullrom"
            }

            function Pu(t) {
                return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ou(t)
            }

            function Ou(t, e) {
                return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new eu(t, e)
            }

            function Iu(t, e) {
                return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new uo(new Ma(t.geometry), new so({
                    color: void 0 !== e ? e : 16777215
                }))
            }

            function Bu(t, e) {
                return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new uo(new yo(t.geometry), new so({
                    color: void 0 !== e ? e : 16777215
                }))
            }

            function Du(t) {
                return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new ss(t)
            }

            function Fu(t) {
                return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new ls(t)
            }
            fs.create = function(t, e) {
                return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(fs.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
            }, Object.assign(Bs.prototype, {
                createPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getPoints(t);
                    return this.createGeometry(e)
                },
                createSpacedPointsGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    var e = this.getSpacedPoints(t);
                    return this.createGeometry(e)
                },
                createGeometry: function(t) {
                    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
                    for (var e = new In, n = 0, r = t.length; n < r; n++) {
                        var i = t[n];
                        e.vertices.push(new je(i.x, i.y, i.z || 0))
                    }
                    return e
                }
            }), Object.assign(Ds.prototype, {
                fromPoints: function(t) {
                    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
                }
            }), Lu.prototype = Object.create(_s.prototype), Cu.prototype = Object.create(_s.prototype), Ru.prototype = Object.create(_s.prototype), Object.assign(Ru.prototype, {
                initFromArray: function() {
                    console.error("THREE.Spline: .initFromArray() has been removed.")
                },
                getControlPointsArray: function() {
                    console.error("THREE.Spline: .getControlPointsArray() has been removed.")
                },
                reparametrizeByArcLength: function() {
                    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
                }
            }), Jc.prototype.setColors = function() {
                console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
            }, Vc.prototype.update = function() {
                console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
            }, Object.assign(lc.prototype, {
                extractUrlBase: function(t) {
                    return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Js.extractUrlBase(t)
                }
            }), Object.assign(tc.prototype, {
                setTexturePath: function(t) {
                    return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
                }
            }), Object.assign(zc.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Object.assign(rn.prototype, {
                center: function(t) {
                    return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
                },
                empty: function() {
                    return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
                },
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                },
                size: function(t) {
                    return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
                }
            }), Gc.prototype.center = function(t) {
                return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
            }, Object.assign(Ge, {
                random16: function() {
                    return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
                },
                nearestPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), Ge.floorPowerOfTwo(t)
                },
                nextPowerOfTwo: function(t) {
                    return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), Ge.ceilPowerOfTwo(t)
                }
            }), Object.assign(Ve.prototype, {
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
                }
            }), Object.assign(Qe.prototype, {
                extractPosition: function(t) {
                    return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
                },
                flattenToArrayOffset: function(t, e) {
                    return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
                },
                getPosition: function() {
                    var t;
                    return function() {
                        return void 0 === t && (t = new je), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
                    }
                }(),
                setRotationFromQuaternion: function(t) {
                    return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
                },
                multiplyToArray: function() {
                    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
                },
                multiplyVector3: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector4: function(t) {
                    return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                multiplyVector3Array: function() {
                    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
                },
                rotateAxis: function(t) {
                    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
                },
                crossVector: function(t) {
                    return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
                },
                translate: function() {
                    console.error("THREE.Matrix4: .translate() has been removed.")
                },
                rotateX: function() {
                    console.error("THREE.Matrix4: .rotateX() has been removed.")
                },
                rotateY: function() {
                    console.error("THREE.Matrix4: .rotateY() has been removed.")
                },
                rotateZ: function() {
                    console.error("THREE.Matrix4: .rotateZ() has been removed.")
                },
                rotateByAxis: function() {
                    console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
                },
                applyToBuffer: function(t) {
                    return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
                },
                applyToVector3Array: function() {
                    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
                },
                makeFrustum: function(t, e, n, r, i, o) {
                    return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, i, o)
                }
            }), Jn.prototype.isIntersectionLine = function(t) {
                return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
            }, Ue.prototype.multiplyVector3 = function(t) {
                return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
            }, Object.assign(an.prototype, {
                isIntersectionBox: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
                },
                isIntersectionPlane: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
                },
                isIntersectionSphere: function(t) {
                    return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
                }
            }), Object.assign(sn.prototype, {
                area: function() {
                    return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
                },
                barycoordFromPoint: function(t, e) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
                },
                midpoint: function(t) {
                    return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
                },
                normal: function(t) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
                },
                plane: function(t) {
                    return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
                }
            }), Object.assign(sn, {
                barycoordFromPoint: function(t, e, n, r, i) {
                    return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), sn.getBarycoord(t, e, n, r, i)
                },
                normal: function(t, e, n, r) {
                    return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), sn.getNormal(t, e, n, r)
                }
            }), Object.assign(Fs.prototype, {
                extractAllPoints: function(t) {
                    return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
                },
                extrude: function(t) {
                    return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new ca(this, t)
                },
                makeGeometry: function(t) {
                    return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ba(this, t)
                }
            }), Object.assign(He.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(je.prototype, {
                setEulerFromRotationMatrix: function() {
                    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
                },
                setEulerFromQuaternion: function() {
                    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
                },
                getPositionFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
                },
                getScaleFromMatrix: function(t) {
                    return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
                },
                getColumnFromMatrix: function(t, e) {
                    return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
                },
                applyProjection: function(t) {
                    return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
                },
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                distanceToManhattan: function(t) {
                    return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(Ye.prototype, {
                fromAttribute: function(t, e, n) {
                    return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
                },
                lengthManhattan: function() {
                    return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
                }
            }), Object.assign(In.prototype, {
                computeTangents: function() {
                    console.error("THREE.Geometry: .computeTangents() has been removed.")
                },
                computeLineDistances: function() {
                    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
                }
            }), Object.assign(en.prototype, {
                getChildByName: function(t) {
                    return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
                },
                renderDepth: function() {
                    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
                },
                translate: function(t, e) {
                    return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
                },
                getWorldRotation: function() {
                    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
                }
            }), Object.defineProperties(en.prototype, {
                eulerOrder: {
                    get: function() {
                        return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
                    },
                    set: function(t) {
                        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
                    }
                },
                useQuaternion: {
                    get: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    },
                    set: function() {
                        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
                    }
                }
            }), Object.defineProperties(ro.prototype, {
                objects: {
                    get: function() {
                        return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
                    }
                }
            }), Object.defineProperty(oo.prototype, "useVertexTexture", {
                get: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                },
                set: function() {
                    console.warn("THREE.Skeleton: useVertexTexture has been removed.")
                }
            }), io.prototype.initBones = function() {
                console.error("THREE.SkinnedMesh: initBones() has been removed.")
            }, Object.defineProperty(fs.prototype, "__arcLengthDivisions", {
                get: function() {
                    return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
                },
                set: function(t) {
                    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
                }
            }), jn.prototype.setLens = function(t, e) {
                console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
            }, Object.defineProperties(ks.prototype, {
                onlyShadow: {
                    set: function() {
                        console.warn("THREE.Light: .onlyShadow has been removed.")
                    }
                },
                shadowCameraFov: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
                    }
                },
                shadowCameraLeft: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
                    }
                },
                shadowCameraRight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
                    }
                },
                shadowCameraTop: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
                    }
                },
                shadowCameraBottom: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
                    }
                },
                shadowCameraNear: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
                    }
                },
                shadowCameraFar: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
                    }
                },
                shadowCameraVisible: {
                    set: function() {
                        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
                    }
                },
                shadowBias: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
                    }
                },
                shadowDarkness: {
                    set: function() {
                        console.warn("THREE.Light: .shadowDarkness has been removed.")
                    }
                },
                shadowMapWidth: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
                    }
                },
                shadowMapHeight: {
                    set: function(t) {
                        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
                    }
                }
            }), Object.defineProperties(gn.prototype, {
                length: {
                    get: function() {
                        return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
                    }
                },
                copyIndicesArray: function() {
                    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
                }
            }), Object.assign(Rn.prototype, {
                addIndex: function(t) {
                    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
                },
                addDrawCall: function(t, e, n) {
                    void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
                },
                clearDrawCalls: function() {
                    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
                },
                computeTangents: function() {
                    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
                },
                computeOffsets: function() {
                    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
                }
            }), Object.defineProperties(Rn.prototype, {
                drawcalls: {
                    get: function() {
                        return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
                    }
                },
                offsets: {
                    get: function() {
                        return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
                    }
                }
            }), Object.assign(ua.prototype, {
                getArrays: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
                },
                addShapeList: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
                },
                addShape: function() {
                    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
                }
            }), Object.defineProperties(Oc.prototype, {
                dynamic: {
                    set: function() {
                        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
                    }
                },
                onUpdate: {
                    value: function() {
                        return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
                    }
                }
            }), Object.defineProperties(mn.prototype, {
                wrapAround: {
                    get: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .wrapAround has been removed.")
                    }
                },
                overdraw: {
                    get: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    },
                    set: function() {
                        console.warn("THREE.Material: .overdraw has been removed.")
                    }
                },
                wrapRGB: {
                    get: function() {
                        return console.warn("THREE.Material: .wrapRGB has been removed."), new un
                    }
                },
                shading: {
                    get: function() {
                        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
                    },
                    set: function(t) {
                        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = t === x
                    }
                }
            }), Object.defineProperties(Da.prototype, {
                metal: {
                    get: function() {
                        return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
                    },
                    set: function() {
                        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
                    }
                }
            }), Object.defineProperties(Hn.prototype, {
                derivatives: {
                    get: function() {
                        return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
                    },
                    set: function(t) {
                        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
                    }
                }
            }), Object.assign(Zi.prototype, {
                clearTarget: function(t, e, n, r) {
                    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
                },
                animate: function(t) {
                    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
                },
                getCurrentRenderTarget: function() {
                    return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
                },
                getMaxAnisotropy: function() {
                    return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
                },
                getPrecision: function() {
                    return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
                },
                resetGLState: function() {
                    return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
                },
                supportsFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
                },
                supportsHalfFloatTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
                },
                supportsStandardDerivatives: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
                },
                supportsCompressedTextureS3TC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
                },
                supportsCompressedTexturePVRTC: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
                },
                supportsBlendMinMax: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
                },
                supportsVertexTextures: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
                },
                supportsInstancedArrays: function() {
                    return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
                },
                enableScissorTest: function(t) {
                    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
                },
                initMaterial: function() {
                    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
                },
                addPrePlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
                },
                addPostPlugin: function() {
                    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
                },
                updateShadowMap: function() {
                    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
                },
                setFaceCulling: function() {
                    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
                },
                allocTextureUnit: function() {
                    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
                },
                setTexture: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
                },
                setTexture2D: function() {
                    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
                },
                setTextureCube: function() {
                    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
                }
            }), Object.defineProperties(Zi.prototype, {
                shadowMapEnabled: {
                    get: function() {
                        return this.shadowMap.enabled
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
                    }
                },
                shadowMapType: {
                    get: function() {
                        return this.shadowMap.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
                    }
                },
                shadowMapCullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Ni.prototype, {
                cullFace: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderReverseSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
                    }
                },
                renderSingleSided: {
                    get: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    },
                    set: function() {
                        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
                    }
                }
            }), Object.defineProperties(Xn.prototype, {
                activeCubeFace: {
                    set: function() {
                        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().")
                    }
                },
                activeMipMapLevel: {
                    set: function() {
                        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().")
                    }
                }
            }), Object.defineProperties(Je.prototype, {
                wrapS: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
                    }
                },
                wrapT: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
                    }
                },
                magFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
                    }
                },
                minFilter: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
                    }
                },
                anisotropy: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
                    }
                },
                offset: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
                    }
                },
                repeat: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
                    }
                },
                format: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
                    }
                },
                type: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
                    }
                },
                generateMipmaps: {
                    get: function() {
                        return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
                    },
                    set: function(t) {
                        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
                    }
                }
            }), Object.defineProperties(Yi.prototype, {
                standing: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .standing has been removed.")
                    }
                },
                userHeight: {
                    set: function() {
                        console.warn("THREE.WebVRManager: .userHeight has been removed.")
                    }
                }
            }), bc.prototype.load = function(t) {
                console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
                var e = this;
                return (new pc).load(t, function(t) {
                    e.setBuffer(t)
                }), this
            }, _c.prototype.getData = function() {
                return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
            }, qn.prototype.updateCubeMap = function(t, e) {
                return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
            };
            var ku = {
                merge: function(t, e, n) {
                    var r;
                    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh && (e.matrixAutoUpdate && e.updateMatrix(), r = e.matrix, e = e.geometry), t.merge(e, r, n)
                },
                center: function(t) {
                    return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
                }
            };

            function Nu() {
                console.error("THREE.CanvasRenderer has been removed")
            }

            function zu() {
                console.error("THREE.JSONLoader has been removed.")
            }
            We.crossOrigin = void 0, We.loadTexture = function(t, e, n, r) {
                console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
                var i = new ds;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(t, n, void 0, r);
                return e && (o.mapping = e), o
            }, We.loadTextureCube = function(t, e, n, r) {
                console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
                var i = new ps;
                i.setCrossOrigin(this.crossOrigin);
                var o = i.load(t, n, void 0, r);
                return e && (o.mapping = e), o
            }, We.loadCompressedTexture = function() {
                console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
            }, We.loadCompressedTextureCube = function() {
                console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
            };
            var Gu = {
                createMultiMaterialObject: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                detach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                },
                attach: function() {
                    console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
                }
            };

            function Hu() {
                console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
            }
        },
        "63d9": function(t, e, n) {
            n("ec30")("Float32", 4, function(t) {
                return function(e, n, r) {
                    return t(this, e, n, r)
                }
            })
        },
        8615: function(t, e, n) {
            var r = n("5ca1"),
                i = n("504c")(!1);
            r(r.S, "Object", {
                values: function(t) {
                    return i(t)
                }
            })
        },
        "9e6a": function(t, e, n) {
            "use strict";
            var r = n("d233"),
                i = Object.prototype.hasOwnProperty,
                o = {
                    allowDots: !1,
                    allowPrototypes: !1,
                    arrayLimit: 20,
                    decoder: r.decode,
                    delimiter: "&",
                    depth: 5,
                    parameterLimit: 1e3,
                    plainObjects: !1,
                    strictNullHandling: !1
                },
                a = function(t, e) {
                    for (var n = {}, r = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t, a = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, s = r.split(e.delimiter, a), c = 0; c < s.length; ++c) {
                        var u, l, h = s[c],
                            p = h.indexOf("]="),
                            d = -1 === p ? h.indexOf("=") : p + 1; - 1 === d ? (u = e.decoder(h, o.decoder), l = e.strictNullHandling ? null : "") : (u = e.decoder(h.slice(0, d), o.decoder), l = e.decoder(h.slice(d + 1), o.decoder)), i.call(n, u) ? n[u] = [].concat(n[u]).concat(l) : n[u] = l
                    }
                    return n
                },
                s = function(t, e, n) {
                    if (t) {
                        var r = n.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
                            o = /(\[[^[\]]*])/g,
                            a = /(\[[^[\]]*])/.exec(r),
                            s = a ? r.slice(0, a.index) : r,
                            c = [];
                        if (s) {
                            if (!n.plainObjects && i.call(Object.prototype, s) && !n.allowPrototypes) return;
                            c.push(s)
                        }
                        for (var u = 0; null !== (a = o.exec(r)) && u < n.depth;) {
                            if (u += 1, !n.plainObjects && i.call(Object.prototype, a[1].slice(1, -1)) && !n.allowPrototypes) return;
                            c.push(a[1])
                        }
                        return a && c.push("[" + r.slice(a.index) + "]"),
                            function(t, e, n) {
                                for (var r = e, i = t.length - 1; i >= 0; --i) {
                                    var o, a = t[i];
                                    if ("[]" === a) o = (o = []).concat(r);
                                    else {
                                        o = n.plainObjects ? Object.create(null) : {};
                                        var s = "[" === a.charAt(0) && "]" === a.charAt(a.length - 1) ? a.slice(1, -1) : a,
                                            c = parseInt(s, 10);
                                        !isNaN(c) && a !== s && String(c) === s && c >= 0 && n.parseArrays && c <= n.arrayLimit ? (o = [])[c] = r : o[s] = r
                                    }
                                    r = o
                                }
                                return r
                            }(c, e, n)
                    }
                };
            t.exports = function(t, e) {
                var n = e ? r.assign({}, e) : {};
                if (null !== n.decoder && void 0 !== n.decoder && "function" != typeof n.decoder) throw new TypeError("Decoder has to be a function.");
                if (n.ignoreQueryPrefix = !0 === n.ignoreQueryPrefix, n.delimiter = "string" == typeof n.delimiter || r.isRegExp(n.delimiter) ? n.delimiter : o.delimiter, n.depth = "number" == typeof n.depth ? n.depth : o.depth, n.arrayLimit = "number" == typeof n.arrayLimit ? n.arrayLimit : o.arrayLimit, n.parseArrays = !1 !== n.parseArrays, n.decoder = "function" == typeof n.decoder ? n.decoder : o.decoder, n.allowDots = "boolean" == typeof n.allowDots ? n.allowDots : o.allowDots, n.plainObjects = "boolean" == typeof n.plainObjects ? n.plainObjects : o.plainObjects, n.allowPrototypes = "boolean" == typeof n.allowPrototypes ? n.allowPrototypes : o.allowPrototypes, n.parameterLimit = "number" == typeof n.parameterLimit ? n.parameterLimit : o.parameterLimit, n.strictNullHandling = "boolean" == typeof n.strictNullHandling ? n.strictNullHandling : o.strictNullHandling, "" === t || null == t) return n.plainObjects ? Object.create(null) : {};
                for (var i = "string" == typeof t ? a(t, n) : t, c = n.plainObjects ? Object.create(null) : {}, u = Object.keys(i), l = 0; l < u.length; ++l) {
                    var h = u[l],
                        p = s(h, i[h], n);
                    c = r.merge(c, p, n)
                }
                return r.compact(c)
            }
        },
        abc8: function(t, e, n) {
            "use strict";
            const r = (t, e) => {
                if ("string" != typeof t && !Array.isArray(t)) throw new TypeError("Expected the input to be `string | string[]`");
                e = Object.assign({
                    pascalCase: !1
                }, e);
                return 0 === (t = Array.isArray(t) ? t.map(t => t.trim()).filter(t => t.length).join("-") : t.trim()).length ? "" : 1 === t.length ? e.pascalCase ? t.toUpperCase() : t.toLowerCase() : (t !== t.toLowerCase() && (t = (t => {
                    let e = !1,
                        n = !1,
                        r = !1;
                    for (let i = 0; i < t.length; i++) {
                        const o = t[i];
                        e && /[a-zA-Z]/.test(o) && o.toUpperCase() === o ? (t = t.slice(0, i) + "-" + t.slice(i), e = !1, r = n, n = !0, i++) : n && r && /[a-zA-Z]/.test(o) && o.toLowerCase() === o ? (t = t.slice(0, i - 1) + "-" + t.slice(i - 1), r = n, n = !1, e = !0) : (e = o.toLowerCase() === o && o.toUpperCase() !== o, r = n, n = o.toUpperCase() === o && o.toLowerCase() !== o)
                    }
                    return t
                })(t)), (t => e.pascalCase ? t.charAt(0).toUpperCase() + t.slice(1) : t)(t = t.replace(/^[_.\- ]+/, "").toLowerCase().replace(/[_.\- ]+(\w|$)/g, (t, e) => e.toUpperCase()).replace(/\d+(\w|$)/g, t => t.toUpperCase())))
            };
            t.exports = r, t.exports.default = r
        },
        b313: function(t, e, n) {
            "use strict";
            var r = String.prototype.replace,
                i = /%20/g;
            t.exports = {
                default: "RFC3986",
                formatters: {
                    RFC1738: function(t) {
                        return r.call(t, i, "+")
                    },
                    RFC3986: function(t) {
                        return t
                    }
                },
                RFC1738: "RFC1738",
                RFC3986: "RFC3986"
            }
        },
        b5ec: function(t, e, n) {
            "use strict";
            n("ac6a");
            var r = n("d225"),
                i = n("b0b4");

            function o(t, e, n) {
                return (1 - n) * t + n * e
            }

            function a(t) {
                return t
            }
            var s = function() {
                function t() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    Object(r.a)(this, t), Object.assign(this, {
                        from: 0,
                        to: 1,
                        delay: 0,
                        duration: 300,
                        ease: a,
                        onStart: null,
                        onUpdate: null,
                        onEnd: null,
                        loop: !1,
                        autoReverese: !1,
                        _startTime: 0,
                        _endTime: 0,
                        _stopped: !1,
                        _started: !1,
                        chainedTweens: []
                    }, e)
                }
                return Object(i.a)(t, [{
                    key: "start",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
                        this._startTime = t + this.delay + performance.now(), this._stopped = !1, this._rAF()
                    }
                }, {
                    key: "stop",
                    value: function() {
                        this._stopped = !0
                    }
                }, {
                    key: "update",
                    value: function() {
                        var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : performance.now();
                        if (this._stopped);
                        else if (t < this._startTime);
                        else if (t > this._startTime + this.duration) {
                            this._stopped = !0, this._started = !1;
                            var e = 1,
                                n = o(this.from, this.to, this.ease(e));
                            if (this.onUpdate && this.onUpdate(n, e, this), this.onStopped && this.onStopped(this), this.chainedTweens.forEach(function(t) {
                                    t.start()
                                }), this.onEnd && this.onEnd(n, this), this.autoReverese) {
                                var r = this.from;
                                this.from = this.to, this.to = r
                            }
                            this.loop && this.start()
                        } else {
                            this._started || (this._started = !0, this.onStart && this.onStart(this));
                            var i = t - this._startTime;
                            e = i / this.duration, n = o(this.from, this.to, this.ease(e)), this.onUpdate && this.onUpdate(n, e, this)
                        }
                        this._stopped || this._rAF()
                    }
                }, {
                    key: "chain",
                    value: function(t) {
                        return this.chainedTweens.push(t), this
                    }
                }, {
                    key: "_rAF",
                    value: function() {
                        window.requestAnimationFrame(this.update.bind(this))
                    }
                }]), t
            }();
            e.a = s
        },
        ba92: function(t, e, n) {
            "use strict";
            var r = n("4bf8"),
                i = n("77f1"),
                o = n("9def");
            t.exports = [].copyWithin || function(t, e) {
                var n = r(this),
                    a = o(n.length),
                    s = i(t, a),
                    c = i(e, a),
                    u = arguments.length > 2 ? arguments[2] : void 0,
                    l = Math.min((void 0 === u ? a : i(u, a)) - c, a - s),
                    h = 1;
                for (c < s && s < c + l && (h = -1, c += l - 1, s += l - 1); l-- > 0;) c in n ? n[s] = n[c] : delete n[s], s += h, c += h;
                return n
            }
        },
        d233: function(t, e, n) {
            "use strict";
            var r = Object.prototype.hasOwnProperty,
                i = function() {
                    for (var t = [], e = 0; e < 256; ++e) t.push("%" + ((e < 16 ? "0" : "") + e.toString(16)).toUpperCase());
                    return t
                }(),
                o = function(t, e) {
                    for (var n = e && e.plainObjects ? Object.create(null) : {}, r = 0; r < t.length; ++r) void 0 !== t[r] && (n[r] = t[r]);
                    return n
                };
            t.exports = {
                arrayToObject: o,
                assign: function(t, e) {
                    return Object.keys(e).reduce(function(t, n) {
                        return t[n] = e[n], t
                    }, t)
                },
                compact: function(t) {
                    for (var e = [{
                            obj: {
                                o: t
                            },
                            prop: "o"
                        }], n = [], r = 0; r < e.length; ++r)
                        for (var i = e[r], o = i.obj[i.prop], a = Object.keys(o), s = 0; s < a.length; ++s) {
                            var c = a[s],
                                u = o[c];
                            "object" == typeof u && null !== u && -1 === n.indexOf(u) && (e.push({
                                obj: o,
                                prop: c
                            }), n.push(u))
                        }
                    return function(t) {
                        for (var e; t.length;) {
                            var n = t.pop();
                            if (e = n.obj[n.prop], Array.isArray(e)) {
                                for (var r = [], i = 0; i < e.length; ++i) void 0 !== e[i] && r.push(e[i]);
                                n.obj[n.prop] = r
                            }
                        }
                        return e
                    }(e)
                },
                decode: function(t) {
                    try {
                        return decodeURIComponent(t.replace(/\+/g, " "))
                    } catch (e) {
                        return t
                    }
                },
                encode: function(t) {
                    if (0 === t.length) return t;
                    for (var e = "string" == typeof t ? t : String(t), n = "", r = 0; r < e.length; ++r) {
                        var o = e.charCodeAt(r);
                        45 === o || 46 === o || 95 === o || 126 === o || o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122 ? n += e.charAt(r) : o < 128 ? n += i[o] : o < 2048 ? n += i[192 | o >> 6] + i[128 | 63 & o] : o < 55296 || o >= 57344 ? n += i[224 | o >> 12] + i[128 | o >> 6 & 63] + i[128 | 63 & o] : (r += 1, o = 65536 + ((1023 & o) << 10 | 1023 & e.charCodeAt(r)), n += i[240 | o >> 18] + i[128 | o >> 12 & 63] + i[128 | o >> 6 & 63] + i[128 | 63 & o])
                    }
                    return n
                },
                isBuffer: function(t) {
                    return null != t && !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
                },
                isRegExp: function(t) {
                    return "[object RegExp]" === Object.prototype.toString.call(t)
                },
                merge: function t(e, n, i) {
                    if (!n) return e;
                    if ("object" != typeof n) {
                        if (Array.isArray(e)) e.push(n);
                        else {
                            if ("object" != typeof e) return [e, n];
                            (i.plainObjects || i.allowPrototypes || !r.call(Object.prototype, n)) && (e[n] = !0)
                        }
                        return e
                    }
                    if ("object" != typeof e) return [e].concat(n);
                    var a = e;
                    return Array.isArray(e) && !Array.isArray(n) && (a = o(e, i)), Array.isArray(e) && Array.isArray(n) ? (n.forEach(function(n, o) {
                        r.call(e, o) ? e[o] && "object" == typeof e[o] ? e[o] = t(e[o], n, i) : e.push(n) : e[o] = n
                    }), e) : Object.keys(n).reduce(function(e, o) {
                        var a = n[o];
                        return r.call(e, o) ? e[o] = t(e[o], a, i) : e[o] = a, e
                    }, a)
                }
            }
        },
        d9f3: function(t, e, n) {
            "use strict";
            n.d(e, "a", function() {
                return o
            }), n.d(e, "b", function() {
                return a
            }), n.d(e, "c", function() {
                return s
            }), n("ac6a"), n("34ef");
            var r = n("75fc"),
                i = n("5a89");

            function o() {
                for (var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [new i.Color("#fff"), new i.Color("#000")], e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : i.LinearFilter, o = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : i.MirroredRepeatWrapping, a = [], s = 0; s < t.length; s++) {
                    var c = t[s];
                    a.push.apply(a, Object(r.a)(c.toArray().map(function(t) {
                        return 255 * t
                    })))
                }
                var u = new i.DataTexture(new Uint8Array(a), e, a.length / 3 / e, i.RGBFormat);
                return u.magFilter = u.minFilter = n, u.needsUpdate = !0, u.wrapS = u.wrapT = o, u
            }

            function a() {
                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : new Uint8Array(16),
                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1,
                    n = new i.DataTexture(t, e, t.length / 3 / e, i.RGBFormat);
                return n.magFilter = n.minFilter = i.LinearFilter, n.needsUpdate = !0, n
            }

            function s(t, e) {
                for (var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, r = 0, i = 0; r < e.length; r++) e[r].toArray().forEach(function(e) {
                    t.image.data[i++] = 255 * e
                });
                n && (t.magFilter = t.minFilter = n), t.needsUpdate = !0
            }
        },
        ec30: function(t, e, n) {
            "use strict";
            if (n("9e1e")) {
                var r = n("2d00"),
                    i = n("7726"),
                    o = n("79e5"),
                    a = n("5ca1"),
                    s = n("0f88"),
                    c = n("ed0b"),
                    u = n("9b43"),
                    l = n("f605"),
                    h = n("4630"),
                    p = n("32e9"),
                    d = n("dcbc"),
                    f = n("4588"),
                    m = n("9def"),
                    v = n("09fa"),
                    g = n("77f1"),
                    y = n("6a99"),
                    x = n("69a8"),
                    b = n("23c6"),
                    w = n("d3f4"),
                    _ = n("4bf8"),
                    M = n("33a4"),
                    E = n("2aeb"),
                    S = n("38fd"),
                    T = n("9093").f,
                    A = n("27ee"),
                    L = n("ca5a"),
                    C = n("2b4c"),
                    R = n("0a49"),
                    P = n("c366"),
                    O = n("ebd6"),
                    I = n("cadf"),
                    B = n("84f2"),
                    D = n("5cc5"),
                    F = n("7a56"),
                    k = n("36bd"),
                    N = n("ba92"),
                    z = n("86cc"),
                    G = n("11e9"),
                    H = z.f,
                    U = G.f,
                    j = i.RangeError,
                    V = i.TypeError,
                    W = i.Uint8Array,
                    q = "ArrayBuffer",
                    X = "Shared" + q,
                    Y = "BYTES_PER_ELEMENT",
                    J = "prototype",
                    Z = Array[J],
                    Q = c.ArrayBuffer,
                    K = c.DataView,
                    $ = R(0),
                    tt = R(2),
                    et = R(3),
                    nt = R(4),
                    rt = R(5),
                    it = R(6),
                    ot = P(!0),
                    at = P(!1),
                    st = I.values,
                    ct = I.keys,
                    ut = I.entries,
                    lt = Z.lastIndexOf,
                    ht = Z.reduce,
                    pt = Z.reduceRight,
                    dt = Z.join,
                    ft = Z.sort,
                    mt = Z.slice,
                    vt = Z.toString,
                    gt = Z.toLocaleString,
                    yt = C("iterator"),
                    xt = C("toStringTag"),
                    bt = L("typed_constructor"),
                    wt = L("def_constructor"),
                    _t = s.CONSTR,
                    Mt = s.TYPED,
                    Et = s.VIEW,
                    St = "Wrong length!",
                    Tt = R(1, function(t, e) {
                        return Pt(O(t, t[wt]), e)
                    }),
                    At = o(function() {
                        return 1 === new W(new Uint16Array([1]).buffer)[0]
                    }),
                    Lt = !!W && !!W[J].set && o(function() {
                        new W(1).set({})
                    }),
                    Ct = function(t, e) {
                        var n = f(t);
                        if (n < 0 || n % e) throw j("Wrong offset!");
                        return n
                    },
                    Rt = function(t) {
                        if (w(t) && Mt in t) return t;
                        throw V(t + " is not a typed array!")
                    },
                    Pt = function(t, e) {
                        if (!(w(t) && bt in t)) throw V("It is not a typed array constructor!");
                        return new t(e)
                    },
                    Ot = function(t, e) {
                        return It(O(t, t[wt]), e)
                    },
                    It = function(t, e) {
                        for (var n = 0, r = e.length, i = Pt(t, r); r > n;) i[n] = e[n++];
                        return i
                    },
                    Bt = function(t, e, n) {
                        H(t, e, {
                            get: function() {
                                return this._d[n]
                            }
                        })
                    },
                    Dt = function(t) {
                        var e, n, r, i, o, a, s = _(t),
                            c = arguments.length,
                            l = c > 1 ? arguments[1] : void 0,
                            h = void 0 !== l,
                            p = A(s);
                        if (null != p && !M(p)) {
                            for (a = p.call(s), r = [], e = 0; !(o = a.next()).done; e++) r.push(o.value);
                            s = r
                        }
                        for (h && c > 2 && (l = u(l, arguments[2], 2)), e = 0, n = m(s.length), i = Pt(this, n); n > e; e++) i[e] = h ? l(s[e], e) : s[e];
                        return i
                    },
                    Ft = function() {
                        for (var t = 0, e = arguments.length, n = Pt(this, e); e > t;) n[t] = arguments[t++];
                        return n
                    },
                    kt = !!W && o(function() {
                        gt.call(new W(1))
                    }),
                    Nt = function() {
                        return gt.apply(kt ? mt.call(Rt(this)) : Rt(this), arguments)
                    },
                    zt = {
                        copyWithin: function(t, e) {
                            return N.call(Rt(this), t, e, arguments.length > 2 ? arguments[2] : void 0)
                        },
                        every: function(t) {
                            return nt(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        fill: function(t) {
                            return k.apply(Rt(this), arguments)
                        },
                        filter: function(t) {
                            return Ot(this, tt(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0))
                        },
                        find: function(t) {
                            return rt(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        findIndex: function(t) {
                            return it(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        forEach: function(t) {
                            $(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        indexOf: function(t) {
                            return at(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        includes: function(t) {
                            return ot(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        join: function(t) {
                            return dt.apply(Rt(this), arguments)
                        },
                        lastIndexOf: function(t) {
                            return lt.apply(Rt(this), arguments)
                        },
                        map: function(t) {
                            return Tt(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        reduce: function(t) {
                            return ht.apply(Rt(this), arguments)
                        },
                        reduceRight: function(t) {
                            return pt.apply(Rt(this), arguments)
                        },
                        reverse: function() {
                            for (var t, e = this, n = Rt(e).length, r = Math.floor(n / 2), i = 0; i < r;) t = e[i], e[i++] = e[--n], e[n] = t;
                            return e
                        },
                        some: function(t) {
                            return et(Rt(this), t, arguments.length > 1 ? arguments[1] : void 0)
                        },
                        sort: function(t) {
                            return ft.call(Rt(this), t)
                        },
                        subarray: function(t, e) {
                            var n = Rt(this),
                                r = n.length,
                                i = g(t, r);
                            return new(O(n, n[wt]))(n.buffer, n.byteOffset + i * n.BYTES_PER_ELEMENT, m((void 0 === e ? r : g(e, r)) - i))
                        }
                    },
                    Gt = function(t, e) {
                        return Ot(this, mt.call(Rt(this), t, e))
                    },
                    Ht = function(t) {
                        Rt(this);
                        var e = Ct(arguments[1], 1),
                            n = this.length,
                            r = _(t),
                            i = m(r.length),
                            o = 0;
                        if (i + e > n) throw j(St);
                        for (; o < i;) this[e + o] = r[o++]
                    },
                    Ut = {
                        entries: function() {
                            return ut.call(Rt(this))
                        },
                        keys: function() {
                            return ct.call(Rt(this))
                        },
                        values: function() {
                            return st.call(Rt(this))
                        }
                    },
                    jt = function(t, e) {
                        return w(t) && t[Mt] && "symbol" != typeof e && e in t && String(+e) == String(e)
                    },
                    Vt = function(t, e) {
                        return jt(t, e = y(e, !0)) ? h(2, t[e]) : U(t, e)
                    },
                    Wt = function(t, e, n) {
                        return !(jt(t, e = y(e, !0)) && w(n) && x(n, "value")) || x(n, "get") || x(n, "set") || n.configurable || x(n, "writable") && !n.writable || x(n, "enumerable") && !n.enumerable ? H(t, e, n) : (t[e] = n.value, t)
                    };
                _t || (G.f = Vt, z.f = Wt), a(a.S + a.F * !_t, "Object", {
                    getOwnPropertyDescriptor: Vt,
                    defineProperty: Wt
                }), o(function() {
                    vt.call({})
                }) && (vt = gt = function() {
                    return dt.call(this)
                });
                var qt = d({}, zt);
                d(qt, Ut), p(qt, yt, Ut.values), d(qt, {
                    slice: Gt,
                    set: Ht,
                    constructor: function() {},
                    toString: vt,
                    toLocaleString: Nt
                }), Bt(qt, "buffer", "b"), Bt(qt, "byteOffset", "o"), Bt(qt, "byteLength", "l"), Bt(qt, "length", "e"), H(qt, xt, {
                    get: function() {
                        return this[Mt]
                    }
                }), t.exports = function(t, e, n, c) {
                    var u = t + ((c = !!c) ? "Clamped" : "") + "Array",
                        h = "get" + t,
                        d = "set" + t,
                        f = i[u],
                        g = f || {},
                        y = f && S(f),
                        x = !f || !s.ABV,
                        _ = {},
                        M = f && f[J],
                        A = function(t, n) {
                            var r = t._d;
                            return r.v[h](n * e + r.o, At)
                        },
                        L = function(t, n, r) {
                            var i = t._d;
                            c && (r = (r = Math.round(r)) < 0 ? 0 : r > 255 ? 255 : 255 & r), i.v[d](n * e + i.o, r, At)
                        },
                        C = function(t, e) {
                            H(t, e, {
                                get: function() {
                                    return A(this, e)
                                },
                                set: function(t) {
                                    return L(this, e, t)
                                },
                                enumerable: !0
                            })
                        };
                    x ? (f = n(function(t, n, r, i) {
                        l(t, f, u, "_d");
                        var o, a, s, c, h = 0,
                            d = 0;
                        if (w(n)) {
                            if (!(n instanceof Q || (c = b(n)) == q || c == X)) return Mt in n ? It(f, n) : Dt.call(f, n);
                            o = n, d = Ct(r, e);
                            var g = n.byteLength;
                            if (void 0 === i) {
                                if (g % e) throw j(St);
                                if ((a = g - d) < 0) throw j(St)
                            } else if ((a = m(i) * e) + d > g) throw j(St);
                            s = a / e
                        } else s = v(n), o = new Q(a = s * e);
                        for (p(t, "_d", {
                                b: o,
                                o: d,
                                l: a,
                                e: s,
                                v: new K(o)
                            }); h < s;) C(t, h++)
                    }), M = f[J] = E(qt), p(M, "constructor", f)) : o(function() {
                        f(1)
                    }) && o(function() {
                        new f(-1)
                    }) && D(function(t) {
                        new f, new f(null), new f(1.5), new f(t)
                    }, !0) || (f = n(function(t, n, r, i) {
                        var o;
                        return l(t, f, u), w(n) ? n instanceof Q || (o = b(n)) == q || o == X ? void 0 !== i ? new g(n, Ct(r, e), i) : void 0 !== r ? new g(n, Ct(r, e)) : new g(n) : Mt in n ? It(f, n) : Dt.call(f, n) : new g(v(n))
                    }), $(y !== Function.prototype ? T(g).concat(T(y)) : T(g), function(t) {
                        t in f || p(f, t, g[t])
                    }), f[J] = M, r || (M.constructor = f));
                    var R = M[yt],
                        P = !!R && ("values" == R.name || null == R.name),
                        O = Ut.values;
                    p(f, bt, !0), p(M, Mt, u), p(M, Et, !0), p(M, wt, f), (c ? new f(1)[xt] == u : xt in M) || H(M, xt, {
                        get: function() {
                            return u
                        }
                    }), _[u] = f, a(a.G + a.W + a.F * (f != g), _), a(a.S, u, {
                        BYTES_PER_ELEMENT: e
                    }), a(a.S + a.F * o(function() {
                        g.of.call(f, 1)
                    }), u, {
                        from: Dt,
                        of: Ft
                    }), Y in M || p(M, Y, e), a(a.P, u, zt), F(u), a(a.P + a.F * Lt, u, {
                        set: Ht
                    }), a(a.P + a.F * !P, u, Ut), r || M.toString == vt || (M.toString = vt), a(a.P + a.F * o(function() {
                        new f(1).slice()
                    }), u, {
                        slice: Gt
                    }), a(a.P + a.F * (o(function() {
                        return [1, 2].toLocaleString() != new f([1, 2]).toLocaleString()
                    }) || !o(function() {
                        M.toLocaleString.call([1, 2])
                    })), u, {
                        toLocaleString: Nt
                    }), B[u] = P ? R : O, r || P || p(M, yt, O)
                }
            } else t.exports = function() {}
        },
        ed0b: function(t, e, n) {
            "use strict";
            var r = n("7726"),
                i = n("9e1e"),
                o = n("2d00"),
                a = n("0f88"),
                s = n("32e9"),
                c = n("dcbc"),
                u = n("79e5"),
                l = n("f605"),
                h = n("4588"),
                p = n("9def"),
                d = n("09fa"),
                f = n("9093").f,
                m = n("86cc").f,
                v = n("36bd"),
                g = n("7f20"),
                y = "ArrayBuffer",
                x = "DataView",
                b = "prototype",
                w = "Wrong index!",
                _ = r[y],
                M = r[x],
                E = r.Math,
                S = r.RangeError,
                T = r.Infinity,
                A = _,
                L = E.abs,
                C = E.pow,
                R = E.floor,
                P = E.log,
                O = E.LN2,
                I = "buffer",
                B = "byteLength",
                D = "byteOffset",
                F = i ? "_b" : I,
                k = i ? "_l" : B,
                N = i ? "_o" : D;

            function z(t, e, n) {
                var r, i, o, a = new Array(n),
                    s = 8 * n - e - 1,
                    c = (1 << s) - 1,
                    u = c >> 1,
                    l = 23 === e ? C(2, -24) - C(2, -77) : 0,
                    h = 0,
                    p = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
                for ((t = L(t)) != t || t === T ? (i = t != t ? 1 : 0, r = c) : (r = R(P(t) / O), t * (o = C(2, -r)) < 1 && (r--, o *= 2), (t += r + u >= 1 ? l / o : l * C(2, 1 - u)) * o >= 2 && (r++, o /= 2), r + u >= c ? (i = 0, r = c) : r + u >= 1 ? (i = (t * o - 1) * C(2, e), r += u) : (i = t * C(2, u - 1) * C(2, e), r = 0)); e >= 8; a[h++] = 255 & i, i /= 256, e -= 8);
                for (r = r << e | i, s += e; s > 0; a[h++] = 255 & r, r /= 256, s -= 8);
                return a[--h] |= 128 * p, a
            }

            function G(t, e, n) {
                var r, i = 8 * n - e - 1,
                    o = (1 << i) - 1,
                    a = o >> 1,
                    s = i - 7,
                    c = n - 1,
                    u = t[c--],
                    l = 127 & u;
                for (u >>= 7; s > 0; l = 256 * l + t[c], c--, s -= 8);
                for (r = l & (1 << -s) - 1, l >>= -s, s += e; s > 0; r = 256 * r + t[c], c--, s -= 8);
                if (0 === l) l = 1 - a;
                else {
                    if (l === o) return r ? NaN : u ? -T : T;
                    r += C(2, e), l -= a
                }
                return (u ? -1 : 1) * r * C(2, l - e)
            }

            function H(t) {
                return t[3] << 24 | t[2] << 16 | t[1] << 8 | t[0]
            }

            function U(t) {
                return [255 & t]
            }

            function j(t) {
                return [255 & t, t >> 8 & 255]
            }

            function V(t) {
                return [255 & t, t >> 8 & 255, t >> 16 & 255, t >> 24 & 255]
            }

            function W(t) {
                return z(t, 52, 8)
            }

            function q(t) {
                return z(t, 23, 4)
            }

            function X(t, e, n) {
                m(t[b], e, {
                    get: function() {
                        return this[n]
                    }
                })
            }

            function Y(t, e, n, r) {
                var i = d(+n);
                if (i + e > t[k]) throw S(w);
                var o = t[F]._b,
                    a = i + t[N],
                    s = o.slice(a, a + e);
                return r ? s : s.reverse()
            }

            function J(t, e, n, r, i, o) {
                var a = d(+n);
                if (a + e > t[k]) throw S(w);
                for (var s = t[F]._b, c = a + t[N], u = r(+i), l = 0; l < e; l++) s[c + l] = u[o ? l : e - l - 1]
            }
            if (a.ABV) {
                if (!u(function() {
                        _(1)
                    }) || !u(function() {
                        new _(-1)
                    }) || u(function() {
                        return new _, new _(1.5), new _(NaN), _.name != y
                    })) {
                    for (var Z, Q = (_ = function(t) {
                            return l(this, _), new A(d(t))
                        })[b] = A[b], K = f(A), $ = 0; K.length > $;)(Z = K[$++]) in _ || s(_, Z, A[Z]);
                    o || (Q.constructor = _)
                }
                var tt = new M(new _(2)),
                    et = M[b].setInt8;
                tt.setInt8(0, 2147483648), tt.setInt8(1, 2147483649), !tt.getInt8(0) && tt.getInt8(1) || c(M[b], {
                    setInt8: function(t, e) {
                        et.call(this, t, e << 24 >> 24)
                    },
                    setUint8: function(t, e) {
                        et.call(this, t, e << 24 >> 24)
                    }
                }, !0)
            } else _ = function(t) {
                l(this, _, y);
                var e = d(t);
                this._b = v.call(new Array(e), 0), this[k] = e
            }, M = function(t, e, n) {
                l(this, M, x), l(t, _, x);
                var r = t[k],
                    i = h(e);
                if (i < 0 || i > r) throw S("Wrong offset!");
                if (i + (n = void 0 === n ? r - i : p(n)) > r) throw S("Wrong length!");
                this[F] = t, this[N] = i, this[k] = n
            }, i && (X(_, B, "_l"), X(M, I, "_b"), X(M, B, "_l"), X(M, D, "_o")), c(M[b], {
                getInt8: function(t) {
                    return Y(this, 1, t)[0] << 24 >> 24
                },
                getUint8: function(t) {
                    return Y(this, 1, t)[0]
                },
                getInt16: function(t) {
                    var e = Y(this, 2, t, arguments[1]);
                    return (e[1] << 8 | e[0]) << 16 >> 16
                },
                getUint16: function(t) {
                    var e = Y(this, 2, t, arguments[1]);
                    return e[1] << 8 | e[0]
                },
                getInt32: function(t) {
                    return H(Y(this, 4, t, arguments[1]))
                },
                getUint32: function(t) {
                    return H(Y(this, 4, t, arguments[1])) >>> 0
                },
                getFloat32: function(t) {
                    return G(Y(this, 4, t, arguments[1]), 23, 4)
                },
                getFloat64: function(t) {
                    return G(Y(this, 8, t, arguments[1]), 52, 8)
                },
                setInt8: function(t, e) {
                    J(this, 1, t, U, e)
                },
                setUint8: function(t, e) {
                    J(this, 1, t, U, e)
                },
                setInt16: function(t, e) {
                    J(this, 2, t, j, e, arguments[2])
                },
                setUint16: function(t, e) {
                    J(this, 2, t, j, e, arguments[2])
                },
                setInt32: function(t, e) {
                    J(this, 4, t, V, e, arguments[2])
                },
                setUint32: function(t, e) {
                    J(this, 4, t, V, e, arguments[2])
                },
                setFloat32: function(t, e) {
                    J(this, 4, t, q, e, arguments[2])
                },
                setFloat64: function(t, e) {
                    J(this, 8, t, W, e, arguments[2])
                }
            });
            g(_, y), g(M, x), s(M[b], a.VIEW, !0), e[y] = _, e[x] = M
        },
        fa0b: function(t, e, n) {
            "use strict";
            n("a481"), n("3b2b");
            var r = "\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n  // First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n  // Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n  // Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n  //Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n",
                i = "\n\n".concat(r, "\n\nvec3 snoiseVec3( vec3 x ){\n\n  float s  = snoise(vec3( x ));\n  float s1 = snoise(vec3( x.y - 19.1 , x.z + 33.4 , x.x + 47.2 ));\n  float s2 = snoise(vec3( x.z + 74.2 , x.x - 124.5 , x.y + 99.4 ));\n  vec3 c = vec3( s , s1 , s2 );\n  return c;\n\n}\nvec3 curlNoise( vec3 p ){\n\n  const float e = .1;\n  vec3 dx = vec3( e   , 0.0 , 0.0 );\n  vec3 dy = vec3( 0.0 , e   , 0.0 );\n  vec3 dz = vec3( 0.0 , 0.0 , e   );\n\n  vec3 p_x0 = snoiseVec3( p - dx );\n  vec3 p_x1 = snoiseVec3( p + dx );\n  vec3 p_y0 = snoiseVec3( p - dy );\n  vec3 p_y1 = snoiseVec3( p + dy );\n  vec3 p_z0 = snoiseVec3( p - dz );\n  vec3 p_z1 = snoiseVec3( p + dz );\n\n  float x = p_y1.z - p_y0.z - p_z1.y + p_z0.y;\n  float y = p_z1.x - p_z0.x - p_x1.z + p_x0.z;\n  float z = p_x1.y - p_x0.y - p_y1.x + p_y0.x;\n\n  const float divisor = 1.0 / ( 2.0 * e );\n  return normalize( vec3( x , y , z ) * divisor );\n\n}"),
                o = Math.PI,
                a = {
                    Linear: "float Linear(float k)\n      {\n        return clamp( k, 0.0, 1.0 );\n      }",
                    Smooth: "float Smooth( float x )\n      {\n        return x*x*(3.0 - 2.0*x);\n      }",
                    Smoother: "float Smoother(float x)\n      {\n        return x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n      }",
                    Zero: "float Zero(float k)\n      {\n        return 0.0;\n      }",
                    One: "float One(float k)\n      {\n        return 1.0;\n      }",
                    Quadratic: {
                        In: "float QuadraticIn( float k )\n          {\n            return k * k;\n          }",
                        Out: "float QuadraticOut(float  k )\n          {\n            return k * ( 2.0 - k );\n          }",
                        InOut: "float QuadraticInOut(float k )\n          {\n            if ( ( k *= 2.0 ) < 1.0 ){ return 0.5 * k * k;}\n            --k;\n            return - 0.5 * ( k * ( k - 2.0 ) - 1.0 );\n          }"
                    },
                    Cubic: {
                        In: "float CubicIn(float k )\n          {\n            return k * k * k;\n          }",
                        Out: "float CubicOut(float k )\n          {\n            --k;\n            return k * k * k + 1.0;\n          }",
                        InOut: "float CubicInOut(float k )\n          {\n            if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k * k;\n            k-=2.0;\n            return 0.5 * ( k * k * k + 2.0 );\n          }"
                    },
                    Quartic: {
                        In: "float QuarticIn(float k )\n          {\n            return k * k * k * k;\n          }",
                        Out: "float QuarticOut(float k )\n          {\n            --k;\n            return 1.0 - ( k * k * k * k );\n          }",
                        InOut: "float QuarticInOut(float k )\n          {\n            if ( ( k *= 2.0 ) < 1.0) return 0.5 * k * k * k * k;\n            k -= 2.0;\n            return - 0.5 * ( k * k * k * k - 2.0 );\n          }"
                    },
                    Quintic: {
                        In: "float QuinticIn(float k )\n          {\n            return k * k * k * k * k;\n          }",
                        Out: "float QuinticOut(float k )\n          {\n            --k;\n            return k * k * k * k * k + 1.0;\n          }",
                        InOut: "float QuinticInOut(float k )\n          {\n            if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * k * k * k * k * k;\n            k -= 2.0;\n            return 0.5 * ( k * k * k * k * k + 2.0 );\n          }"
                    },
                    Sinusoidal: {
                        In: "float SinusoidalIn(float k )\n          {\n            return 1.0 - cos( k * ".concat(o, " / 2.0 );\n          }"),
                        Out: "float SinusoidalOut(float k )\n          {\n            return sin( k * ".concat(o, " / 2.0 );\n          }"),
                        InOut: "float SinusoidalInOut(float k )\n          {\n            return 0.5 * ( 1.0 - cos( ".concat(o, " * k ) );\n          }")
                    },
                    Exponential: {
                        In: "float ExponentialIn(float k )\n          {\n            return k == 0.0 ? 0.0 : pow( 1024, k - 1.0 );\n          }",
                        Out: "float ExponentialOut(float k )\n          {\n            return k == 1.0 ? 1.0 : 1.0 - pow( 2.0, - 10.0 * k );\n          }",
                        InOut: "float ExponentialInOut(float k )\n          {\n            if ( k == 0.0 ) return 0.0;\n            if ( k == 1.0 ) return 1.0;\n            if ( ( k *= 2.0 ) < 1.0 ) return 0.5 * pow( 1024, k - 1.0 );\n            return 0.5 * ( - pow( 2.0, - 10.0 * ( k - 1.0 ) ) + 2.0 );\n          }"
                    },
                    Circular: {
                        In: "float CircularIn(float k )\n          {\n            return 1.0 - sqrt( 1.0 - k * k );\n          }",
                        Out: "float CircularOut(float k )\n          {\n            --k;\n            return sqrt( 1.0 - ( k * k ) );\n          }",
                        InOut: "float CircularInOut(float k )\n          {\n            if ( ( k *= 2.0 ) < 1.0) return - 0.5 * ( sqrt( 1.0 - k * k) - 1.0);\n            k -= 2.0;\n            return 0.5 * ( sqrt( 1.0 - k * k) + 1.0);\n          }"
                    },
                    Elastic: {
                        In: "float ElasticIn(float k )\n          {\n            float s, a, p;\n            a = 0.1;\n            p = 0.4;\n\n            if ( k == 0.0 ) return 0.0;\n            if ( k == 1.0 ) return 1.0;\n            if ( !a || a < 1.0 ) { a = 1.0; s = p / 4.0; }\n            else s = p * asin( 1.0 / a ) / ( 2.0 * ".concat(o, " );\n            k -= 1.0;\n            return - ( a * pow( 2.0, 10.0 * k ) * sin( ( k - s ) * ( 2.0 * ").concat(o, " ) / p ) );\n          }"),
                        Out: "float ElasticOut(float k )\n          {\n            float s, a, p;\n            a = 0.1;\n            p = 0.4;\n            if ( k == 0.0 ) return 0.0;\n            if ( k == 1.0 ) return 1.0;\n            if ( !a || a < 1.0 ) { a = 1.0; s = p / 4.0; }\n            else s = p * asin( 1.0 / a ) / ( 2.0 * ".concat(o, " );\n            return ( a * pow( 2.0, - 10.0 * k) * sin( ( k - s ) * ( 2.0 * ").concat(o, " ) / p ) + 1.0 );\n          }"),
                        InOut: "float ElasticInOut(float k )\n          {\n            float s, a, p;\n            a = 0.1;\n            p = 0.4;\n\n            if ( k == 0.0 ) return 0.0;\n            if ( k == 1.0 ) return 1.0;\n            if ( !a || a < 1.0 ) { a = 1.0; s = p / 4.0; }\n            else s = p * asin( 1.0 / a ) / ( 2.0 * ".concat(o, " );\n            if ( ( k *= 2.0 ) < 1.0 )\n            {\n              k -= 1.0;\n              return - 0.5 * ( a * pow( 2.0, 10.0 * k ) * sin( ( k - s ) * ( 2.0 * ").concat(o, " ) / p ) );\n            }\n            k -= 1.0;\n            return a * pow( 2.0, -10 * k ) * sin( ( k - s ) * ( 2.0 * ").concat(o, " ) / p ) * 0.5 + 1.0;\n          }")
                    },
                    Back: {
                        In: "float BackIn(float k )\n          {\n            float s = 1.70158;\n            return k * k * ( ( s + 1.0 ) * k - s );\n          }",
                        Out: "float BackOut(float k )\n          {\n            float s = 1.70158;\n            --k;\n            return k * k * ( ( s + 1.0 ) * k + s ) + 1.0;\n          }",
                        InOut: "float BackInOut(float k )\n          {\n            float s = 1.70158 * 1.525;\n            k *= 2.0;\n            if ( k < 1.0 ) return 0.5 * ( k * k * ( ( s + 1.0 ) * k - s ) );\n            k -= 2.0;\n            return 0.5 * ( k * k * ( ( s + 1.0 ) * k + s ) + 2.0 );\n          }"
                    },
                    Bounce: {
                        Out: "float BounceOut(float k )\n          {\n            if ( k < ( 1.0 / 2.75 ) ) {\n              return 7.5625 * k * k;\n            } else if ( k < ( 2.0 / 2.75 ) ) {\n              k -= 1.5 / 2.75;\n              return 7.5625 * k * k + 0.75;\n            } else if ( k < ( 2.5 / 2.75 ) ) {\n              k -= 2.25 / 2.75 ;\n              return 7.5625 * k * k + 0.9375;\n            } else {\n              k -= 2.625 / 2.75;\n              return 7.5625 * k * k + 0.984375;\n            }\n          }",
                        In: "float BounceIn(float k )\n          {\n            return 1.0 - Out( 1.0 - k );\n          }",
                        InOut: "float BounceInOut(float k )\n          {\n            if ( k < 0.5 ) return In( k * 2.0 ) * 0.5;\n            return Out( k * 2.0 - 1.0 ) * 0.5 + 0.5;\n          }"
                    }
                },
                s = function() {
                    var t = {};
                    return function(e) {
                        var n = t[e];
                        if (!n) {
                            var r = e.replace(/\$\{([\s]*[^;\s\{]+[\s]*)\}/g, function(t, e) {
                                return "${map.".concat(e.trim(), "}")
                            }).replace(/(\$\{(?!map\.)[^}]+\})/g, "");
                            n = Function("map", "return `".concat(r, "`"))
                        }
                        return n
                    }
                }();
            n.d(e, "a", function() {
                return u
            });
            var c = {
                curlNoise: i,
                eases: a,
                hueShift: "\nvec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}",
                luma: "float luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}",
                mapLinear: "\nfloat mapLinear( in float x, in float a1, in float a2, in float b1, in float b2 ) {\n  return a2 == a1 ? b1 : b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\n}\n",
                random: "\nfloat random(vec2 co){ return fract(sin(dot(co.xy,vec2(12.9898,78.233))) * 43758.5453);}\nfloat random(float u, float v) {  return random(vec2(u, v));}\n",
                snoise: r
            };

            function u(t) {
                return s(t)(c)
            }
            new RegExp([/\/(\*)[^*]*\*+(?:[^*\/][^*]*\*+)*\//.source, /\/(\/)[^\n]*$/.source, /"(?:[^"\\]*|\\[\S\s])*"|'(?:[^'\\]*|\\[\S\s])*'/.source, /(?:[$\w\)\]]|\+\+|--)\s*\/(?![*\/])/.source, /\/(?=[^*\/])[^[\/\\]*(?:(?:\[(?:\\.|[^\]\\]*)*\]|\\.)[^[\/\\]*)*?\/[gim]*/.source].join("|"), "gm")
        },
        fa81: function(t, e, n) {
            "undefined" != typeof self && self, t.exports = function(t) {
                var e = {};

                function n(r) {
                    if (e[r]) return e[r].exports;
                    var i = e[r] = {
                        i: r,
                        l: !1,
                        exports: {}
                    };
                    return t[r].call(i.exports, i, i.exports, n), i.l = !0, i.exports
                }
                return n.m = t, n.c = e, n.d = function(t, e, r) {
                    n.o(t, e) || Object.defineProperty(t, e, {
                        enumerable: !0,
                        get: r
                    })
                }, n.r = function(t) {
                    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                        value: "Module"
                    }), Object.defineProperty(t, "__esModule", {
                        value: !0
                    })
                }, n.t = function(t, e) {
                    if (1 & e && (t = n(t)), 8 & e) return t;
                    if (4 & e && "object" == typeof t && t && t.__esModule) return t;
                    var r = Object.create(null);
                    if (n.r(r), Object.defineProperty(r, "default", {
                            enumerable: !0,
                            value: t
                        }), 2 & e && "string" != typeof t)
                        for (var i in t) n.d(r, i, function(e) {
                            return t[e]
                        }.bind(null, i));
                    return r
                }, n.n = function(t) {
                    var e = t && t.__esModule ? function() {
                        return t.default
                    } : function() {
                        return t
                    };
                    return n.d(e, "a", e), e
                }, n.o = function(t, e) {
                    return Object.prototype.hasOwnProperty.call(t, e)
                }, n.p = "", n(n.s = 1)
            }([function(t, e, n) {
                "use strict";
                var r = n(3);

                function i(t) {
                    return !0 === r(t) && "[object Object]" === Object.prototype.toString.call(t)
                }
                t.exports = function(t) {
                    var e, n;
                    return !1 !== i(t) && "function" == typeof(e = t.constructor) && !1 !== i(n = e.prototype) && !1 !== n.hasOwnProperty("isPrototypeOf")
                }
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.VERSION = e.PALETTE_MATERIAL_CHROME = e.PALETTE_MATERIAL_500 = e.COLOR_NAMES = e.getLuminance = e.intToRgb = e.rgbToInt = e.rgbToHsv = e.rgbToHsl = e.hslToRgb = e.rgbToHex = e.parseColor = e.parseColorToHsla = e.parseColorToHsl = e.parseColorToRgba = e.parseColorToRgb = e.from = e.createPicker = void 0;
                var r = function() {
                        function t(t, e) {
                            for (var n = 0; n < e.length; n++) {
                                var r = e[n];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(t, r.key, r)
                            }
                        }
                        return function(e, n, r) {
                            return n && t(e.prototype, n), r && t(e, r), e
                        }
                    }(),
                    i = function(t, e) {
                        if (Array.isArray(t)) return t;
                        if (Symbol.iterator in Object(t)) return function(t, e) {
                            var n = [],
                                r = !0,
                                i = !1,
                                o = void 0;
                            try {
                                for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);
                            } catch (t) {
                                i = !0, o = t
                            } finally {
                                try {
                                    !r && s.return && s.return()
                                } finally {
                                    if (i) throw o
                                }
                            }
                            return n
                        }(t, e);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    },
                    o = n(2),
                    a = c(n(0)),
                    s = c(n(4));

                function c(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }

                function u(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function l(t) {
                    if (Array.isArray(t)) {
                        for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
                        return n
                    }
                    return Array.from(t)
                }
                var h = "undefined" != typeof window && window.navigator.userAgent.indexOf("Edge") > -1,
                    p = "undefined" != typeof window && window.navigator.userAgent.indexOf("rv:") > -1,
                    d = {
                        id: null,
                        attachTo: "body",
                        showHSL: !0,
                        showRGB: !0,
                        showHEX: !0,
                        showAlpha: !1,
                        color: "#ff0000",
                        palette: null,
                        paletteEditable: !1,
                        useAlphaInPalette: "auto"
                    },
                    f = [232, 150],
                    m = [150, 11],
                    v = m,
                    g = "COLOR",
                    y = "RGBA_USER",
                    x = "HSLA_USER";

                function b(t, e, n) {
                    return t ? t instanceof HTMLElement ? t : t instanceof NodeList ? t[0] : "string" == typeof t ? document.querySelector(t) : t.jquery ? t.get(0) : n ? e : null : e
                }

                function w(t) {
                    var e = t.getContext("2d"),
                        n = +t.width,
                        r = +t.height,
                        a = e.createLinearGradient(1, 1, 1, r - 1);
                    return a.addColorStop(0, "white"), a.addColorStop(1, "black"), {
                        setHue: function(t) {
                            var i = e.createLinearGradient(1, 0, n - 1, 0);
                            i.addColorStop(0, "hsla(" + t + ", 100%, 50%, 0)"), i.addColorStop(1, "hsla(" + t + ", 100%, 50%, 1)"), e.fillStyle = a, e.fillRect(0, 0, n, r), e.fillStyle = i, e.globalCompositeOperation = "multiply", e.fillRect(0, 0, n, r), e.globalCompositeOperation = "source-over"
                        },
                        grabColor: function(t, n) {
                            return e.getImageData(t, n, 1, 1).data
                        },
                        findColor: function(t, e, a) {
                            var s = (0, o.rgbToHsv)(t, e, a),
                                c = i(s, 3),
                                u = c[1],
                                l = c[2];
                            return [u * n, r - l * r]
                        }
                    }
                }

                function _(t, e, n) {
                    return null === t ? e : /^\s*$/.test(t) ? n : !!/true|yes|1/i.test(t) || !/false|no|0/i.test(t) && e
                }
                var M = function() {
                        function t(e, n) {
                            if (u(this, t), n ? (e = b(e), this.options = Object.assign({}, d, n)) : e && (0, a.default)(e) ? (this.options = Object.assign({}, d, e), e = b(this.options.attachTo)) : (this.options = Object.assign({}, d), e = b((0, o.nvl)(e, this.options.attachTo))), !e) throw new Error("Container not found: " + this.options.attachTo);
                            ! function(t, e) {
                                var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "acp-";
                                if (e.hasAttribute(n + "show-hsl") && (t.showHSL = _(e.getAttribute(n + "show-hsl"), d.showHSL, !0)), e.hasAttribute(n + "show-rgb") && (t.showRGB = _(e.getAttribute(n + "show-rgb"), d.showRGB, !0)), e.hasAttribute(n + "show-hex") && (t.showHEX = _(e.getAttribute(n + "show-hex"), d.showHEX, !0)), e.hasAttribute(n + "show-alpha") && (t.showAlpha = _(e.getAttribute(n + "show-alpha"), d.showAlpha, !0)), e.hasAttribute(n + "palette-editable") && (t.paletteEditable = _(e.getAttribute(n + "palette-editable"), d.paletteEditable, !0)), e.hasAttribute(n + "palette")) {
                                    var r = e.getAttribute(n + "palette");
                                    switch (r) {
                                        case "PALETTE_MATERIAL_500":
                                            t.palette = o.PALETTE_MATERIAL_500;
                                            break;
                                        case "PALETTE_MATERIAL_CHROME":
                                        case "":
                                            t.palette = o.PALETTE_MATERIAL_CHROME;
                                            break;
                                        default:
                                            t.palette = r.split(/[;|]/)
                                    }
                                }
                                e.hasAttribute(n + "color") && (t.color = e.getAttribute(n + "color"))
                            }(this.options, e), this.H = 0, this.S = 0, this.L = 0, this.R = 0, this.G = 0, this.B = 0, this.A = 1, this.palette = {}, this.element = document.createElement("div"), this.options.id && (this.element.id = this.options.id), this.element.className = "a-color-picker", this.element.innerHTML = s.default, e.appendChild(this.element);
                            var r = this.element.querySelector(".a-color-picker-h");
                            this.setupHueCanvas(r), this.hueBarHelper = w(r), this.huePointer = this.element.querySelector(".a-color-picker-h+.a-color-picker-dot");
                            var i = this.element.querySelector(".a-color-picker-sl");
                            this.setupSlCanvas(i), this.slBarHelper = w(i), this.slPointer = this.element.querySelector(".a-color-picker-sl+.a-color-picker-dot"), this.preview = this.element.querySelector(".a-color-picker-preview"), this.setupClipboard(this.preview.querySelector(".a-color-picker-clipbaord")), this.options.showHSL ? (this.setupInput(this.inputH = this.element.querySelector(".a-color-picker-hsl>input[nameref=H]")), this.setupInput(this.inputS = this.element.querySelector(".a-color-picker-hsl>input[nameref=S]")), this.setupInput(this.inputL = this.element.querySelector(".a-color-picker-hsl>input[nameref=L]"))) : this.element.querySelector(".a-color-picker-hsl").remove(), this.options.showRGB ? (this.setupInput(this.inputR = this.element.querySelector(".a-color-picker-rgb>input[nameref=R]")), this.setupInput(this.inputG = this.element.querySelector(".a-color-picker-rgb>input[nameref=G]")), this.setupInput(this.inputB = this.element.querySelector(".a-color-picker-rgb>input[nameref=B]"))) : this.element.querySelector(".a-color-picker-rgb").remove(), this.options.showHEX ? this.setupInput(this.inputRGBHEX = this.element.querySelector("input[nameref=RGBHEX]")) : this.element.querySelector(".a-color-picker-rgbhex").remove(), this.options.paletteEditable || this.options.palette && this.options.palette.length > 0 ? this.setPalette(this.element.querySelector(".a-color-picker-palette")) : this.element.querySelector(".a-color-picker-palette").remove(), this.options.showAlpha ? (this.setupAlphaCanvas(this.element.querySelector(".a-color-picker-a")), this.alphaPointer = this.element.querySelector(".a-color-picker-a+.a-color-picker-dot")) : this.element.querySelector(".a-color-picker-alpha").remove(), this.onValueChanged(g, this.options.color)
                        }
                        return r(t, [{
                            key: "setupHueCanvas",
                            value: function(t) {
                                var e = this;
                                t.width = m[0], t.height = m[1];
                                for (var n = t.getContext("2d"), r = n.createLinearGradient(0, 0, m[0], 0), i = 0; i <= 1; i += 1 / 360) r.addColorStop(i, "hsl(" + 360 * i + ", 100%, 50%)");
                                n.fillStyle = r, n.fillRect(0, 0, m[0], m[1]);
                                var a = function(n) {
                                        var r = (0, o.limit)(n.clientX - t.getBoundingClientRect().left, 0, m[0]),
                                            i = Math.round(360 * r / m[0]);
                                        e.huePointer.style.left = r - 7 + "px", e.onValueChanged("H", i)
                                    },
                                    s = function t() {
                                        document.removeEventListener("mousemove", a), document.removeEventListener("mouseup", t)
                                    };
                                t.addEventListener("mousedown", function(t) {
                                    a(t), document.addEventListener("mousemove", a), document.addEventListener("mouseup", s)
                                })
                            }
                        }, {
                            key: "setupSlCanvas",
                            value: function(t) {
                                var e = this;
                                t.width = f[0], t.height = f[1];
                                var n = function(n) {
                                        var r = (0, o.limit)(n.clientX - t.getBoundingClientRect().left, 0, f[0] - 1),
                                            i = (0, o.limit)(n.clientY - t.getBoundingClientRect().top, 0, f[1] - 1),
                                            a = e.slBarHelper.grabColor(r, i);
                                        e.slPointer.style.left = r - 7 + "px", e.slPointer.style.top = i - 7 + "px", e.onValueChanged("RGB", a)
                                    },
                                    r = function t() {
                                        document.removeEventListener("mousemove", n), document.removeEventListener("mouseup", t)
                                    };
                                t.addEventListener("mousedown", function(t) {
                                    n(t), document.addEventListener("mousemove", n), document.addEventListener("mouseup", r)
                                })
                            }
                        }, {
                            key: "setupAlphaCanvas",
                            value: function(t) {
                                var e = this;
                                t.width = v[0], t.height = v[1];
                                var n = t.getContext("2d"),
                                    r = n.createLinearGradient(0, 0, t.width - 1, 0);
                                r.addColorStop(0, "hsla(0, 0%, 50%, 0)"), r.addColorStop(1, "hsla(0, 0%, 50%, 1)"), n.fillStyle = r, n.fillRect(0, 0, v[0], v[1]);
                                var i = function(n) {
                                        var r = (0, o.limit)(n.clientX - t.getBoundingClientRect().left, 0, v[0]),
                                            i = +(r / v[0]).toFixed(2);
                                        e.alphaPointer.style.left = r - 7 + "px", e.onValueChanged("ALPHA", i)
                                    },
                                    a = function t() {
                                        document.removeEventListener("mousemove", i), document.removeEventListener("mouseup", t)
                                    };
                                t.addEventListener("mousedown", function(t) {
                                    i(t), document.addEventListener("mousemove", i), document.addEventListener("mouseup", a)
                                })
                            }
                        }, {
                            key: "setupInput",
                            value: function(t) {
                                var e = this,
                                    n = +t.min,
                                    r = +t.max,
                                    i = t.getAttribute("nameref");
                                t.hasAttribute("select-on-focus") && t.addEventListener("focus", function() {
                                    t.select()
                                }), "text" === t.type ? t.addEventListener("change", function() {
                                    e.onValueChanged(i, t.value)
                                }) : ((h || p) && t.addEventListener("keydown", function(a) {
                                    "Up" === a.key ? (t.value = (0, o.limit)(+t.value + 1, n, r), e.onValueChanged(i, t.value), a.returnValue = !1) : "Down" === a.key && (t.value = (0, o.limit)(+t.value - 1, n, r), e.onValueChanged(i, t.value), a.returnValue = !1)
                                }), t.addEventListener("change", function() {
                                    var a = +t.value;
                                    e.onValueChanged(i, (0, o.limit)(a, n, r))
                                }))
                            }
                        }, {
                            key: "setupClipboard",
                            value: function(t) {
                                var e = this;
                                t.title = "click to copy", t.addEventListener("click", function() {
                                    t.value = (0, o.parseColor)([e.R, e.G, e.B, e.A], "hexcss4"), t.select(), document.execCommand("copy")
                                })
                            }
                        }, {
                            key: "setPalette",
                            value: function(t) {
                                var e = this,
                                    n = "auto" === this.options.useAlphaInPalette ? this.options.showAlpha : this.options.useAlphaInPalette,
                                    r = void 0;
                                switch (this.options.palette) {
                                    case "PALETTE_MATERIAL_500":
                                        r = o.PALETTE_MATERIAL_500;
                                        break;
                                    case "PALETTE_MATERIAL_CHROME":
                                        r = o.PALETTE_MATERIAL_CHROME;
                                        break;
                                    default:
                                        r = (0, o.ensureArray)(this.options.palette)
                                }
                                if (this.options.paletteEditable || r.length > 0) {
                                    var i = function(n, r, i) {
                                            var o = t.querySelector('.a-color-picker-palette-color[data-color="' + n + '"]') || document.createElement("div");
                                            o.className = "a-color-picker-palette-color", o.style.backgroundColor = n, o.setAttribute("data-color", n), o.title = n, t.insertBefore(o, r), e.palette[n] = !0, i && e.onPaletteColorAdd(n)
                                        },
                                        a = function(n, r) {
                                            n ? (t.removeChild(n), e.palette[n.getAttribute("data-color")] = !1, r && e.onPaletteColorRemove(n.getAttribute("data-color"))) : (t.querySelectorAll(".a-color-picker-palette-color[data-color]").forEach(function(e) {
                                                t.removeChild(e)
                                            }), Object.keys(e.palette).forEach(function(t) {
                                                e.palette[t] = !1
                                            }), r && e.onPaletteColorRemove())
                                        };
                                    if (r.map(function(t) {
                                            return (0, o.parseColor)(t, n ? "rgbcss4" : "hex")
                                        }).filter(function(t) {
                                            return !!t
                                        }).forEach(function(t) {
                                            return i(t)
                                        }), this.options.paletteEditable) {
                                        var s = document.createElement("div");
                                        s.className = "a-color-picker-palette-color a-color-picker-palette-add", s.innerHTML = "+", t.appendChild(s), t.addEventListener("click", function(t) {
                                            /a-color-picker-palette-add/.test(t.target.className) ? t.shiftKey ? a(null, !0) : i(n ? (0, o.parseColor)([e.R, e.G, e.B, e.A], "rgbcss4") : (0, o.rgbToHex)(e.R, e.G, e.B), t.target, !0) : /a-color-picker-palette-color/.test(t.target.className) && (t.shiftKey ? a(t.target, !0) : e.onValueChanged(g, t.target.getAttribute("data-color")))
                                        })
                                    } else t.addEventListener("click", function(t) {
                                        /a-color-picker-palette-color/.test(t.target.className) && e.onValueChanged(g, t.target.getAttribute("data-color"))
                                    })
                                } else t.style.display = "none"
                            }
                        }, {
                            key: "onValueChanged",
                            value: function(t, e) {
                                switch (t) {
                                    case "H":
                                        this.H = e;
                                        var n = (0, o.hslToRgb)(this.H, this.S, this.L),
                                            r = i(n, 3);
                                        this.R = r[0], this.G = r[1], this.B = r[2], this.slBarHelper.setHue(e), this.updatePointerH(this.H), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case "S":
                                        this.S = e;
                                        var a = (0, o.hslToRgb)(this.H, this.S, this.L),
                                            s = i(a, 3);
                                        this.R = s[0], this.G = s[1], this.B = s[2], this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case "L":
                                        this.L = e;
                                        var c = (0, o.hslToRgb)(this.H, this.S, this.L),
                                            u = i(c, 3);
                                        this.R = u[0], this.G = u[1], this.B = u[2], this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case "R":
                                        this.R = e;
                                        var l = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            h = i(l, 3);
                                        this.H = h[0], this.S = h[1], this.L = h[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case "G":
                                        this.G = e;
                                        var p = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            d = i(p, 3);
                                        this.H = d[0], this.S = d[1], this.L = d[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case "B":
                                        this.B = e;
                                        var f = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            m = i(f, 3);
                                        this.H = m[0], this.S = m[1], this.L = m[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case "RGB":
                                        var v = i(e, 3);
                                        this.R = v[0], this.G = v[1], this.B = v[2];
                                        var b = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            w = i(b, 3);
                                        this.H = w[0], this.S = w[1], this.L = w[2], this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B);
                                        break;
                                    case y:
                                        var _ = i(e, 4);
                                        this.R = _[0], this.G = _[1], this.B = _[2], this.A = _[3];
                                        var M = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            E = i(M, 3);
                                        this.H = E[0], this.S = E[1], this.L = E[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B), this.updatePointerA(this.A);
                                        break;
                                    case x:
                                        var S = i(e, 4);
                                        this.H = S[0], this.S = S[1], this.L = S[2], this.A = S[3];
                                        var T = (0, o.hslToRgb)(this.H, this.S, this.L),
                                            A = i(T, 3);
                                        this.R = A[0], this.G = A[1], this.B = A[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B), this.updatePointerA(this.A);
                                        break;
                                    case "RGBHEX":
                                        var L = (0, o.cssColorToRgb)(e) || [this.R, this.G, this.B],
                                            C = i(L, 3);
                                        this.R = C[0], this.G = C[1], this.B = C[2];
                                        var R = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            P = i(R, 3);
                                        this.H = P[0], this.S = P[1], this.L = P[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B);
                                        break;
                                    case g:
                                        var O = (0, o.parseColor)(e, "rgba") || [0, 0, 0, 1],
                                            I = i(O, 4);
                                        this.R = I[0], this.G = I[1], this.B = I[2], this.A = I[3];
                                        var B = (0, o.rgbToHsl)(this.R, this.G, this.B),
                                            D = i(B, 3);
                                        this.H = D[0], this.S = D[1], this.L = D[2], this.slBarHelper.setHue(this.H), this.updatePointerH(this.H), this.updatePointerSL(this.H, this.S, this.L), this.updateInputHSL(this.H, this.S, this.L), this.updateInputRGB(this.R, this.G, this.B), this.updateInputRGBHEX(this.R, this.G, this.B), this.updatePointerA(this.A);
                                        break;
                                    case "ALPHA":
                                        this.A = e
                                }
                                this.onColorChanged(this.R, this.G, this.B, this.A)
                            }
                        }, {
                            key: "onColorChanged",
                            value: function(t, e, n, r) {
                                this.preview.style.backgroundColor = 1 === r ? "rgb(" + t + "," + e + "," + n + ")" : "rgba(" + t + "," + e + "," + n + "," + r + ")", this.onchange && this.onchange(this.preview.style.backgroundColor)
                            }
                        }, {
                            key: "onPaletteColorAdd",
                            value: function(t) {
                                this.oncoloradd && this.oncoloradd(t)
                            }
                        }, {
                            key: "onPaletteColorRemove",
                            value: function(t) {
                                this.oncolorremove && this.oncolorremove(t)
                            }
                        }, {
                            key: "updateInputHSL",
                            value: function(t, e, n) {
                                this.options.showHSL && (this.inputH.value = t, this.inputS.value = e, this.inputL.value = n)
                            }
                        }, {
                            key: "updateInputRGB",
                            value: function(t, e, n) {
                                this.options.showRGB && (this.inputR.value = t, this.inputG.value = e, this.inputB.value = n)
                            }
                        }, {
                            key: "updateInputRGBHEX",
                            value: function(t, e, n) {
                                this.options.showHEX && (this.inputRGBHEX.value = (0, o.rgbToHex)(t, e, n))
                            }
                        }, {
                            key: "updatePointerH",
                            value: function(t) {
                                var e = m[0] * t / 360;
                                this.huePointer.style.left = e - 7 + "px"
                            }
                        }, {
                            key: "updatePointerSL",
                            value: function(t, e, n) {
                                var r = (0, o.hslToRgb)(t, e, n),
                                    a = i(r, 3),
                                    s = a[0],
                                    c = a[1],
                                    u = a[2],
                                    l = this.slBarHelper.findColor(s, c, u),
                                    h = i(l, 2),
                                    p = h[0],
                                    d = h[1];
                                p >= 0 && (this.slPointer.style.left = p - 7 + "px", this.slPointer.style.top = d - 7 + "px")
                            }
                        }, {
                            key: "updatePointerA",
                            value: function(t) {
                                if (this.options.showAlpha) {
                                    var e = v[0] * t;
                                    this.alphaPointer.style.left = e - 7 + "px"
                                }
                            }
                        }]), t
                    }(),
                    E = function() {
                        function t(e) {
                            u(this, t), this.name = e, this.listeners = []
                        }
                        return r(t, [{
                            key: "on",
                            value: function(t) {
                                t && this.listeners.push(t)
                            }
                        }, {
                            key: "off",
                            value: function(t) {
                                this.listeners = t ? this.listeners.filter(function(e) {
                                    return e !== t
                                }) : []
                            }
                        }, {
                            key: "emit",
                            value: function(t, e) {
                                for (var n = this.listeners.slice(0), r = 0; r < n.length; r++) n[r].apply(e, t)
                            }
                        }]), t
                    }();

                function S(t, e) {
                    var n = new M(t, e),
                        r = {
                            change: new E("change"),
                            coloradd: new E("coloradd"),
                            colorremove: new E("colorremove")
                        },
                        a = !0,
                        s = {},
                        c = {get element() {
                                return n.element
                            },
                            get rgb() {
                                return [n.R, n.G, n.B]
                            },
                            set rgb(t) {
                                var e = i(t, 3),
                                    r = e[0],
                                    a = e[1],
                                    s = e[2],
                                    c = [(0, o.limit)(r, 0, 255), (0, o.limit)(a, 0, 255), (0, o.limit)(s, 0, 255)];
                                r = c[0], a = c[1], s = c[2], n.onValueChanged(y, [r, a, s, 1])
                            },
                            get hsl() {
                                return [n.H, n.S, n.L]
                            },
                            set hsl(t) {
                                var e = i(t, 3),
                                    r = e[0],
                                    a = e[1],
                                    s = e[2],
                                    c = [(0, o.limit)(r, 0, 360), (0, o.limit)(a, 0, 100), (0, o.limit)(s, 0, 100)];
                                r = c[0], a = c[1], s = c[2], n.onValueChanged(x, [r, a, s, 1])
                            },
                            get rgbhex() {
                                return this.all.hex
                            },
                            get rgba() {
                                return [n.R, n.G, n.B, n.A]
                            },
                            set rgba(t) {
                                var e = i(t, 4),
                                    r = e[0],
                                    a = e[1],
                                    s = e[2],
                                    c = e[3],
                                    u = [(0, o.limit)(r, 0, 255), (0, o.limit)(a, 0, 255), (0, o.limit)(s, 0, 255), (0, o.limit)(c, 0, 1)];
                                r = u[0], a = u[1], s = u[2], c = u[3], n.onValueChanged(y, [r, a, s, c])
                            },
                            get hsla() {
                                return [n.H, n.S, n.L, n.A]
                            },
                            set hsla(t) {
                                var e = i(t, 4),
                                    r = e[0],
                                    a = e[1],
                                    s = e[2],
                                    c = e[3],
                                    u = [(0, o.limit)(r, 0, 360), (0, o.limit)(a, 0, 100), (0, o.limit)(s, 0, 100), (0, o.limit)(c, 0, 1)];
                                r = u[0], a = u[1], s = u[2], c = u[3], n.onValueChanged(x, [r, a, s, c])
                            },
                            get color() {
                                return this.all.toString()
                            },
                            set color(t) {
                                n.onValueChanged(g, t)
                            },
                            get all() {
                                if (a) {
                                    var t = [n.R, n.G, n.B, n.A],
                                        e = n.A < 1 ? "rgba(" + n.R + "," + n.G + "," + n.B + "," + n.A + ")" : o.rgbToHex.apply(void 0, t);
                                    (s = (0, o.parseColor)(t, s)).toString = function() {
                                        return e
                                    }, a = !1
                                }
                                return Object.assign({}, s)
                            },
                            get onchange() {
                                return r.change && r.change.listeners[0]
                            },
                            set onchange(t) {
                                this.off("change").on("change", t)
                            },
                            get oncoloradd() {
                                return r.coloradd && r.coloradd.listeners[0]
                            },
                            set oncoloradd(t) {
                                this.off("coloradd").on("coloradd", t)
                            },
                            get oncolorremove() {
                                return r.colorremove && r.colorremove.listeners[0]
                            },
                            set oncolorremove(t) {
                                this.off("colorremove").on("colorremove", t)
                            },
                            get palette() {
                                return Object.keys(n.palette).filter(function(t) {
                                    return n.palette[t]
                                })
                            },
                            on: function(t, e) {
                                return t && r[t] && r[t].on(e), this
                            },
                            off: function(t, e) {
                                return t && r[t] && r[t].off(e), this
                            },
                            destroy: function() {
                                r.change.off(), r.coloradd.off(), r.colorremove.off(), n.element.remove(), r = null, n = null
                            }
                        };
                    return n.onchange = function() {
                        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        a = !0, r.change.emit([c].concat(e), c)
                    }, n.oncoloradd = function() {
                        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        r.coloradd.emit([c].concat(e), c)
                    }, n.oncolorremove = function() {
                        for (var t = arguments.length, e = Array(t), n = 0; n < t; n++) e[n] = arguments[n];
                        r.colorremove.emit([c].concat(e), c)
                    }, n.element.ctrl = c, c
                }
                if ("undefined" != typeof window && !document.querySelector('head>style[data-source="a-color-picker"]')) {
                    var T = n(5).toString(),
                        A = document.createElement("style");
                    A.setAttribute("type", "text/css"), A.setAttribute("data-source", "a-color-picker"), A.innerHTML = T, document.querySelector("head").appendChild(A)
                }
                e.createPicker = S, e.from = function(t, e) {
                    var n = function(t) {
                        return t ? Array.isArray(t) ? t : t instanceof HTMLElement ? [t] : t instanceof NodeList ? [].concat(l(t)) : "string" == typeof t ? [].concat(l(document.querySelectorAll(t))) : t.jquery ? t.get() : [] : []
                    }(t).map(function(t, n) {
                        var r = S(t, e);
                        return r.index = n, r
                    });
                    return n.on = function(t, e) {
                        return n.forEach(function(n) {
                            return n.on(t, e)
                        }), this
                    }, n.off = function(t) {
                        return n.forEach(function(e) {
                            return e.off(t)
                        }), this
                    }, n
                }, e.parseColorToRgb = o.parseColorToRgb, e.parseColorToRgba = o.parseColorToRgba, e.parseColorToHsl = o.parseColorToHsl, e.parseColorToHsla = o.parseColorToHsla, e.parseColor = o.parseColor, e.rgbToHex = o.rgbToHex, e.hslToRgb = o.hslToRgb, e.rgbToHsl = o.rgbToHsl, e.rgbToHsv = o.rgbToHsv, e.rgbToInt = o.rgbToInt, e.intToRgb = o.intToRgb, e.getLuminance = o.getLuminance, e.COLOR_NAMES = o.COLOR_NAMES, e.PALETTE_MATERIAL_500 = o.PALETTE_MATERIAL_500, e.PALETTE_MATERIAL_CHROME = o.PALETTE_MATERIAL_CHROME, e.VERSION = "1.1.8"
            }, function(t, e, n) {
                "use strict";
                Object.defineProperty(e, "__esModule", {
                    value: !0
                }), e.nvl = e.ensureArray = e.limit = e.getLuminance = e.parseColor = e.parseColorToHsla = e.parseColorToHsl = e.cssHslaToHsla = e.cssHslToHsl = e.parseColorToRgba = e.parseColorToRgb = e.cssRgbaToRgba = e.cssRgbToRgb = e.cssColorToRgba = e.cssColorToRgb = e.intToRgb = e.rgbToInt = e.rgbToHsv = e.rgbToHsl = e.hslToRgb = e.rgbToHex = e.PALETTE_MATERIAL_CHROME = e.PALETTE_MATERIAL_500 = e.COLOR_NAMES = void 0;
                var r = function(t, e) {
                        if (Array.isArray(t)) return t;
                        if (Symbol.iterator in Object(t)) return function(t, e) {
                            var n = [],
                                r = !0,
                                i = !1,
                                o = void 0;
                            try {
                                for (var a, s = t[Symbol.iterator](); !(r = (a = s.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);
                            } catch (t) {
                                i = !0, o = t
                            } finally {
                                try {
                                    !r && s.return && s.return()
                                } finally {
                                    if (i) throw o
                                }
                            }
                            return n
                        }(t, e);
                        throw new TypeError("Invalid attempt to destructure non-iterable instance")
                    },
                    i = function(t) {
                        return t && t.__esModule ? t : {
                            default: t
                        }
                    }(n(0));

                function o(t) {
                    if (Array.isArray(t)) {
                        for (var e = 0, n = Array(t.length); e < t.length; e++) n[e] = t[e];
                        return n
                    }
                    return Array.from(t)
                }
                var a = {
                    aliceblue: "#F0F8FF",
                    antiquewhite: "#FAEBD7",
                    aqua: "#00FFFF",
                    aquamarine: "#7FFFD4",
                    azure: "#F0FFFF",
                    beige: "#F5F5DC",
                    bisque: "#FFE4C4",
                    black: "#000000",
                    blanchedalmond: "#FFEBCD",
                    blue: "#0000FF",
                    blueviolet: "#8A2BE2",
                    brown: "#A52A2A",
                    burlywood: "#DEB887",
                    cadetblue: "#5F9EA0",
                    chartreuse: "#7FFF00",
                    chocolate: "#D2691E",
                    coral: "#FF7F50",
                    cornflowerblue: "#6495ED",
                    cornsilk: "#FFF8DC",
                    crimson: "#DC143C",
                    cyan: "#00FFFF",
                    darkblue: "#00008B",
                    darkcyan: "#008B8B",
                    darkgoldenrod: "#B8860B",
                    darkgray: "#A9A9A9",
                    darkgrey: "#A9A9A9",
                    darkgreen: "#006400",
                    darkkhaki: "#BDB76B",
                    darkmagenta: "#8B008B",
                    darkolivegreen: "#556B2F",
                    darkorange: "#FF8C00",
                    darkorchid: "#9932CC",
                    darkred: "#8B0000",
                    darksalmon: "#E9967A",
                    darkseagreen: "#8FBC8F",
                    darkslateblue: "#483D8B",
                    darkslategray: "#2F4F4F",
                    darkslategrey: "#2F4F4F",
                    darkturquoise: "#00CED1",
                    darkviolet: "#9400D3",
                    deeppink: "#FF1493",
                    deepskyblue: "#00BFFF",
                    dimgray: "#696969",
                    dimgrey: "#696969",
                    dodgerblue: "#1E90FF",
                    firebrick: "#B22222",
                    floralwhite: "#FFFAF0",
                    forestgreen: "#228B22",
                    fuchsia: "#FF00FF",
                    gainsboro: "#DCDCDC",
                    ghostwhite: "#F8F8FF",
                    gold: "#FFD700",
                    goldenrod: "#DAA520",
                    gray: "#808080",
                    grey: "#808080",
                    green: "#008000",
                    greenyellow: "#ADFF2F",
                    honeydew: "#F0FFF0",
                    hotpink: "#FF69B4",
                    "indianred ": "#CD5C5C",
                    "indigo ": "#4B0082",
                    ivory: "#FFFFF0",
                    khaki: "#F0E68C",
                    lavender: "#E6E6FA",
                    lavenderblush: "#FFF0F5",
                    lawngreen: "#7CFC00",
                    lemonchiffon: "#FFFACD",
                    lightblue: "#ADD8E6",
                    lightcoral: "#F08080",
                    lightcyan: "#E0FFFF",
                    lightgoldenrodyellow: "#FAFAD2",
                    lightgray: "#D3D3D3",
                    lightgrey: "#D3D3D3",
                    lightgreen: "#90EE90",
                    lightpink: "#FFB6C1",
                    lightsalmon: "#FFA07A",
                    lightseagreen: "#20B2AA",
                    lightskyblue: "#87CEFA",
                    lightslategray: "#778899",
                    lightslategrey: "#778899",
                    lightsteelblue: "#B0C4DE",
                    lightyellow: "#FFFFE0",
                    lime: "#00FF00",
                    limegreen: "#32CD32",
                    linen: "#FAF0E6",
                    magenta: "#FF00FF",
                    maroon: "#800000",
                    mediumaquamarine: "#66CDAA",
                    mediumblue: "#0000CD",
                    mediumorchid: "#BA55D3",
                    mediumpurple: "#9370DB",
                    mediumseagreen: "#3CB371",
                    mediumslateblue: "#7B68EE",
                    mediumspringgreen: "#00FA9A",
                    mediumturquoise: "#48D1CC",
                    mediumvioletred: "#C71585",
                    midnightblue: "#191970",
                    mintcream: "#F5FFFA",
                    mistyrose: "#FFE4E1",
                    moccasin: "#FFE4B5",
                    navajowhite: "#FFDEAD",
                    navy: "#000080",
                    oldlace: "#FDF5E6",
                    olive: "#808000",
                    olivedrab: "#6B8E23",
                    orange: "#FFA500",
                    orangered: "#FF4500",
                    orchid: "#DA70D6",
                    palegoldenrod: "#EEE8AA",
                    palegreen: "#98FB98",
                    paleturquoise: "#AFEEEE",
                    palevioletred: "#DB7093",
                    papayawhip: "#FFEFD5",
                    peachpuff: "#FFDAB9",
                    peru: "#CD853F",
                    pink: "#FFC0CB",
                    plum: "#DDA0DD",
                    powderblue: "#B0E0E6",
                    purple: "#800080",
                    rebeccapurple: "#663399",
                    red: "#FF0000",
                    rosybrown: "#BC8F8F",
                    royalblue: "#4169E1",
                    saddlebrown: "#8B4513",
                    salmon: "#FA8072",
                    sandybrown: "#F4A460",
                    seagreen: "#2E8B57",
                    seashell: "#FFF5EE",
                    sienna: "#A0522D",
                    silver: "#C0C0C0",
                    skyblue: "#87CEEB",
                    slateblue: "#6A5ACD",
                    slategray: "#708090",
                    slategrey: "#708090",
                    snow: "#FFFAFA",
                    springgreen: "#00FF7F",
                    steelblue: "#4682B4",
                    tan: "#D2B48C",
                    teal: "#008080",
                    thistle: "#D8BFD8",
                    tomato: "#FF6347",
                    turquoise: "#40E0D0",
                    violet: "#EE82EE",
                    wheat: "#F5DEB3",
                    white: "#FFFFFF",
                    whitesmoke: "#F5F5F5",
                    yellow: "#FFFF00",
                    yellowgreen: "#9ACD32"
                };

                function s(t, e, n) {
                    return t = +t, isNaN(t) ? e : t < e ? e : t > n ? n : t
                }

                function c(t, e) {
                    return null == t ? e : t
                }

                function u(t, e, n) {
                    var r = [s(t, 0, 255), s(e, 0, 255), s(n, 0, 255)];
                    return "#" + ("000000" + ((t = r[0]) << 16 | (e = r[1]) << 8 | (n = r[2])).toString(16)).slice(-6)
                }

                function l(t, e, n) {
                    var r = void 0,
                        i = void 0,
                        o = void 0,
                        a = [s(t, 0, 360) / 360, s(e, 0, 100) / 100, s(n, 0, 100) / 100];
                    if (t = a[0], n = a[2], 0 == (e = a[1])) r = i = o = n;
                    else {
                        var c = function(t, e, n) {
                                return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + 6 * (e - t) * n : n < .5 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t
                            },
                            u = n < .5 ? n * (1 + e) : n + e - n * e,
                            l = 2 * n - u;
                        r = c(l, u, t + 1 / 3), i = c(l, u, t), o = c(l, u, t - 1 / 3)
                    }
                    return [255 * r, 255 * i, 255 * o].map(Math.round)
                }

                function h(t, e, n) {
                    var r = [s(t, 0, 255) / 255, s(e, 0, 255) / 255, s(n, 0, 255) / 255];
                    t = r[0], e = r[1], n = r[2];
                    var i = Math.max(t, e, n),
                        o = Math.min(t, e, n),
                        a = void 0,
                        c = void 0,
                        u = (i + o) / 2;
                    if (i == o) a = c = 0;
                    else {
                        var l = i - o;
                        switch (c = u > .5 ? l / (2 - i - o) : l / (i + o), i) {
                            case t:
                                a = (e - n) / l + (e < n ? 6 : 0);
                                break;
                            case e:
                                a = (n - t) / l + 2;
                                break;
                            case n:
                                a = (t - e) / l + 4
                        }
                        a /= 6
                    }
                    return [360 * a, 100 * c, 100 * u].map(Math.round)
                }

                function p(t, e, n) {
                    return t << 16 | e << 8 | n
                }

                function d(t) {
                    if (t) {
                        var e = a[t.toString().toLowerCase()],
                            n = /^\s*#?((([0-9A-F])([0-9A-F])([0-9A-F]))|(([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})))\s*$/i.exec(e || t) || [],
                            i = r(n, 10),
                            o = i[3],
                            s = i[4],
                            c = i[5],
                            u = i[7],
                            l = i[8],
                            h = i[9];
                        if (void 0 !== o) return [parseInt(o + o, 16), parseInt(s + s, 16), parseInt(c + c, 16)];
                        if (void 0 !== u) return [parseInt(u, 16), parseInt(l, 16), parseInt(h, 16)]
                    }
                }

                function f(t) {
                    if (t) {
                        var e = a[t.toString().toLowerCase()],
                            n = /^\s*#?((([0-9A-F])([0-9A-F])([0-9A-F])([0-9A-F])?)|(([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})?))\s*$/i.exec(e || t) || [],
                            i = r(n, 12),
                            o = i[3],
                            s = i[4],
                            c = i[5],
                            u = i[6],
                            l = i[8],
                            h = i[9],
                            p = i[10],
                            d = i[11];
                        if (void 0 !== o) return [parseInt(o + o, 16), parseInt(s + s, 16), parseInt(c + c, 16), u ? +(parseInt(u + u, 16) / 255).toFixed(2) : 1];
                        if (void 0 !== l) return [parseInt(l, 16), parseInt(h, 16), parseInt(p, 16), d ? +(parseInt(d, 16) / 255).toFixed(2) : 1]
                    }
                }

                function m(t) {
                    if (t) {
                        var e = /^rgb\((\d+)[\s,](\d+)[\s,](\d+)\)/i.exec(t) || [],
                            n = r(e, 4),
                            i = n[0],
                            o = n[1],
                            a = n[2],
                            c = n[3];
                        return i ? [s(o, 0, 255), s(a, 0, 255), s(c, 0, 255)] : void 0
                    }
                }

                function v(t) {
                    if (t) {
                        var e = /^rgba?\((\d+)\s*[\s,]\s*(\d+)\s*[\s,]\s*(\d+)(\s*[\s,]\s*(\d*(.\d+)?))?\)/i.exec(t) || [],
                            n = r(e, 6),
                            i = n[0],
                            o = n[1],
                            a = n[2],
                            u = n[3],
                            l = n[5];
                        return i ? [s(o, 0, 255), s(a, 0, 255), s(u, 0, 255), s(c(l, 1), 0, 1)] : void 0
                    }
                }

                function g(t) {
                    if (Array.isArray(t)) return [s(t[0], 0, 255), s(t[1], 0, 255), s(t[2], 0, 255), s(c(t[3], 1), 0, 1)];
                    var e = f(t) || v(t);
                    return e && 3 === e.length && e.push(1), e
                }

                function y(t) {
                    if (t) {
                        var e = /^hsl\((\d+)[\s,](\d+)[\s,](\d+)\)/i.exec(t) || [],
                            n = r(e, 4),
                            i = n[0],
                            o = n[1],
                            a = n[2],
                            c = n[3];
                        return i ? [s(o, 0, 360), s(a, 0, 100), s(c, 0, 100)] : void 0
                    }
                }

                function x(t) {
                    if (t) {
                        var e = /^hsla?\((\d+)\s*[\s,]\s*(\d+)\s*[\s,]\s*(\d+)(\s*[\s,]\s*(\d*(.\d+)?))?\)/i.exec(t) || [],
                            n = r(e, 6),
                            i = n[0],
                            o = n[1],
                            a = n[2],
                            u = n[3],
                            l = n[5];
                        return i ? [s(o, 0, 255), s(a, 0, 255), s(u, 0, 255), s(c(l, 1), 0, 1)] : void 0
                    }
                }

                function b(t) {
                    if (Array.isArray(t)) return [s(t[0], 0, 360), s(t[1], 0, 100), s(t[2], 0, 100), s(c(t[3], 1), 0, 1)];
                    var e = x(t);
                    return e && 3 === e.length && e.push(1), e
                }

                function w(t, e) {
                    switch (e) {
                        case "rgb":
                        default:
                            return t.slice(0, 3);
                        case "rgbcss":
                            return "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ")";
                        case "rgbcss4":
                            return "rgb(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
                        case "rgba":
                            return t;
                        case "rgbacss":
                            return "rgba(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ")";
                        case "hsl":
                            return h.apply(void 0, o(t));
                        case "hslcss":
                            return "hsl(" + (t = h.apply(void 0, o(t)))[0] + ", " + t[1] + ", " + t[2] + ")";
                        case "hslcss4":
                            var n = h.apply(void 0, o(t));
                            return "hsl(" + n[0] + ", " + n[1] + ", " + n[2] + ", " + t[3] + ")";
                        case "hsla":
                            return [].concat(o(h.apply(void 0, o(t))), [t[3]]);
                        case "hslacss":
                            var r = h.apply(void 0, o(t));
                            return "hsla(" + r[0] + ", " + r[1] + ", " + r[2] + ", " + t[3] + ")";
                        case "hex":
                            return u.apply(void 0, o(t));
                        case "hexcss4":
                            return u.apply(void 0, o(t)) + ("00" + parseInt(255 * t[3]).toString(16)).slice(-2);
                        case "int":
                            return p.apply(void 0, o(t))
                    }
                }
                e.COLOR_NAMES = a, e.PALETTE_MATERIAL_500 = ["#F44336", "#E91E63", "#E91E63", "#9C27B0", "#9C27B0", "#673AB7", "#673AB7", "#3F51B5", "#3F51B5", "#2196F3", "#2196F3", "#03A9F4", "#03A9F4", "#00BCD4", "#00BCD4", "#009688", "#009688", "#4CAF50", "#4CAF50", "#8BC34A", "#8BC34A", "#CDDC39", "#CDDC39", "#FFEB3B", "#FFEB3B", "#FFC107", "#FFC107", "#FF9800", "#FF9800", "#FF5722", "#FF5722", "#795548", "#795548", "#9E9E9E", "#9E9E9E", "#607D8B", "#607D8B"], e.PALETTE_MATERIAL_CHROME = ["#f44336", "#e91e63", "#9c27b0", "#673ab7", "#3f51b5", "#2196f3", "#03a9f4", "#00bcd4", "#009688", "#4caf50", "#8bc34a", "#cddc39", "#ffeb3b", "#ffc107", "#ff9800", "#ff5722", "#795548", "#9e9e9e", "#607d8b"], e.rgbToHex = u, e.hslToRgb = l, e.rgbToHsl = h, e.rgbToHsv = function(t, e, n) {
                    var r = [s(t, 0, 255) / 255, s(e, 0, 255) / 255, s(n, 0, 255) / 255];
                    t = r[0], e = r[1], n = r[2];
                    var i, o = Math.max(t, e, n),
                        a = Math.min(t, e, n),
                        c = void 0,
                        u = o,
                        l = o - a;
                    if (i = 0 === o ? 0 : l / o, o == a) c = 0;
                    else {
                        switch (o) {
                            case t:
                                c = (e - n) / l + (e < n ? 6 : 0);
                                break;
                            case e:
                                c = (n - t) / l + 2;
                                break;
                            case n:
                                c = (t - e) / l + 4
                        }
                        c /= 6
                    }
                    return [c, i, u]
                }, e.rgbToInt = p, e.intToRgb = function(t) {
                    return [t >> 16 & 255, t >> 8 & 255, 255 & t]
                }, e.cssColorToRgb = d, e.cssColorToRgba = f, e.cssRgbToRgb = m, e.cssRgbaToRgba = v, e.parseColorToRgb = function(t) {
                    return Array.isArray(t) ? t = [s(t[0], 0, 255), s(t[1], 0, 255), s(t[2], 0, 255)] : d(t) || m(t)
                }, e.parseColorToRgba = g, e.cssHslToHsl = y, e.cssHslaToHsla = x, e.parseColorToHsl = function(t) {
                    return Array.isArray(t) ? t = [s(t[0], 0, 360), s(t[1], 0, 100), s(t[2], 0, 100)] : y(t)
                }, e.parseColorToHsla = b, e.parseColor = function(t, e) {
                    if (e = e || "rgb", null != t) {
                        var n = void 0;
                        if ((n = g(t)) || (n = b(t)) && (n = [].concat(o(l.apply(void 0, o(n))), [n[3]]))) return (0, i.default)(e) ? ["rgb", "rgbcss", "rgbcss4", "rgba", "rgbacss", "hsl", "hslcss", "hslcss4", "hsla", "hslacss", "hex", "hexcss4", "int"].reduce(function(t, e) {
                            return t[e] = w(n, e), t
                        }, e || {}) : w(n, e.toString().toLowerCase())
                    }
                }, e.getLuminance = function(t, e, n) {
                    return .2126 * (t = (t /= 255) < .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4)) + .7152 * (e = (e /= 255) < .03928 ? e / 12.92 : Math.pow((e + .055) / 1.055, 2.4)) + .0722 * ((n /= 255) < .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4))
                }, e.limit = s, e.ensureArray = function(t) {
                    return t ? Array.from(t) : []
                }, e.nvl = c
            }, function(t, e, n) {
                "use strict";
                t.exports = function(t) {
                    return null != t && "object" == typeof t && !1 === Array.isArray(t)
                }
            }, function(t, e) {
                t.exports = '<div class="a-color-picker-row a-color-picker-stack a-color-picker-row-top"> <canvas class="a-color-picker-sl a-color-picker-transparent"></canvas> <div class=a-color-picker-dot></div> </div> <div class=a-color-picker-row> <div class="a-color-picker-stack a-color-picker-transparent a-color-picker-circle"> <div class=a-color-picker-preview> <input class=a-color-picker-clipbaord type=text> </div> </div> <div class=a-color-picker-column> <div class="a-color-picker-cell a-color-picker-stack"> <canvas class=a-color-picker-h></canvas> <div class=a-color-picker-dot></div> </div> <div class="a-color-picker-cell a-color-picker-alpha a-color-picker-stack" show-on-alpha> <canvas class="a-color-picker-a a-color-picker-transparent"></canvas> <div class=a-color-picker-dot></div> </div> </div> </div> <div class="a-color-picker-row a-color-picker-hsl" show-on-hsl> <label>H</label> <input nameref=H type=number maxlength=3 min=0 max=360 value=0> <label>S</label> <input nameref=S type=number maxlength=3 min=0 max=100 value=0> <label>L</label> <input nameref=L type=number maxlength=3 min=0 max=100 value=0> </div> <div class="a-color-picker-row a-color-picker-rgb" show-on-rgb> <label>R</label> <input nameref=R type=number maxlength=3 min=0 max=255 value=0> <label>G</label> <input nameref=G type=number maxlength=3 min=0 max=255 value=0> <label>B</label> <input nameref=B type=number maxlength=3 min=0 max=255 value=0> </div> <div class="a-color-picker-row a-color-picker-rgbhex a-color-picker-single-input" show-on-single-input> <label>HEX</label> <input nameref=RGBHEX type=text select-on-focus> </div> <div class="a-color-picker-row a-color-picker-palette"></div>'
            }, function(t, e, n) {
                var r = n(6);
                t.exports = "string" == typeof r ? r : r.toString()
            }, function(t, e, n) {
                (t.exports = n(7)(!1)).push([t.i, "/*!\n * a-color-picker\n * https://github.com/narsenico/a-color-picker\n * \n * Copyright (c) 2017-2018, Gianfranco Caldi.\n * Released under the MIT License.\n */.a-color-picker{background-color:#fff;padding:0;display:inline-flex;flex-direction:column;user-select:none;width:232px;font:400 10px Helvetica,Arial,sans-serif;border-radius:3px;box-shadow:0 0 0 1px rgba(0,0,0,.05),0 2px 4px rgba(0,0,0,.25)}.a-color-picker,.a-color-picker-row,.a-color-picker input{box-sizing:border-box}.a-color-picker-row{padding:15px;display:flex;flex-direction:row;align-items:center;justify-content:space-between;user-select:none}.a-color-picker-row-top{padding:0}.a-color-picker-row:not(:first-child){border-top:1px solid #f5f5f5}.a-color-picker-column{display:flex;flex-direction:column}.a-color-picker-cell{flex:1 1 auto;margin-bottom:4px}.a-color-picker-cell:last-child{margin-bottom:0}.a-color-picker-stack{position:relative}.a-color-picker-dot{position:absolute;width:14px;height:14px;top:0;left:0;background:#fff;pointer-events:none;border-radius:50px;z-index:1000;box-shadow:0 1px 2px rgba(0,0,0,.75)}.a-color-picker-a,.a-color-picker-h,.a-color-picker-sl{cursor:cell}.a-color-picker-a+.a-color-picker-dot,.a-color-picker-h+.a-color-picker-dot{top:-2px}.a-color-picker-a,.a-color-picker-h{border-radius:2px}.a-color-picker-preview{box-sizing:border-box;width:30px;height:30px;user-select:none;border-radius:15px}.a-color-picker-circle{border-radius:50px;border:1px solid #eee}.a-color-picker-hsl,.a-color-picker-rgb,.a-color-picker-single-input{justify-content:space-evenly}.a-color-picker-hsl>label,.a-color-picker-rgb>label,.a-color-picker-single-input>label{padding:0 8px;flex:0 0 auto;color:#969696}.a-color-picker-hsl>input,.a-color-picker-rgb>input,.a-color-picker-single-input>input{text-align:center;padding:2px 0;width:0;flex:1 1 auto;border:1px solid #e0e0e0;line-height:20px}.a-color-picker-hsl>input::-webkit-inner-spin-button,.a-color-picker-rgb>input::-webkit-inner-spin-button,.a-color-picker-single-input>input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}.a-color-picker-hsl>input:focus,.a-color-picker-rgb>input:focus,.a-color-picker-single-input>input:focus{border-color:#04a9f4;outline:none}.a-color-picker-transparent{background-image:linear-gradient(-45deg,#cdcdcd 25%,transparent 0),linear-gradient(45deg,#cdcdcd 25%,transparent 0),linear-gradient(-45deg,transparent 75%,#cdcdcd 0),linear-gradient(45deg,transparent 75%,#cdcdcd 0);background-size:11px 11px;background-position:0 0,0 -5.5px,-5.5px 5.5px,5.5px 0}.a-color-picker-sl{border-radius:3px 3px 0 0}.a-color-picker.hide-alpha [show-on-alpha],.a-color-picker.hide-hsl [show-on-hsl],.a-color-picker.hide-rgb [show-on-rgb],.a-color-picker.hide-single-input [show-on-single-input]{display:none}.a-color-picker-clipbaord{width:100%;height:100%;opacity:0;cursor:pointer}.a-color-picker-palette{flex-flow:wrap;flex-direction:row;justify-content:flex-start;padding:10px}.a-color-picker-palette-color{width:15px;height:15px;flex:0 1 15px;margin:3px;box-sizing:border-box;cursor:pointer;border-radius:3px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.1)}.a-color-picker-palette-add{text-align:center;line-height:13px;color:#607d8b}", ""])
            }, function(t, e) {
                t.exports = function(t) {
                    var e = [];
                    return e.toString = function() {
                        return this.map(function(e) {
                            var n = function(t, e) {
                                var n = t[1] || "",
                                    r = t[3];
                                if (!r) return n;
                                if (e && "function" == typeof btoa) {
                                    var i = function(t) {
                                            return "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(t)))) + " */"
                                        }(r),
                                        o = r.sources.map(function(t) {
                                            return "/*# sourceURL=" + r.sourceRoot + t + " */"
                                        });
                                    return [n].concat(o).concat([i]).join("\n")
                                }
                                return [n].join("\n")
                            }(e, t);
                            return e[2] ? "@media " + e[2] + "{" + n + "}" : n
                        }).join("")
                    }, e.i = function(t, n) {
                        "string" == typeof t && (t = [
                            [null, t, ""]
                        ]);
                        for (var r = {}, i = 0; i < this.length; i++) {
                            var o = this[i][0];
                            "number" == typeof o && (r[o] = !0)
                        }
                        for (i = 0; i < t.length; i++) {
                            var a = t[i];
                            "number" == typeof a[0] && r[a[0]] || (n && !a[2] ? a[2] = n : n && (a[2] = "(" + a[2] + ") and (" + n + ")"), e.push(a))
                        }
                    }, e
                }
            }])
        }
    }
]);